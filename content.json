{"meta":{"title":"Snow Huose","subtitle":"","description":"前路漫漫，唯心作伴","author":"libieke","url":"https://libieke.github.io/blog","root":"/blog/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-22","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-22","excerpt":""}],"posts":[{"title":"JS扩展知识","text":"vue属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 计算属性// vue2 computed: &#123; // &quot;计算属性名&quot;:()&#123;&#125;, &quot;计算属性名&quot;: &#123; // 想要给计算属性赋值, 需要使用set方法 set(值)&#123; &#125;, get()&#123; return 值 &#125; &#125; &#125;// vue3const haveChineseName = computed&lt;string&gt;(() =&gt; &#123; return onePeople.chineseName.length &gt; 0 ? &quot;有中文名&quot; : &quot;没有&quot;&#125;)// 监听// vue2 watch: &#123; 变量名: &#123; // 在监视的数据发生变化时被调用 handler(newVal，oldVal)&#123; //监听info对象变化 console.log(&quot;newVal&quot;,newVal) &#125;, deep: true, // 深度侦听(对象里面层的值改变) immediate: true // 立即侦听(网页打开handler执行一次) &#125; &#125;// vue3 watch([count, name], ([newCount, newName],[oldCount,oldName])=&gt;&#123; console.log(`count或者name变化了，[newCount, newName],[oldCount,oldName]`) &#125;, &#123; deep: true， immediate: true // 立刻监听 &#125;),// 页面的首次加载就会执行,不需要配置，使用哪个就监听哪个 watchEffect(onInvalidate =&gt; &#123; console.log(`$&#123;sum.person.age&#125; 的值变化了！`) onInvalidate(() =&gt; &#123; console.log(&#x27;清除副作用函数执行了！&#x27;) &#125;) &#125;) // watchEffect取消监听 const stop = watchEffect(() =&gt; &#123; console.log(nameObj.name); setTimeout(() =&gt; &#123; stop(); &#125;, 5000); &#125;); 节流防抖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 节流：n秒内只运行一次，若在n 秒内重复触发，只有一次生效// 搜索框搜索输入。只需用户最后一次输入完，再发送请求// 手机号、邮箱验证输入检测onchange /oninput事件// 窗口大小计算。只需窗口调整完成后，计算窗口大小。防止重复渲染// 使用时间戳实现 function throttle(func, delay)&#123; //定义初始时间(开始触发事件的时间) var start = 0; return function()&#123; var that = this; var args = arguments; //获取当前时间戳 var current = Date.now(); // 判断当前时间与初始时间是否超过间隔 if(current - start &gt;= delay)&#123; //执行事件处理程序 func.call(that, args) //更新初始时间 start = current; &#125; &#125; &#125;// 使用定时器实现 function throttle(func, delay)&#123; var timer = null; return function()&#123; var that = this; var args = arguments if(!timer)&#123; timer = setTimeout(function()&#123; //执行事件处理程序 func.call(that, args) //事件执行完后把定时器清除掉，下次触发事件的时候再设置 timer = null; &#125;, delay) &#125; &#125; &#125;// 防抖：n秒后在执行该事件，若在n秒内被重复触发，则重新计时。用户高频事件完了，再进行事件操作// 懒加载、滚动加载、加载更多或监听滚动条位置// 防止高频点击提交，防止表单重复提交//防抖主要使用定时器来实现 function debounce(func, delay)&#123; var timer = null; return function()&#123; var that = this; var args = arguments //每次触发事件 都把定时器清掉重新计时 clearTimeout(timer) timer = setTimeout(function()&#123; //执行事件处理程序 func.call(that, args) &#125;, delay) &#125; &#125; JS深浅拷贝 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//浅拷贝：//1.手动遍历复制对象属性function CopyObject(obj) &#123; const copy = &#123;&#125;; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; copy[key] = obj[key]; &#125; &#125; return copy;&#125;const ABC = &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27; &#125;;const ABCCopy = CopyObject(ABC);//2. 扩展运算符（…）const ABC = &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27; &#125;;const ABCCopy = &#123; ...ABC &#125;;//3. Object.assign()const ABC = &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27; &#125;;const ABCCopy = Object.assign(&#123;&#125;, ABC);//4.Object.create()const ABC = &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27; &#125;;const ABCCopy = Object.create(ABC);//5. Array.slice()const ABC = [1, 2, 3, 4, 5];const ABCCopy = ABC.slice(1,2);console.log(ABC) //[ 1, 2, 3, 4, 5 ]console.log(ABCCopy) //[ 2 ]//6. Array.concat()const ABC = [1, 2, 3, 4, 5];const ABCCopy = [999,888,777].concat(ABC);console.log(ABC) //[1, 2, 3, 4, 5]console.log(ABCCopy) //[999,888,777,1,2,3,4,5]//7.Array.from() 复制数组Array.from(arrayLike [, mapFunction [, thisArg]])// arrayLike: 要转换成数组的对象或可迭代对象。//mapFunction（可选）: 对数组中的每个元素执行的映射函数。//thisArg（可选）: 映射函数中 this 的值。const ABC = [1, 2, 3, 4, 5];const ABCCopy = Array.from(ABC);//8. 使用 slice() 复制字符串const ABC = &quot;Hello, World!&quot;;const ABCCopy = ABC.slice(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 深拷贝：// 1.使用第三方库，Lodash中的cloneDeep()方法,npm i lodash //安装依赖库const _ = require(&quot;lodash&quot;);const ABC = &#123; key1: &quot;value1&quot;, key2: &quot;value2&quot;, abc: &#123; key3: &quot;value3&quot;, key4: &quot;value4&quot;, &#125;,&#125;;// 使用深拷贝库，如Lodash中的_.cloneDeep()const deepCopy = _.cloneDeep(ABC);// 修改深拷贝的第一层元素deepCopy.key1 = &quot;第一层元素&quot;;// 修改深拷贝的嵌套对象deepCopy.abc.key3 = &quot;嵌套对象&quot;;console.log(ABC);// &#123;// key1: &#x27;value1&#x27;,// key2: &#x27;value2&#x27;,// abc: &#123; key3: &#x27;value3&#x27;, key4: &#x27;value4&#x27; &#125;// &#125;console.log(deepCopy);// &#123;// key1: &#x27;第一层元素&#x27;,// key2: &#x27;value2&#x27;,// abc: &#123; key3: &#x27;嵌套对象&#x27;, key4: &#x27;value4&#x27; &#125;// &#125;//2.递归手动实现function deepCopy(obj) &#123; if (typeof obj !== &quot;object&quot; || obj === null) &#123; return obj; &#125; let result = Array.isArray(obj) ? [] : &#123;&#125;; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = deepCopy(obj[key]); &#125; &#125; return result;&#125;const ABC = &#123; key1: &quot;value1&quot;, key2: &#123; abc: &quot;abcValue&quot; &#125; &#125;;const deepCopyObj = deepCopy(ABC);//3.JSON 序列化与反序列化(JSON.parse和JSON.stringify)const ABC = &#123; key1: &quot;value1&quot;, key2: &#123; abc: &quot;abcValue&quot; &#125; &#125;;const deepCopyObj = JSON.parse(JSON.stringify(ABC)); 对象相关方法 12345678910111213141516171819202122232425262728// 阻止修改对象：1. Object.preventExtensions（阻止扩展）：禁止添加属性和方法，可以被修改或删除;实施操作：Object.preventExtensions()；检测是否应用该操作：Object.isExtensible()2. Object.seal（密封）：禁止删除、添加，可修改;实施操作：Object.seal();检测是否应用该操作：Object.isSealed()3. Object.freeze（冻结）：禁止删除、添加、修改，所有字段均只读;实施操作：Object.freeze()；检测是否应用该操作：Object.isFrozen()4. Object.defineProperties(对象名, &quot;添加属性名&quot;, &#123; // 属性值参数(具体值/函数) value: &quot;&quot;, enumerable, // 默认false, 控制是否可以便利 writable, //默认false, 控制是否可以修改 configurable, //默认false, 控制是否可以删除 get() &#123; // 读取时，调用 &#125;, set() &#123; // 修改时，调用 &#125;,&#125;);5. Object.assign(目标对象,源对象) //对象的合并,将源对象的所有可 枚举（便利）属性复制到目标对象里面去;第一个参数是目标对象， //后面的参数是源对象，将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的;实行的是浅拷贝 12345678910111213141516171819202122232425262728293031323334353637// 对象便利//1.for…in… 会遍历对象中所有的可枚举属性const obj = &#123; itemA: &quot;itemA&quot;, itemB: &quot;itemB&quot;,&#125;;// 使用Object.create创建一个原型为obj的对象 （模拟继承来的属性）var newObj = Object.create(obj);newObj.newItemA = &quot;newItemA&quot;;newObj.newItemB = &quot;newItemB&quot;;// 现在我们将其中的一个属性变为不可枚举属性Object.defineProperty(newObj, &quot;newItemA&quot;, &#123; enumerable: false,&#125;)for (i in newObj) &#123; console.log(i);&#125;//2.Object.keys()会返回一个包括所有的可枚举的自有 属性 的名称组成的数组const result = Object.keys(newObj)console.log(result) // [&quot;newItemB&quot;]//3.Object.values()会返回一个包括所有的可枚举的自有 属性值 的名称组成的数组const result = Object.values(newObj)console.log(result) //4.Object.getOwnPropertyNames() 会返回自有属性的名称const result = Object.getOwnPropertyNames(newObj)console.log(result) // [&#x27;newItemA&#x27;,&#x27;newItemB&#x27;]//5.Object.entries(obj)可枚举属性的键值对数组//6.Object.is(&#123;&#125;, &#123;&#125;) 它用来比较两个值是否严格相等，严格比较运算符（===） 数组相关方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 对原数组有改变的方法1.push（）末尾添加数据 2.pop（）末尾处删除数据3.unshift（）头部添加数据4.shifr（）头部删除数据5.reverse（）翻转数组6.sort（）排序7.splice（）截取数组// 不改变原数组的方法1.concat（）合并数组2.join（）数组转字符串3.slice（）截取数组的一部分数据4.indexOf 从左检查数组中有没有这个数值5.lastIndexOf 从右检查数组中有没有这个数值// ES6新增的数组方法1、forEach（）用来循环遍历的for2、map 映射数组的3.filter 过滤数组4.every 判断数组是不是满足所有条件5.some（）数组中有没有满足条件的6.find（）用来获取数组中满足条件的第一个数据7.reduce（）叠加后的效果 var arr = [1, 20, 35, 44, 50] console.log( arr);//[1, 20, 35, 44, 50] var res = arr.reduce(function (result,item) &#123; return result+item; &#125;) console.log(res);//150 闭包相关 12345闭包：1.闭包：指有权访问另一个函数作用域中的变量的函数。2.被闭包函数访问的父级及以上的函数的局部变量（如范例中的局部变量 i ）会一直存在于内存中，不会被 JS 的垃圾回收机制回收。3.闭包函数实现了对其他函数内部变量的访问。（函数内部的变量对外是无法访问的，闭包通过这种变通的方法，实现了访问。）4 闭包的用途：访问函数内部的变量，让变量始终保持在内存中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//1.返回值 最常用的function fn() &#123; var name = &quot;hello&quot;; return function () &#123; return name; &#125;;&#125;// 2.函数赋值var fnc = fn();console.log(fnc()); //hellovar fn2;function fn() &#123; var name = &quot;hello&quot;; //将函数赋值给fn2 fn2 = function () &#123; return name; &#125;;&#125;fn(); //要先执行进行赋值，console.log(fn2()); //执行输出fn2// 3.函数参数function fn() &#123; var name = &quot;hello&quot;; return function callback() &#123; return name; &#125;;&#125;var fn1 = fn(); //执行函数将返回值（callback函数）赋值给fn1，function fn2(f) &#123; //将函数作为参数传入 console.log(f()); //执行函数，并输出&#125;fn2(fn1); //执行输出fn2// 4.循环赋值//每秒执行1次，分别输出1-10for (var i = 1; i &lt;= 10; i++) &#123; (function (j) &#123; //j来接收 setTimeout(function () &#123; console.log(j); &#125;, j * 1000); &#125;)(i); //i作为实参传入&#125;// 5.节流函数// &lt;head&gt;// &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot;&gt;// &lt;style&gt;// *&#123;// margin:0;padding:0;// &#125;// &lt;/style&gt;// &lt;/head&gt;// &lt;body&gt;// &lt;div class=&quot;box&quot; id=&quot;div_box&quot; &gt;// &lt;button onclick=&quot;fn1()&quot;&gt;test&lt;/button&gt;// &lt;/div&gt;// &lt;/body&gt;function throttle(fn, delay) &#123; var flag = false; var timer = null; return function () &#123; var args = [].slice.call(arguments, 0); //将参数转成数组 var context = this; if (flag) &#123; //如果在限定的时间内 flag是true 则直接返回，不让执行 return; &#125; flag = true; //函数正在控制中 //执行函数 fn.apply(context, args); clearTimeout(timer); //清除定时器 timer = setTimeout(function () &#123; flag = false; //延时时间过了以后，放开函数控制 &#125;, delay); &#125;;&#125;function fn() &#123; console.log(123);&#125;var fn1 = throttle(fn, 2000); //绑定节流函数 Vue组件传值6种方法 Props（父向子） 1234567891011121314151617181920212223242526272829&lt;!-- 父组件代码： --&gt;&lt;template&gt; &lt;ChildComponent :parentValue=&quot;valueFromParent&quot; /&gt;&lt;/template&gt;&lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; data() &#123; return &#123; valueFromParent: &quot;这是父组件的数据&quot;, &#125;; &#125;, components: &#123; ChildComponent, &#125;, &#125;;&lt;/script&gt;&lt;!-- 子组件代码 --&gt;&lt;template&gt; &lt;div&gt;&#123;&#123; parentValue &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; parentValue: String, // 接收并展示来自父组件的值 &#125;, &#125;;&lt;/script&gt; 自定义事件（子向父） 123456789101112&lt;template&gt; &lt;button @click=&quot;emitValue&quot;&gt;点击传递数据&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; emitValue() &#123; this.$emit(&quot;childEvent&quot;, &quot;这是子组件传递的数据&quot;); &#125;, &#125;, &#125;;&lt;/script&gt; $refs 和直接调用方法 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 子组件代码： --&gt;&lt;template&gt; &lt;div ref=&quot;childRef&quot;&gt;...&lt;/div&gt; &lt;button @click=&quot;sendData&quot;&gt;发送数据&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; sendData() &#123; this.$emit(&quot;dataSent&quot;, this.someData); &#125;, &#125;, &#125;;&lt;/script&gt;&lt;!-- 父组件代码： --&gt;&lt;template&gt; &lt;ChildComponent ref=&quot;child&quot; @dataSent=&quot;handleData&quot; /&gt;&lt;/template&gt;&lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; methods: &#123; handleData(data) &#123; console.log(&quot;通过事件接收的数据:&quot;, data); &#125;, callChildMethod() &#123; // 使用 $refs 访问子组件实例并调用方法 this.$refs.child.sendData(); &#125;, &#125;, components: &#123; ChildComponent, &#125;, &#125;;&lt;/script&gt; Vuex(跨多个层级组件间的通信):直接从 store 中获取 …mapGetters([‘getSharedData’]) 123456789101112131415161718192021222324// store.jsimport Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; sharedData: null, &#125;, mutations: &#123; setSharedData(state, data) &#123; state.sharedData = data; &#125;, &#125;, actions: &#123; updateSharedData(&#123; commit &#125;, newData) &#123; commit(&quot;setSharedData&quot;, newData); &#125;, &#125;, getters: &#123; getSharedData(state) &#123; return state.sharedData; &#125;, &#125;,&#125;); 12345678910111213141516171819// 任何组件内&lt;template&gt; &lt;button @click=&quot;updateData&quot;&gt;更新共享数据&lt;/button&gt; &lt;AnotherComponent /&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapActions, mapGetters &#125; from &quot;vuex&quot;; export default &#123; computed: &#123; ...mapGetters([&quot;getSharedData&quot;]), &#125;, methods: &#123; ...mapActions([&quot;updateSharedData&quot;]), updateData() &#123; this.updateSharedData(&#123; some: &quot;new data&quot; &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; Event Bus（允许任意组件之间进行通信）： 123// eventBus.jsimport Vue from &quot;vue&quot;;export const EventBus = new Vue(); 123456789101112131415&lt;!-- 发送事件组件： --&gt;&lt;template&gt; &lt;button @click=&quot;sendMessage&quot;&gt;发送消息&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import &#123; EventBus &#125; from &quot;./eventBus&quot;; export default &#123; methods: &#123; sendMessage() &#123; EventBus.$emit(&quot;customEvent&quot;, &#123; message: &quot;Hello from component A!&quot; &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 1234567891011121314&lt;script&gt; import &#123; EventBus &#125; from &quot;./eventBus&quot;; export default &#123; created() &#123; EventBus.$on(&quot;customEvent&quot;, (data) =&gt; &#123; console.log(&quot;Received message:&quot;, data.message); &#125;); &#125;, beforeDestroy() &#123; // 不要忘记在组件销毁时解绑事件监听器以避免内存泄漏 EventBus.$off(&quot;customEvent&quot;); &#125;, &#125;;&lt;/script&gt; provide&#x2F;inject:Vue 提供了 provide 和 inject API 来实现祖先组件向后代组件提供依赖的方式（无需中间传递） 12345678910111213141516171819202122232425//祖先组件提供数据：&lt;script&gt; export default &#123; provide() &#123; return &#123; ancestorData: this.someData, &#125;; &#125;, data() &#123; return &#123; someData: &quot;来自祖先的数据&quot;, &#125;; &#125;, &#125;;&lt;/script&gt;// 后代组件注入数据&lt;script&gt; export default &#123; inject: [&quot;ancestorData&quot;], mounted() &#123; console.log(&quot;从祖先获取的数据:&quot;, this.ancestorData); &#125;, &#125;;&lt;/script&gt;","path":"2024/08/22/JS扩展知识/","date":"08-22","excerpt":"","tags":[{"name":"前端","slug":"前端","permalink":"https://libieke.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"webapis小细节","text":"易错点和注意事项 到底使用的是querySelector 还是 querySelectorAll ，关键看获取的是一个还是多个 到底要不要写for循环，看操作的是不是元素集合伪数组，如果是元素集合伪数组，就需要for循环遍历操作处理。 伪数组，也有数字下标，也是从0开始的。 要不要使用${} ${} 的使用是在 反引号里面来使用的，反引号表示是个字符串 所以不涉及到反引号，不涉及字符串的化，就不要书写 ${} 了 是属性还是方法 属性不需要括号 方法是需要的 1234567// 能记住最好，记不住就通过console.log() 输出来看是属性还是方法console.log( box.innerHTML ) // 是结果console.log( box.classList.add ) // 是function，说明add是方法box.innerHTML = &#x27;哈哈&#x27; // innerHTML是属性box.classList.add(&#x27;abc&#x27;) // add 是方法，需要括号调用 到底要不要加引号 我们操作的值如果是字符串，就需要带引号 如果非字符串，就可以不用引号 1234box.style.opacity = &quot;none&quot;// &quot;none&quot; 这个值是字符串类型数据，需要有引号// 如果直接写 none 会报错，当成变量来查找none 给元素注册事件的时候，到底要不要使用事件委托呢 当给多个元素注册事件的时候，可以使用事件委托来优化 并且当给动态生成的元素来注册事件的时候，使用事件委托来实现。 操作内容，到底是通过 innerHTML 还是 value 属性 对于像 div span ul li p 等标签，操作内容使用 innerHTML 或 innerText 来实现 但是对于像表单元素 input、单选、多选、文本域等，操作内容就需要通过 value 属性来操作了 特殊的：button按钮的内容是需要通过 innerText 或 innerHTML 来设置了 设置样式的时候，是否需要单位px 对于style设置样式，大部分需要带单位px 比如fontSize、width 、height 但对于层级z-index ，背景系列background不需要 另外三大家族的scrollTop的值是不需要单位px的","path":"2024/05/14/易错点和注意事项/","date":"05-14","excerpt":"","tags":[{"name":"前端","slug":"前端","permalink":"https://libieke.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"什么是 RESTful 接口规范","text":"&#x2F;&#x2F; 5个标准格式组成:&#x2F;&#x2F; 新增 post body[data] &#x2F;api&#x2F;news&#x2F;book&#x2F;&#x2F; 修改 put body[data ] &#x2F;api&#x2F;news&#x2F;book&#x2F;修改的ID&#x2F;&#x2F; 删除 delete body[data] &#x2F;api&#x2F;news&#x2F;book&#x2F;删除的ID&#x2F;&#x2F; 查询 get&#x2F;&#x2F; 查询列表 query[params] &#x2F;api&#x2F;news&#x2F;book&#x2F;&#x2F;&#x2F; 查询单个 &#x2F;api&#x2F;news&#x2F;book&#x2F;查询ID &#x2F;&#x2F;查询列表 export const getDepertListApi &#x3D; (params) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department’, method: ‘get’, params })}&#x2F;&#x2F;查询单个 export const getDepertInfoApi &#x3D; (id) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘ + id, method: ‘get’ })}&#x2F;&#x2F;增加 export const addDepertListApi &#x3D; (data) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘, method: ‘post’, data })}&#x2F;&#x2F;修改 export const editDepartmentListApi &#x3D; (data) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘ + data.id, method: ‘put’, data })}&#x2F;&#x2F;删除export const delDepartmentListApi &#x3D; (id) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘ + id, method: ‘delete’ })}","path":"2024/05/14/补充/","date":"05-14","excerpt":"&#x2F;&#x2F; 5个标准格式组成:&#x2F;&#x2F; 新增 post body[data] &#x2F;api&#x2F;news&#x2F;book&#x2F;&#x2F; 修改 put body[data ] &#x2F;api&#x2F;news&#x2F;book&#x2F;修改的ID&#x2F;&#x2F; 删除 delete body[data] &#x2F;api&#x2F;news&#x2F;book&#x2F;删除的ID&#x2F;&#x2F; 查询 get&#x2F;&#x2F; 查询列表 query[params] &#x2F;api&#x2F;news&#x2F;book&#x2F;&#x2F;&#x2F; 查询单个 &#x2F;api&#x2F;news&#x2F;book&#x2F;查询ID","tags":[]},{"title":"制作小程序简历","text":"制作小程序简历 使用微信小程序云开发制作自己的个人简历，简单高效。首先需要了解小程序的基本结构以及云开发模式，及一些css样式基础。使用小程序云数据库、vant组件库实现简历内容。 代码如下：index.json 123456789101112&#123; &quot;usingComponents&quot;: &#123; //引入vant组件 &quot;van-progress&quot;: &quot;@vant/weapp/progress/index&quot;, &quot;van-divider&quot;: &quot;@vant/weapp/divider&quot;, &quot;van-tag&quot;: &quot;@vant/weapp/tag/index&quot;, &quot;van-collapse&quot;: &quot;@vant/weapp/collapse/index&quot;, &quot;van-collapse-item&quot;: &quot;@vant/weapp/collapse-item/index&quot;, &quot;van-panel&quot;: &quot;@vant/weapp/panel/index&quot;, &quot;van-toast&quot;: &quot;@vant/weapp/toast/index&quot; &#125;&#125; index.wxml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&#123;&lt;swiper indicator-dots=&quot;&#123;&#123;indicatorDots&#125;&#125;&quot; autoplay=&quot;&#123;&#123;autoplay&#125;&#125;&quot;&gt; &lt;!-- 第一个页面 --&gt; &lt;swiper-item&gt; &lt;image class=&#x27;background&#x27; src=&quot;../../images/user.jpg&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt; &lt;view class=&quot;myMsg&quot;&gt; &lt;view class=&quot;name&quot;&gt; &lt;text&gt;李&lt;/text&gt; &lt;text&gt;七&lt;/text&gt; &lt;text&gt;月&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;myText&quot;&gt; 我的简历 &lt;image class=&quot;rightImg&quot; src=&quot;../../images/right.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 走马灯 --&gt; &lt;swiper class=&quot;swiperUser&quot; indicator-dots=&quot;&#123;&#123;indicatorDotsUser&#125;&#125;&quot; autoplay=&quot;&#123;&#123;autoplayUser&#125;&#125;&quot; interval=&quot;&#123;&#123;intervalUser&#125;&#125;&quot; duration=&quot;&#123;&#123;durationUser&#125;&#125;&quot; vertical=&quot;&#123;&#123;verticalUser&#125;&#125;&quot; circular=&quot;&#123;&#123;circularUser&#125;&#125;&quot; display-multiple-items=&quot;&#123;&#123;2&#125;&#125;&quot;&gt; &lt;block wx:for=&quot;&#123;&#123;userlist&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;swiper-item class=&quot;swiperItemUser&quot;&gt; &lt;view class=&quot;swiperItemUserMsg&quot;&gt; &lt;image class=&quot;userImg&quot; src=&quot;&#123;&#123;item.userImg&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;view class=&quot;zanWord&quot;&gt;&#123;&#123;item.name&#125;&#125;刚刚赞了你一下&lt;/view&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; &lt;view class=&quot;myJob&quot;&gt; &lt;view&gt;程序员&lt;/view&gt; &lt;text class=&quot;jobYear&quot;&gt;N年项目经验&lt;/text&gt; &lt;button class=&quot;zanBtn&quot; wx:if=&quot;&#123;&#123;canIUse&#125;&#125;&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;bindGetUserInfo&quot;&gt; &lt;image class=&quot;zanImg&quot; src=&quot;../../images/zan.png&quot;&gt;&lt;/image&gt; &lt;block&gt;点个赞吧&lt;/block&gt; &lt;/button&gt; &lt;van-toast id=&quot;van-toast&quot; /&gt; &lt;/view&gt; &lt;!-- 第二个页面 --&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;van-divider contentPosition=&quot;left&quot; customStyle=&quot;font-size: 30px;margin-bottom:20px;&quot;&gt;基本资料&lt;/van-divider&gt; &lt;view class=&quot;myData&quot;&gt; &lt;view&gt;姓名：李七&lt;/view&gt; &lt;view&gt;年龄：27&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;myData&quot;&gt; &lt;view&gt;电话：175****8021&lt;/view&gt; &lt;view&gt;性别：男&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;myData&quot;&gt;邮箱：1234@qq.com&lt;/view&gt; &lt;view class=&quot;myData marginBottom&quot;&gt;地址：安徽合肥（6号线）&lt;/view&gt; &lt;van-divider contentPosition=&quot;left&quot; customStyle=&quot;font-size: 30px;&quot;&gt;主要技能&lt;/van-divider&gt; &lt;view class=&quot;mainSkill&quot;&gt; &lt;view class=&quot;skillItems&quot;&gt; HTML+CSS+JavaScript &lt;/view&gt; &lt;van-progress percentage=&quot;50&quot; stroke-width=&quot;8&quot; color=&quot;&quot; show-pivot=&quot;&#123;&#123;indicatorDots&#125;&#125;&quot; /&gt; &lt;view class=&quot;skillItems&quot;&gt; MySql+Linux+Nginx &lt;/view&gt; &lt;van-progress percentage=&quot;75&quot; stroke-width=&quot;8&quot; color=&quot;&quot; show-pivot=&quot;&#123;&#123;indicatorDots&#125;&#125;&quot; /&gt; &lt;view class=&quot;skillItems&quot;&gt; Redis+Memcached &lt;/view&gt; &lt;van-progress percentage=&quot;65&quot; stroke-width=&quot;8&quot; color=&quot;&quot; show-pivot=&quot;&#123;&#123;indicatorDots&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;skillList&quot;&gt; &lt;view class=&quot;tabIcon&quot; wx:for=&quot;&#123;&#123;skillList&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;van-tag plain size=&quot;&#123;&#123;item.size&#125;&#125;&quot; type=&quot;&#123;&#123;item.type&#125;&#125;&quot; bindtap=&quot;vanMax&quot; data-id=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&#123;&#123;item.name&#125;&#125; &lt;/van-tag&gt; &lt;/view&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;!-- 第三个页面 --&gt; &lt;swiper-item&gt; &lt;van-divider contentPosition=&quot;left&quot; customStyle=&quot;font-size: 30px;margin-bottom:20px;&quot;&gt;工作经历&lt;/van-divider&gt; &lt;van-panel title=&quot;北京****科技有限公司&quot; desc=&quot;2016.05-2019.07&quot; status=&quot;PHP开发&quot;&gt; &lt;view class=&quot;conText&quot;&gt; &lt;text&gt;北京****科技有限公司是一家以鲜农产品为主的互联网电商公司，公司产业主要有鲜肉类、农产品类、及自营酒业，以社区经营模式进行线上销售、公司自主研发社区类游戏、自营电商及其他互联网项目累计用户30万。工作期间参与研发自营电商、线上游戏两大项目。 &lt;/text&gt; &lt;/view&gt; &lt;/van-panel&gt; &lt;van-panel title=&quot;北京**网络科技有限公司&quot; desc=&quot;2019.07-2020.05&quot; status=&quot;PHP开发&quot;&gt; &lt;view class=&quot;conText&quot;&gt; &lt;text&gt;北京**网络科技有限公司是一家创业型公司，主要业务以CPS广告模式推广，研发合成类小游戏，网络众包任务平台。公司成立蜘初加入，参与公司项目设计、项目搭建、及开发上线，项目迭代。 &lt;/text&gt; &lt;/view&gt; &lt;/van-panel&gt; &lt;/swiper-item&gt; &lt;!-- 第四个页面 --&gt; &lt;swiper-item&gt; &lt;van-divider contentPosition=&quot;left&quot; customStyle=&quot;font-size: 30px;margin-bottom:20px;&quot;&gt;项目经验&lt;/van-divider&gt; &lt;van-collapse value=&quot;&#123;&#123; activeName &#125;&#125;&quot; bind:change=&quot;onChange&quot; accordion&gt; &lt;van-collapse-item title=&quot;**星球App&quot; name=&quot;1&quot;&gt; 该项目是娱海网络公司自主研发App游戏，通过第三方cpm广告模式盈利，内置网络众包平台，用户可完成他人发布任务获取游戏积分。该项目由创业之初全程参与设计、项目搭建，使用Laravel框架开发，微信登录，公众号认证，微信企业付款到零钱、阿里企业付款，主要负责用户师徒体系、宠物商店、活跃任务、企业付款，众包平台模块。 &lt;/van-collapse-item&gt; &lt;van-collapse-item title=&quot;**易购App&quot; name=&quot;2&quot;&gt; 该项目是大道农联公司自营电商项目，内置淘宝、京东、拼多多等主流电商优惠券返利模式，同时搭建自营商品，主要负责淘宝客返利佣金结算，自营商城搭建，商品sku系统及商城活动。 &lt;/van-collapse-item&gt; &lt;van-collapse-item title=&quot;***H5&quot; name=&quot;3&quot;&gt; 该项目是大道农联公司自行研发的H5游戏，模拟宠物合成、宠物交易等虚拟宠物市场，内容丰富，玩法多样。使用Laravel框架开发，Laravel-admin搭建后台管理系统，后台使用echars图表数据分析，支付方式使用微信支付。主要负责用户个人中心、仓库管理、消息通知、微信付款、交易走势及模拟微信拼手气红包，不定期游戏活动。 &lt;/van-collapse-item&gt; &lt;van-collapse-item title=&quot;**商城&quot; name=&quot;4&quot;&gt; 该项目是大道农联公司第一版商城，使用ThinkPHP搭建，商城内置分销系统、会员返利机制。此项目前后端、数据库及后台均独立开发完成，业务大致分用户系统、订单流程、邀请机制，奖励机制等模块。使用第三方短信验证登录、七牛上传、phpExcel导出，第三方银行卡支付。 &lt;/van-collapse-item&gt; &lt;/van-collapse&gt; &lt;/swiper-item&gt;&lt;/swiper&gt;&#125; index.wxss 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158page &#123; width: 100%; height: 100%; overflow: hidden; background-color: ;&#125;swiper &#123; display: block; height: 100%;&#125;.swiper-img &#123; width: 100%; height: 100%;&#125;/* 第一屏 */.background &#123; width: 100%; height: 100%; position: fixed; background-size: 100% 100%; z-index: -1;&#125;.myMsg&#123; display: flex; align-items: flex-start; justify-content: space-between; padding:30rpx 20rpx 0 80rpx; box-sizing: border-box;&#125;.name&#123; font-size: 70rpx; font-family: &#x27;Times New Roman&#x27;, Times, serif; font-weight: 600; color:; display: flex; align-items: center; justify-content: center; flex-direction: column;&#125;.myText&#123; display: flex; align-items: center; justify-content: end; font-size:40rpx; color:; margin-top:30rpx;&#125;.rightImg&#123; width:40rpx; height:40rpx; margin-left:10rpx;&#125;.myJob&#123; position: fixed; bottom:100rpx; left:0; right:0; background:rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; flex-direction: column; font-size: 70rpx; color:; padding:30rpx 0; box-sizing: border-box;&#125;.jobYear&#123; font-size: 40rpx; margin-top:10rpx;&#125;/* 第二屏 */.myData&#123; display: flex; align-items: center; justify-content: space-between; padding: 0 100rpx 0 40rpx; box-sizing: border-box; margin-bottom: 10rpx;&#125;.marginBottom&#123; margin-bottom: 40rpx;&#125;.mainSkill&#123; padding:0 40rpx; box-sizing: border-box;&#125;.skillItems&#123; padding:40rpx 10rpx 20rpx 10rpx; box-sizing: border-box;&#125;.skillList&#123; display: flex; align-items: center; justify-content: flex-start; flex-wrap: wrap; padding: 50rpx 40rpx; box-sizing: border-box;&#125;.tabIcon&#123; margin-right:20rpx; margin-bottom:20rpx;&#125;.van-tag--large&#123; font-size: 50rpx !important;&#125;.van-tag--medium &#123; font-size: 30rpx !important;&#125;.conText&#123; font-size: 30rpx; color: ; padding: 50rpx 30rpx; box-sizing: border-box; text-indent: 2em; text-align: justify;&#125;.swiperUser&#123; width:100%; height:170rpx; margin-top:30rpx;&#125;.swiperItemUser&#123; width:auto !important; padding:0 30rpx 0 0;&#125;.swiperItemUserMsg&#123; /* height:100rpx; */ display: flex; align-items: center; margin-bottom:10rpx; margin-left:10rpx; padding:0 30rpx 0 0; background:rgba(0,0,0,0.3); border-radius:100rpx;&#125;.userImg&#123; width:70rpx; height:70rpx; border-radius: 50%; margin-right:10rpx;&#125;.zanBtn&#123; display: flex; align-items: center; justify-content: center; font-size: 36rpx; font-weight: 600; color:rgba(67, 5, 5, 0.851); margin-top:10rpx;&#125;.zanImg&#123; width:46rpx; height:46rpx; margin-right:10rpx;&#125; index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205import Toast from &#x27;@vant/weapp/toast/toast&#x27;;//标签数组const skillList=[ &#123; name: &quot;PHP&quot;, type:&quot;danger&quot;, size:&quot;large&quot;&#125;, &#123; name: &quot;Redis&quot;, type:&quot;primary&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;MySql&quot;, type:&quot;success&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;缓存&quot;, type:&quot;primary&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;分布锁&quot;, type:&quot;danger&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;Laravel&quot;, type:&quot;success&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;ThinkPHP&quot;, type:&quot;danger&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;支付&quot;, type:&quot;primary&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;后台&quot;, type:&quot;warning&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;Laravel-admin&quot;, type:&quot;danger&quot;, size:&quot;medium&quot;&#125;, &#123; name: &quot;LNMP&quot;, type:&quot;success&quot;, size:&quot;medium&quot;&#125;,];const db=wx.cloud.database();Page( &#123; /** * 页面的初始数据 */ data: &#123; // 全屏swiper 配置indicatorDots: false,autoplay: false,// 走马灯swiper配置indicatorDotsUser:false,//不要swiper点autoplayUser:true,//自动切换intervalUser:5000,//自动切换时长durationUser:1000,//滑动时长verticalUser:true,//滑动方向 纵向circularUser:true,//采用衔接滑动skillList:skillList,activeName:&#x27;1&#x27;,canIUse: wx.canIUse(&#x27;button.open-type.getUserInfo&#x27;),userlist:[] &#125;, //切换标签放大效果 vanMax:function(event)&#123; console.log(&quot;v&quot;) let id = event.target.dataset.id; let data = skillList data.forEach(Element =&gt; &#123; console.log(Element); Element.size = &quot;medium&quot; &#125;); data[id].size = &quot;large&quot; this.setData(&#123; skillList:data &#125;) &#125;, //vant组件 onChange(event) &#123; this.setData(&#123; activeName: event.detail, &#125;); &#125;, //点赞记录用户信息，更新弹幕列表 bindGetUserInfo (e) &#123; let userInfo = e.detail.userInfo let addData = &#123; name:userInfo.nickName, userImg:userInfo.avatarUrl &#125; db.collection(&#x27;userInfo&#x27;).add(&#123; data: &#123; name:userInfo.nickName, userImg:userInfo.avatarUrl &#125;, success:res =&gt;&#123; console.log(res) Toast.success(&#x27;点赞成功！&#x27;); this.setData(&#123; userlist:this.data.userlist.concat(addData) &#125;) &#125;, fail: err =&gt;&#123; console.log(res); &#125; &#125;) &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; //获取点赞用户db.collection(&#x27;userInfo&#x27;).field(&#123; name:true, userImg:true&#125;).get().then( res =&gt;&#123; console.log(res) this.setData(&#123; userlist:res.data &#125;)&#125;).catch( err =&gt;&#123; console.log(err)&#125;) &#125; /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; console.log(this.data.userlist);// this.getUserInfo() &#125; /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 注意注意需在小程序云数据库中，添加”userInfo”集合，用于储存点赞用户信息，页面加载前会获取用户信息 以上就是小程序版个人简历的全部代码，具体审核流程，参照微信小程序审核文档。","path":"2024/05/14/小程序简历/","date":"05-14","excerpt":"","tags":[]},{"title":"vue开发","text":"安装好脚手架 创建项目命令 1vue create hm-news 安装组件 123456yarn add vant@2 # 注意版本，封装utils/vant.js中，按需导入---main.js// npm i vant@2 yarn add babel-plugin-import -D # 适配yarn add amfe-flexible # import &#x27;amfe-flexible&#x27; 导入main.jsyarn add postcss-pxtorem -D # 将 px 转换为 remyarn add axios # 封装进 utils/request.js，创建一个自定义的 axios 来使用 配置环境 .prettierrc 格式化 1234567&#123; &quot;semi&quot;: false, &quot;singleQuote&quot;: true, &quot;trailingComma&quot;: &quot;none&quot;, &quot;htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;&#125; .eslintrc.js 格式化 123456789101112131415161718module.exports = &#123; root: true, env: &#123; node: true &#125;, extends: [&#x27;plugin:vue/essential&#x27;, &#x27;@vue/standard&#x27;], parserOptions: &#123; parser: &#x27;@babel/eslint-parser&#x27; &#125;, rules: &#123; &#x27;no-console&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;warn&#x27; : &#x27;off&#x27;, &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;warn&#x27; : &#x27;off&#x27;, // 把Eslint的这个规则给关闭掉（函数名和小括号之间不需要有空格） &#x27;space-before-function-paren&#x27;: &#x27;off&#x27;, &#x27;vue/multi-word-component-names&#x27;: &#x27;off&#x27; &#125;&#125; babel.config.js rem适配 123456789101112131415module.exports = &#123; presets: [&#x27;@vue/cli-plugin-babel/preset&#x27;], plugins: [ [ &#x27;import&#x27;, &#123; libraryName: &#x27;vant&#x27;, libraryDirectory: &#x27;es&#x27;, style: true &#125;, &#x27;vant&#x27; ] ]&#125; 提供 postcss 的配置文件postcss.config.js 123456789module.exports = &#123; plugins: &#123; &#x27;postcss-pxtorem&#x27;: &#123; // 1rem的大小 750 rootValue: 37.5, propList: [&#x27;*&#x27;], &#125;, &#125;,&#125; 文件目录配置 src 下面 12345671. ajax代码统一放在 api目录下2. 静态资源放在 assets 目录下3. css放样式放在 styles文件夹中4. 路由文件在 router 目录下5. vuex的仓库数据放在 store 目录下；其他分页面的可以新建一个 modules 文件夹6. ajax请求根目录封装一个js文件、vant（三方组件）、存储js文件，放在 utils 目录下7. 各页面一级路由直接放在 views 中，若有二级页面则 views/二级页面（记得加上二级路由）","path":"2024/05/14/vue开发项目/","date":"05-14","excerpt":"安装好脚手架 创建项目命令 1vue create hm-news 安装组件 123456yarn add vant@2 # 注意版本，封装utils/vant.js中，按需导入---main.js// npm i vant@2 yarn add babel-plugin-import -D # 适配yarn add amfe-flexible # import &#x27;amfe-flexible&#x27; 导入main.jsyarn add postcss-pxtorem -D # 将 px 转换为 remyarn add axios # 封装进 utils/request.js，创建一个自定义的 axios 来使用","tags":[{"name":"前端","slug":"前端","permalink":"https://libieke.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"","text":"生命周期 概念：一组件从 创建 到 销毁 的整个过程就是生命周期 1.1_钩子函数 目标: Vue 框架内置函数，随着组件的生命周期阶段，自动执行 作用: 特定的时间点，执行特定的操作 场景: 组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据 分类: 4大阶段8个方法 阶段 方法名 方法名 初始化 beforeCreate created 挂载 beforeMount mounted 更新 beforeUpdate updated 销毁 beforeDestroy destroyed 1.2_初始化阶段 目标: 掌握初始化阶段2个钩子函数作用和执行时机 含义讲解: 1.new Vue() – Vue实例化(组件也是一个小的Vue实例) 2.Init Events &amp; Lifecycle – 初始化事件和生命周期函数 3.beforeCreate – 生命周期钩子函数被执行 4.Init injections&amp;reactivity – Vue内部添加data和methods等 5.created – 生命周期钩子函数被执行, 实例创建 6.接下来是编译模板阶段 –开始分析 7.Has el option? – 是否有el选项 – 检查要挂到哪里 ​ 没有. 调用$mount()方法 ​ 有, 继续检查template选项 12345678910111213141516171819202122232425&lt;script&gt;export default &#123; data()&#123; return &#123; msg: &quot;hello, Vue&quot; &#125; &#125;, // 一. 初始化 // new Vue()以后, vue内部给实例对象添加了一些属性和方法, data和methods初始化&quot;之前&quot; beforeCreate()&#123; console.log(&quot;beforeCreate -- 执行&quot;); console.log(this.msg); // undefined &#125;, // data和methods初始化以后 // 场景: 网络请求, 注册全局事件 created()&#123; console.log(&quot;created -- 执行&quot;); console.log(this.msg); // hello, Vue this.timer = setInterval(() =&gt; &#123; console.log(&quot;哈哈哈&quot;); &#125;, 1000) &#125;&#125;&lt;/script&gt; App.vue - 引入使用 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;1. 生命周期&lt;/h1&gt; &lt;Life&gt;&lt;/Life&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Life from &#x27;./components/Life&#x27;export default &#123; components: &#123; Life &#125;&#125;&lt;/script&gt; 1.3_挂载阶段 目标: 掌握挂载阶段2个钩子函数作用和执行时机 含义讲解: 1.template选项检查 ​ 有 - 编译template返回render渲染函数 ​ 无 – 编译el选项对应标签作为template(要渲染的模板) 2.虚拟DOM挂载成真实DOM之前 3.beforeMount – 生命周期钩子函数被执行 4.Create … – 把虚拟DOM和渲染的数据一并挂到真实DOM上 5.真实DOM挂载完毕 6.mounted – 生命周期钩子函数被执行 components&#x2F;Life.vue - 创建一个文件 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt; &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // ...省略其他代码 // 二. 挂载 // 真实DOM挂载之前 // 场景: 预处理data, 不会触发updated钩子函数 beforeMount()&#123; console.log(&quot;beforeMount -- 执行&quot;); console.log(document.getElementById(&quot;myP&quot;)); // null this.msg = &quot;重新值&quot; &#125;, // 真实DOM挂载以后 // 场景: 挂载后真实DOM mounted()&#123; console.log(&quot;mounted -- 执行&quot;); console.log(document.getElementById(&quot;myP&quot;)); // p &#125;&#125;&lt;/script&gt; 1.4_更新阶段 目标: 掌握更新阶段2个钩子函数作用和执行时机 含义讲解: 1.当data里数据改变, 更新DOM之前 2.beforeUpdate – 生命周期钩子函数被执行 3.Virtual DOM…… – 虚拟DOM重新渲染, 打补丁到真实DOM 4.updated – 生命周期钩子函数被执行 5.当有data数据改变 – 重复这个循环 components&#x2F;Life.vue - 创建一个文件 准备ul+li循环, 按钮添加元素, 触发data改变-&gt;导致更新周期开始 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;p&gt;学习生命周期 - 看控制台打印&lt;/p&gt; &lt;p id=&quot;myP&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;ul id=&quot;myUL&quot;&gt; &lt;li v-for=&quot;(val, index) in arr&quot; :key=&quot;index&quot;&gt; &#123;&#123; val &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;arr.push(1000)&quot;&gt;点击末尾加值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; msg: &quot;hello, Vue&quot;, arr: [5, 8, 2, 1] &#125; &#125;, // ...省略其他代码 // 三. 更新 // 前提: data数据改变才执行 // 更新之前 beforeUpdate()&#123; console.log(&quot;beforeUpdate -- 执行&quot;); console.log(document.querySelectorAll(&quot;#myUL&gt;li&quot;)[4]); // undefined &#125;, // 更新之后 // 场景: 获取更新后的真实DOM updated()&#123; console.log(&quot;updated -- 执行&quot;); console.log(document.querySelectorAll(&quot;#myUL&gt;li&quot;)[4]); // li &#125;&#125;&lt;/script&gt; 1.5_销毁阶段 目标: 掌握销毁阶段2个钩子函数作用和执行时机 含义讲解: 1.当$destroy()被调用 – 比如组件DOM被移除(例v-if) 2.beforeDestroy – 生命周期钩子函数被执行 3.拆卸数据监视器、子组件和事件侦听器 4.实例销毁后, 最后触发一个钩子函数 5.destroyed – 生命周期钩子函数被执行 components&#x2F;Life.vue - 准备生命周期方法(Life组件即将要被删除) 12345678910111213141516&lt;script&gt;export default &#123; // ...省略其他代码 // 四. 销毁 // 前提: v-if=&quot;false&quot; 销毁Vue实例 // 场景: 移除全局事件, 移除当前组件, 计时器, 定时器, eventBus移除事件$off方法 beforeDestroy()&#123; // console.log(&#x27;beforeDestroy -- 执行&#x27;); clearInterval(this.timer) &#125;, destroyed()&#123; // console.log(&quot;destroyed -- 执行&quot;); &#125;&#125;&lt;/script&gt; 主要: App.vue - 点击按钮让Life组件从DOM上移除 -&gt; 导致Life组件进入销毁阶段 12345678910&lt;Life v-if=&quot;show&quot;&gt;&lt;/Life&gt;&lt;button @click=&quot;show = false&quot;&gt;销毁组件&lt;/button&gt;&lt;script&gt; data()&#123; return &#123; show: true &#125; &#125;,&lt;/script&gt; 2.0_axios基本使用特点 支持客户端发送Ajax请求 支持服务端Node.js发送请求 支持Promise相关用法 支持请求和响应的拦截器功能 自动转换JSON数据 axios 底层还是原生js实现, 内部通过Promise封装的 axios的基本使用 123456789101112131415axios(&#123; method: &#x27;请求方式&#x27;, // get post url: &#x27;请求地址&#x27;, data: &#123; // 拼接到请求体的参数, post请求的参数 xxx: xxx, &#125;, params: &#123; // 拼接到请求行的参数, get请求的参数 xxx: xxx &#125;&#125;).then(res =&gt; &#123; console.log(res.data) // 后台返回的结果&#125;).catch(err =&gt; &#123; console.log(err) // 后台报错返回&#125;) 2.1_axios基本使用-获取数据 目标: 调用文档最后_获取所有图书信息接口 功能: 点击调用后台接口, 拿到所有数据 – 打印到控制台 接口: 参考预习资料.md – 接口文档 引入: 下载axios, 引入后才能使用 components&#x2F;UseAxios.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取所有图书信息&lt;/p&gt; &lt;button @click=&quot;getAllFn&quot;&gt;点击-查看控制台&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标1: 获取所有图书信息// 1. 下载axios// 2. 引入axios// 3. 发起axios请求import axios from &quot;axios&quot;;export default &#123; methods: &#123; getAllFn() &#123; axios(&#123; url: &quot;http://123.57.109.30:3006/api/getbooks&quot;, method: &quot;GET&quot;, // 默认就是GET方式请求, 可以省略不写 &#125;).then((res) =&gt; &#123; console.log(res); &#125;); // axios()-原地得到Promise对象 &#125;, &#125;&#125;;&lt;/script&gt; 2.2_axios基本使用-传参 目标: 调用接口-获取某本书籍信息 功能: 点击调用后台接口, 查询用户想要的书籍信息 – 打印到控制台 接口: 参考预习资料.md – 接口文档 例子如下: components&#x2F;UseAxios.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;p&gt;2. 查询某本书籍信息&lt;/p&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入要查询 的书名&quot; v-model=&quot;bName&quot; /&gt; &lt;button @click=&quot;findFn&quot;&gt;查询&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;export default &#123; data() &#123; return &#123; bName: &quot;&quot; &#125;; &#125;, methods: &#123; // ...省略了查询所有的代码 findFn() &#123; axios(&#123; url: &quot;/api/getbooks&quot;, method: &quot;GET&quot;, params: &#123; // 都会axios最终拼接到url?后面 bookname: this.bName &#125; &#125;).then(res =&gt; &#123; console.log(res); &#125;) &#125; &#125;,&#125;;&lt;/script&gt; 2.3_axios基本使用-发布书籍 目标: 完成发布书籍功能 功能: 点击新增按钮, 把用户输入的书籍信息, 传递给后台 – 把结果打印在控制台 接口: 参考预习资料.md – 接口文档 例子如下: components&#x2F;UseAxios.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div&gt; &lt;p&gt;3. 新增图书信息&lt;/p&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;书名&quot; v-model=&quot;bookObj.bookname&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;作者&quot; v-model=&quot;bookObj.author&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;出版社&quot; v-model=&quot;bookObj.publisher&quot;&gt; &lt;/div&gt; &lt;button @click=&quot;sendFn&quot;&gt;发布&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;export default &#123; data() &#123; return &#123; bName: &quot;&quot;, bookObj: &#123; // 参数名提前和后台的参数名对上-发送请求就不用再次对接了 bookname: &quot;&quot;, author: &quot;&quot;, publisher: &quot;&quot; &#125; &#125;; &#125;, methods: &#123; // ...省略了其他代码 sendFn()&#123; axios(&#123; url: &quot;/api/addbook&quot;, method: &quot;POST&quot;, data: &#123; appkey: &quot;7250d3eb-18e1-41bc-8bb2-11483665535a&quot;, ...this.bookObj // 等同于下面 // bookname: this.bookObj.bookname, // author: this.bookObj.author, // publisher: this.bookObj.publisher &#125; &#125;) &#125; &#125;,&#125;;&lt;/script&gt; 2.4_axios基本使用-全局配置 目标: 避免前缀基地址, 暴露在逻辑页面里, 统一设置 123456789101112axios.defaults.baseURL = &quot;http://123.57.109.30:3006&quot;// 所有请求的url前置可以去掉, 请求时, axios会自动拼接baseURL的地址在前面getAllFn() &#123; axios(&#123; url: &quot;/api/getbooks&quot;, method: &quot;GET&quot;, // 默认就是GET方式请求, 可以省略不写 &#125;).then((res) =&gt; &#123; console.log(res); &#125;); // axios()-原地得到Promise对象&#125;, 3.0 $refs-获取DOM 目标: 利用 ref 和 $refs 可以用于获取 dom 元素 components&#x2F;More.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt; &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象export default &#123; mounted()&#123; console.log(document.getElementById(&quot;h&quot;)); // h1 console.log(this.$refs.myH); // h1 &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 总结: 通过id &#x2F; ref, 都可以获取原生DOM标签 3.1 $refs-获取组件对象 目标: 获取组件对象, 调用组件里方法 components&#x2F;Child&#x2F;Demo.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;p&gt;我是Demo组件&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fn()&#123; console.log(&quot;demo组件内的方法被调用了&quot;); &#125; &#125;&#125;&lt;/script&gt; More.vue - 获取组件对象 - 调用组件方法 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt; &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt; &lt;p&gt;2. 获取组件对象 - 可调用组件内一切&lt;/p&gt; &lt;Demo ref=&quot;de&quot;&gt;&lt;/Demo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123; mounted()&#123; console.log(document.getElementById(&quot;h&quot;)); // h1 console.log(this.$refs.myH); // h1 let demoObj = this.$refs.de; demoObj.fn() &#125;, components: &#123; Demo &#125;&#125;&lt;/script&gt; 总结: ref定义值, 通过$refs.值 来获取组件对象, 就能继续调用组件内的变量 3.2 $nextTick使用 Vue更新DOM-异步的 目标: 点击count++, 马上通过”原生DOM”拿标签内容, 无法拿到新值 components&#x2F;Move.vue - 继续新增第三套代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt; &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt; &lt;p&gt;2. 获取组件对象 - 可调用组件内一切&lt;/p&gt; &lt;Demo ref=&quot;de&quot;&gt;&lt;/Demo&gt; &lt;p&gt;3. vue更新DOM是异步的&lt;/p&gt; &lt;p ref=&quot;myP&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;btn&quot;&gt;点击count+1, 马上提取p标签内容&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123; mounted()&#123; console.log(document.getElementById(&quot;h&quot;)); // h1 console.log(this.$refs.myH); // h1 let demoObj = this.$refs.de; demoObj.fn() &#125;, components: &#123; Demo &#125;, data()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; btn()&#123; this.count++; // vue监测数据更新, 开启一个DOM更新队列(异步任务) console.log(this.$refs.myP.innerHTML); // 0 // 原因: Vue更新DOM异步 // 解决: this.$nextTick() // 过程: DOM更新完会挨个触发$nextTick里的函数体 this.$nextTick(() =&gt; &#123; console.log(this.$refs.myP.innerHTML); // 1 &#125;) &#125; &#125;&#125;&lt;/script&gt; 总结: 因为DOM更新是异步的 3.3 $nextTick使用场景 目标: 点击搜索按钮, 弹出聚焦的输入框, 按钮消失 components&#x2F;Tick.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;input ref=&quot;myInp&quot; type=&quot;text&quot; placeholder=&quot;这是一个输入框&quot; v-if=&quot;isShow&quot;&gt; &lt;button v-else @click=&quot;btn&quot;&gt;点击我进行搜索&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 点按钮(消失) - 输入框出现并聚焦// 1. 获取到输入框// 2. 输入框调用事件方法focus()达到聚焦行为export default &#123; data()&#123; return &#123; isShow: false &#125; &#125;, methods: &#123; async btn()&#123; this.isShow = true; // this.$refs.myInp.focus() // 原因: data变化更新DOM是异步的 // 输入框还没有挂载到真实DOM上 // 解决: // this.$nextTick(() =&gt; &#123; // this.$refs.myInp.focus() // &#125;) // 扩展: await取代回调函数 // $nextTick()原地返回Promise对象 await this.$nextTick() this.$refs.myInp.focus() &#125; &#125;&#125;&lt;/script&gt; 3.4 组件name属性使用 目标: 可以用组件的name属性值, 来注册组件名字 问题: 组件名不是可以随便写的? 答案: 我们封装的组件-可以自己定义name属性组件名-让使用者有个统一的前缀风格 components&#x2F;Com.vue 1234567891011&lt;template&gt; &lt;div&gt; &lt;p&gt;我是一个Com组件&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ComNameHaHa&quot; // 注册时可以定义自己的名字&#125;&lt;/script&gt; App.vue - 注册和使用 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;h1&gt;1. 生命周期&lt;/h1&gt; &lt;Life v-if=&quot;show&quot;&gt;&lt;/Life&gt; &lt;button @click=&quot;show = false&quot;&gt;销毁组件&lt;/button&gt; &lt;hr&gt; &lt;h1&gt;2. axios使用&lt;/h1&gt; &lt;UseAxios&gt;&lt;/UseAxios&gt; &lt;hr&gt; &lt;h1&gt;3. $refs的使用&lt;/h1&gt; &lt;More&gt;&lt;/More&gt; &lt;hr&gt; &lt;h1&gt;4. $nextTick使用场景&lt;/h1&gt; &lt;Tick&gt;&lt;/Tick&gt; &lt;hr&gt; &lt;h1&gt;5. 组件对象里name属性&lt;/h1&gt; &lt;ComNameHaHa&gt;&lt;/ComNameHaHa&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Life from &#x27;./components/Life&#x27;import UseAxios from &#x27;./components/UseAxios&#x27;import More from &#x27;./components/More&#x27;import Tick from &#x27;./components/Tick&#x27;import Com from &#x27;./components/Com&#x27;export default &#123; data()&#123; return &#123; show: true &#125; &#125;, components: &#123; Life, UseAxios, More, Tick, [Com.name]: Com // 对象里的key是变量的话[]属性名表达式 // &quot;ComNameHaHa&quot;: Com &#125;&#125;&lt;/script&gt;","path":"2024/05/14/vue-生命周期/","date":"05-14","excerpt":"","tags":[]},{"title":"JS原生轮播图例子","text":"JS原生轮播图 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;轮播图点击切换&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;slider&quot;&gt; &lt;div class=&quot;slider-wrapper&quot;&gt; &lt;img src=&quot;./images/slider01.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;slider-footer&quot;&gt; &lt;p&gt;对人类来说会不会太超前了？&lt;/p&gt; &lt;ul class=&quot;slider-indicator&quot;&gt; &lt;li class=&quot;active&quot; data-id=&quot;0&quot;&gt;&lt;/li&gt; &lt;li data-id=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-id=&quot;2&quot;&gt;&lt;/li&gt; &lt;li data-id=&quot;3&quot;&gt;&lt;/li&gt; &lt;li data-id=&quot;4&quot;&gt;&lt;/li&gt; &lt;li data-id=&quot;5&quot;&gt;&lt;/li&gt; &lt;li data-id=&quot;6&quot;&gt;&lt;/li&gt; &lt;li data-id=&quot;7&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;toggle&quot;&gt; &lt;button class=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt; &lt;button class=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 &lt;style&gt; * &#123; box-sizing: border-box; &#125; .slider &#123; width: 560px; height: 400px; overflow: hidden; &#125; .slider-wrapper &#123; width: 100%; height: 320px;&#125;.slider-wrapper img &#123; width: 100%; height: 100%; display: block;&#125;.slider-footer &#123; height: 80px; background-color: rgb(100, 67, 68); padding: 12px 12px 0 12px; position: relative;&#125;.slider-footer .toggle &#123; position: absolute; right: 0; top: 12px; display: flex;&#125;.slider-footer .toggle button &#123; margin-right: 12px; width: 28px; height: 28px; appearance: none; border: none; background: rgba(255, 255, 255, 0.1); border-radius: 4px; cursor: pointer;&#125;.slider-footer .toggle button:hover &#123; background: rgba(255, 255, 255, 0.2);&#125;.slider-footer p &#123; margin: 0; font-size: 18px; margin-bottom: 10px;&#125;.slider-indicator &#123; margin: 0; padding: 0; list-style: none; display: flex; align-items: center;&#125;.slider-indicator li &#123; width: 8px; height: 8px; margin: 4px; border-radius: 50%; opacity: 0.4; cursor: pointer;&#125;.slider-indicator li.active &#123; width: 12px; height: 12px; opacity: 1;&#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 &lt;script&gt; // 1. 初始数据 const data = [&#123; url: &#x27;./images/slider01.jpg&#x27;, title: &#x27;对人类来说会不会太超前了？&#x27;, color: &#x27;rgb(100, 67, 68)&#x27; &#125;, &#123; url: &#x27;./images/slider02.jpg&#x27;, title: &#x27;开启剑与雪的黑暗传说！&#x27;, color: &#x27;rgb(43, 35, 26)&#x27; &#125;, &#123; url: &#x27;./images/slider03.jpg&#x27;, title: &#x27;真正的jo厨出现了！&#x27;, color: &#x27;rgb(36, 31, 33)&#x27; &#125;, &#123; url: &#x27;./images/slider04.jpg&#x27;, title: &#x27;李玉刚：让世界通过B站看到东方大国文化&#x27;, color: &#x27;rgb(139, 98, 66)&#x27; &#125;, &#123; url: &#x27;./images/slider05.jpg&#x27;, title: &#x27;快来分享你的寒假日常吧~&#x27;, color: &#x27;rgb(67, 90, 92)&#x27; &#125;, &#123; url: &#x27;./images/slider06.jpg&#x27;, title: &#x27;哔哩哔哩小年YEAH&#x27;, color: &#x27;rgb(166, 131, 143)&#x27; &#125;, &#123; url: &#x27;./images/slider07.jpg&#x27;, title: &#x27;一站式解决你的电脑配置问题！！！&#x27;, color: &#x27;rgb(53, 29, 25)&#x27; &#125;, &#123; url: &#x27;./images/slider08.jpg&#x27;, title: &#x27;谁不想和小猫咪贴贴呢！&#x27;, color: &#x27;rgb(99, 72, 114)&#x27; &#125;, ] // 1. const img = document.querySelector(&#x27;.slider-wrapper img&#x27;) const p = document.querySelector(&#x27;.slider-footer p&#x27;) const footer = document.querySelector(&#x27;.slider-footer&#x27;) // 所有小圆点 const lis = document.querySelectorAll(&#x27;.slider-indicator li&#x27;) const prev = document.querySelector(&#x27;.prev&#x27;) const next = document.querySelector(&#x27;.next&#x27;) // 注册点击下一张事件 let i = 0//初始下标 // let k = 0 next.addEventListener(&#x27;click&#x27;, function () &#123; i++ // 数组长度为8，要设置衔接条件 if (i &gt;= data.length) &#123; i = 0//循环衔接 &#125; change(i) &#125;) // 注册点击上一张事件 prev.addEventListener(&#x27;click&#x27;, function () &#123; i-- // 数组长度为8，要设置衔接条件 if (i &lt; 0) &#123; i = data.length - 1//循环衔接 &#125; change(i) &#125;) // 自动播放事件 const slider = document.querySelector(&#x27;.slider&#x27;) let t = setInterval(function () &#123; next.click()//JS特性，跟随倒计时模仿点击下一次 &#125;, 1000) // 鼠标悬停停止 slider.addEventListener(&#x27;mouseenter&#x27;, function () &#123; clearInterval(t) &#125;) // 鼠标移出恢复播放 slider.addEventListener(&#x27;mouseleave&#x27;, function () &#123; t = setInterval(function () &#123; next.click() &#125;, 1000) &#125;) // 点击小圆点播放对应的图片,让下标对应 // for循环 for (let j = 0; j &lt; lis.length; j++) &#123; lis[j].addEventListener(&#x27;click&#x27;, function () &#123; i = j//若不给i赋值，它会一直自顾自的循环，不受控制 change(i) &#125;) &#125; // 委托事件做法 const ul = document.querySelector(&#x27;.slider-indicator&#x27;) // ul.addEventListener(&#x27;click&#x27;, function (e) &#123; // if (e.target.tagName === &#x27;LI&#x27;) &#123; // i = e.target.dataset.id//获取自定义id下标 // change(i) // &#125; // &#125;) // 函数封装公共部分 function change(j) &#123; // 替换内容 const obj = data[j]//方便书写 img.src = obj.url p.innerHTML = obj.title footer.style.backgroundColor = obj.color // 小圆点，排它思想 document.querySelector(&#x27;.slider-indicator .active&#x27;).classList.remove(&#x27;active&#x27;)//删除 lis[j].classList.add(&#x27;active&#x27;) &#125;&lt;/script&gt;","path":"2024/05/14/JS原生轮播图/","date":"05-14","excerpt":"","tags":[]},{"title":"GitHub找项目","text":"EXP :我想要找到一个自动化部署的项目，关键字为devops，语言是java，star为100以上的项目搜索条件就是：devops language:java stars:&gt;100 awesome xxx &#x2F;&#x2F;令人惊叹的xxx项目stars:&gt;xxx &#x2F;&#x2F; stars数大于xxxstars:xxx..yyy &#x2F;&#x2F; stars数在xxx和yyy之间的forks:&gt;xxx &#x2F;&#x2F; forks数大于xxxlanguage:xxx &#x2F;&#x2F; 编程语言是xxxin:name xxx 或xxx in:name &#x2F;&#x2F; 按照项目名搜索in:readme xxx 或xxx in:readme &#x2F;&#x2F; 按照README搜索in:description xxx 或xxx in:description &#x2F;&#x2F; 按照description搜索pushed:&gt;YYYY-MM-DD &#x2F;&#x2F; 最后更新时间大于YYYY-MM-DDlocation:xxx &#x2F;&#x2F;开发者位置在xxx，比如china，beijing，chengduuser:xxx &#x2F;&#x2F;查找某开发者下的所有仓库followers:&gt;&#x3D;xxx &#x2F;&#x2F;粉丝数大于xxx的开发者 说明： 冒号两侧不能有空格； 不区分大小写； 不能将以下通配符用作搜索查询的一部分，搜索将忽略这些符号：. , : ; &#x2F; \\ &#96; ’ “ &#x3D; * ! ? # $ &amp; + ^ | ~ &lt; &gt; ( ) { } [ ]； 搜索默认为master分支","path":"2024/05/14/github找项目/","date":"05-14","excerpt":"EXP :我想要找到一个自动化部署的项目，关键字为devops，语言是java，star为100以上的项目搜索条件就是：devops language:java stars:&gt;100","tags":[]},{"title":"Windowns终端","text":"Windowns终端外观配置 Windowns终端配置win11自带 WindowsTerminal，win10可以到自己电脑的微软商店搜索下载 配置个性化主题简单的一些设置通过 Oh My Posh，可以使用完整的颜色集来定义和呈现终端提示，包括能够使用内置主题或创建自己的自定义主题。 WindowsTerminal管理员权限在执行此命令，安装 Oh My Posh 1winget install oh-my-posh 选择主题，输入此命令可以查看各种样式的主题， 1Get-PoshThemes 并使用此命令打开 PowerShell 配置文件.（可以将 notepad 替换为你选择的文本编辑器。） 1notepad $PROFILE 将以下项添加到 PowerShell 配置文件的末尾，以设置 paradox 主题。 （将 paradox 替换为你选择的主题。） https://ohmyposh.dev/docs/themes 主题地址 12oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\paradox.omp.json&quot; | Invoke-Expressioncls # 加上这一行，可以在进入时候清除顶部的字段 主题需要配合字体使用，会更加美观，下载安装Nerd的字体 https://www.nerdfonts.com/font-downloads ctrl+f 复制 JetBrainsMono 下载后将字体保存在自己选择的文件夹，然后解压。Ctrl+A 全选，单击鼠标右键选择安装即可。 最后，打开 WindowsTerminal，win+r 输入wt 即可打开，点击右上方的下拉箭头，点设置 选择左边的 WindowsPowerShell ，右边拉到最下面，选择外观，可以看到字体选择，建议选择 JetBrainsMonoNL Nerd Font Mono 字体 下面还有背景图片等设置 配置git代码补全功能1.下载post-git离线安装包，自选下载路径，解压 ​ 地址：https://files.cnblogs.com/files/xcr1234/posh-git-master.zip 2.打开WindowsPowerShell，cd+你的下载路径解压路径，然后执行执行install.ps1 1./install.ps1 3.若不能修改则用管理员权限打开powershell，修改策略，再执行即可 1set-executionpolicy remotesigned","path":"2022/11/18/Windowns终端配置/","date":"11-18","excerpt":"","tags":[]},{"title":"前端资料","text":"H5+C3 html超文本标记语言day0101. 网页组成​ 文字 图片 视频 音频 链接 02. web标准​ 结构html、表现css、行为JavaScript 03. 注释​ ctrl+&#x2F; 解释说明代码 04. html骨架123456&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/html&gt; 05. h1-h6 标题标签双标签 独占一行 文字加粗 文字变大h1-h6逐渐变小 自带上下边距 06. 快捷键​ Alt+B 运行 ​ ctrl+D 出现多个光标 ​ shift+alt+下箭头 批量复制 07. 段落标签：1&lt;p&gt;&lt;/p&gt; 段落之间存在间隙 独占一行 08. 换行标签:1&lt;br&gt; 单标签 让文字强制换行 09. 水平线标签 :1&lt;hr&gt; 单标签 在页面显示一条水平线 10. 文本格式化标签: 语义 标签 说明 加粗 strong &#x2F; b strong 语义更强烈 倾斜 em &#x2F; i em 语义更强烈 删除线 del &#x2F; s del 语义更强烈 下划线 ins &#x2F; u ins 语义更强烈 11. 图片标签:1&lt;img src=&quot;图片路径&quot; width=&quot;宽度&quot; height=&quot;高度&quot; border=&quot;边框&quot; alt=&quot;替换文本&quot; title=&quot;提示文本&quot; &gt; 单标签 需借助属性 属性必须写在开始标签里面 属性和属性 属性和标签之间要有空格 属性 属性值 说明 src 图片路径 必填属性 alt 文本 替换文本，当图像不能显示时候，显示文本 title 文本 提示文本，当鼠标悬停在图像的时候显示文本 boder 像素 边框 width 像素 宽度（宽度和高度设置其中一个即可，因图片是等比例缩放） height 像素 高度（宽度和高度设置其中一个即可，因图片是等比例缩放） 12. 路径 绝对路径: 盘符开头&#x2F;完整地网络地址 相对路径: 同级目录(直接写目标文件名或.&#x2F;) 下级目录 (文件夹名&#x2F;目标文件) 上级目录(..&#x2F;目标文件) 13. 媒体标签音频标签: 1&lt;audio src=&quot;&quot; controls autoplay loop&gt;&lt;/audio&gt; src路径 controls控件 autoplay自动播放 loop循环 视频标签: 1&lt;video src=&quot;&quot; controls autoplay loop&gt;&lt;/video&gt; src路径 controls控件 autoplay自动播放需要配合muted静音播放 loop循环 14. 链接标签超链接: 1&lt;a href=&quot;&quot; target=&quot;&quot; title=&quot;&quot;&gt;&lt;/a&gt; 外部链接 内部链接 空链接 下载链接 图片链接 锚点链接 target属性:_self默认值 当前窗口跳转 _blank新窗口中跳转 锚点链接: 12&lt;h5 id=&quot;one&quot;&gt;&lt;/h5&gt;&lt;a href=&quot;#one&quot; target=&quot;_blank&quot;&gt; 跳转h5位置&lt;/a&gt; 15. 查文档MDN中文文档地址: https://developer.mozilla.org/zh-CN/ 现代JS教程地址: https://zh.javascript.info/ 菜鸟教程 day0201. 列表标签无序列表 有序列表 自定义列表 无序列表: 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; ul只能含li li可以含任意内容 li独占一行 前面有个小圆点有序列表: 123&lt;ol&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; ol只能含li li可以含任意内容自定义列表: 12345&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 一个dt对应多个dd 02. table表格标签书写方式12345678910111213141516171819202122232425&lt;table border=&quot;边框&quot; width=&quot;宽度&quot; height=&quot;高度&quot; cellspacing=&quot;单和单距离&quot; cellpadding=&quot;单和内距离&quot;&gt; &lt;!-- 表格标题 --&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;!-- 表格头部 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; ... &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 表格身体 --&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; ... &lt;/tr&gt; &lt;/tbody&gt; &lt;!-- 表格底部 --&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; ... &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; 03. 表格标签table(表格整体)&gt;tr(表格每行)&gt;td(单元格) 123&lt;caption&gt;写在&lt;table&gt;标签之间 &lt;table&gt;&lt;caption&gt;&lt;/caption&gt;&lt;/table&gt; 标签 属性 tr 行 th 表头单元格（加粗、居中效果）包含tr内(替换td) td 表格单元格 caption 表格标题 居中显示 04. 表格属性：以下表格属性写在标签里面 1&lt;table border=&quot;1&quot;&gt;&lt;/table&gt; 属性 属性值 说明 border 数值（无单位） 边框 width 数值（无单位） 宽度 height 数值（无单位） 高度 align 左：left &#x2F; 居中：center &#x2F; 右：right 水平对齐方式 cellspacing 数值（无单位） 单元格和单元格之间的距离，默认2像素 cellpadding 数值（无单位） 单元格和内容之间的距离，默认1像素 05. table表格构成：注意：table表格构成不支持合并； 标签名 名称 thead 表格头部 tbody 表格主体 tfoot 表格底部 06. 合并表格 写在tr&#x2F;th单元格里面 步骤: 1.明确合并方式 2.通过左上原则确定保留谁删除谁 3.给保留的单元格设置rowspan或colspan 多行多列合并 先合并列 再合并行 再删除多余的 不能跨结构合并单元格 属性 属性值 应用 rowspan 跨行合并（垂直方向） 保留最上的，删除其他的 colspan 跨列合并（水平方向） 保留最下的，删除其他的 07. 快捷键alt+shift点点&#x2F;按住鼠标滚轮向下拖 可同时选中竖列 shift+alt+F自动格式化 ctrl+shift +左右箭头可以在选中多行的时候移动光标 tab缩进 shift+tab向前缩进 快捷方式 table&gt;tr*&gt;td*2 08. input书写方式12345678&lt;form action=&quot;url地址&quot; method=&quot;提交方式post/get&quot; name=&quot;表单名&quot;&gt; &lt;input type=&quot;属性&quot; value=&quot;文本&quot; name=&quot;名字&quot;...&gt; &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt; &lt;/form&gt; 09. 表单域：form会把它范围内的表单元素信息提交给服务器. 属性 属性值 作用 action url地址 链接处理表单服务器的url地址 method get 显示信息 &#x2F; post 不显示信息 设置表单提交方式 name 表单名 区分同个页面的多个表单域 10. input 属性 号 属性 描述 1 type 元素的类型 2 name 名称 3 value 显示的文本值 5 checked 默认选中项 6 maxlength 设置字符个数 7 placeholder 占位符-提示语（当编辑的时候文字消失，不编辑的时候文字还原） 9 multiple 多个文件上传，需要：type&#x3D;”file” 搭配使用 10 required 必须填写内容不能为空 11 autofocus 自动获取焦点 12 autocomplete 用户输入信息并提交成功之后，会留下记录； 默认是on 开启的 off 关闭，注意急需要在表单内添加name属性名 11. type 属性 号 类型 含义 1 text 文本框 2 password 密码框 3 radio 单选按钮 4 checkbox 复选框 5 button 普通按钮（默认无功能，配合js添加功能使用） 6 submit 提交按钮（提交数据给后端服务器） 7 reset 重置按钮（点击之后恢复表单默认值） 8 image 图片按钮， 需要和src搭配使用 9 file 上传单个文件按钮 10 email 邮箱（邮箱格式） 11 url 网址 12 date 日期 13 time 时分秒 14 number 数字 15 tel 手机号（纯数字） 16 search 搜索 17 color 颜色按钮 12. 下拉菜单：select&gt;optionselected默认选中 1234&lt;select&gt; &lt;option&gt;xxx&lt;/option&gt; ...&lt;/select&gt; 13. 文本域：textarea1&lt;textarea rows=&quot;行&quot; cols=&quot;列&quot;&gt;提示内容&lt;textarea&gt; 14. 增加点击范围：label注意：需要和input标签搭配使用 1234567891.label和input并列式，label 需要添加for=&quot;name名&quot; input需要添加 id=&quot;name名&quot; 名字必须一致才可以做链接；&lt;input type=&quot;checkbox&quot; id=&quot;one&quot;&gt;&lt;label for=&quot;one&quot;&gt;敲代码&lt;/label&gt;2. label嵌套input，需要把form属性删除&lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt;熬夜&lt;/label&gt; 15. 按钮标签：button12345&lt;button type =&quot;按钮属性&quot;&gt;xxx&lt;/button&gt;属性： * submit:提交按钮 * reset:重置按 * button:普通按钮，后期搭配js进行使用。 16. 单选框实现单选一的效果设置相同的name属性值 checked默认选中 12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt;男 (默认选中男)&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 17. 无语义化标签（盒子布局标签） 标签 说明 div 独占一行，属于块级元素，可以设置宽高 span 一行可占多个，属于行内元素，不可以设置宽高 18. 有语义化标签注意：有语义化标签是针对于搜索引擎使用，可以多次使用，一般用在移动端口； ​ 其中在IE9中不兼容问题导致是行内元素，需要把这些元素转换为块级元素即可； 标签名 语义 header 头部 nav 导航 footer 底部 aside 侧边栏 section 定义某个文档区域–块级元素 article 内容 19. 特殊字符标签： 标签 说明 &amp;nbsp； 空格 &amp;lt； 小于号 &amp;gt； 大于号 CSS层叠样式表day0101. css层叠样式表给页面中的HTML标签设置样式使用 {}包含一个或多个样式声明；每条样式声明以键值对形式出现：属性: 值；属性和值之间使用 : 分隔 每个样式写完之后使用;结束 标点符号都是英文状态下的 02. css引入方式内嵌式(style标签里) 外联式(link标签引入) 行内式(标签的style属性中) 行内式 说明：写在html标签中，针对当前标签，一般配合js搭配使用 1&lt;标签名 style=&quot;属性：属性值;&quot;&gt;xxx&lt;/标签名&gt; 内嵌式 说明：写在head里面和title标题下面，针对于当前页面 123456&lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;style&gt; 选择器&#123;属性:属性值;&#125; &lt;/style&gt;&lt;/head&gt; 外链接式 说明：先新建一个css文件，然后到html文件–head标签里面写上link链接；针对于多个页面使用 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt; 03. 标签选择器 标签{属性:属性值;} 1div &#123; color: green;&#125; 04. 类选择器 .类名{属性:属性值;} 如: 1.box &#123; color: green;&#125; 1&lt;div class=&quot;box one&quot;&gt;&lt;/div&gt; 每个标签都可以设置class属性, class&#x3D;”类名” 以点+类名的形式显示类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头 05. id选择器id名{属性:属性值;} 如 1#box&#123; color: green;&#125;; 在一个页面中是唯一的，不可重复的 以#开头 06. 通配符选择器:12345*&#123; margin:0; padding:0;&#125; 清除标签的默认样式 基础选择器 优点 缺点 使用情况 用法 标签选择器 快速选出所有相同的标签 不能选择其中一个 较多 标签名{ } 类&#x2F;多类选择器 可以选出1个或多个标签 根据需求选择 非常多 . class名{ } id选择器 一次只能选择1个标签 只能在html设置一次 和js搭配使用 #id名{ } 通配符选择器 选择所有的标签 选择的太多，有部分不需要 特殊情况使用 * { } 07. 字体样式 font-size(px) font-weight(400&#x2F;700) font-style(normal italic) font-family(Microsoft YaHei sans-serif) 属性 作用 说明 font-size 字体大小 px 像素 font-family 字体样式 各种字体，可以写多个，字体之间用空格隔开 font-style 字体倾斜 italic 倾斜 、normal 不倾斜 font-weight 字体粗细 bold &#x3D; 700 加粗 、 normal &#x3D; 400 不加粗，取值100–900，数字后面没有单位； font： 字体连写 font: style weight size &#x2F;line-height family;注意：必须遵守前后顺序，其他的可以忽略掉,但是必须写字体大小和样式 08. 文本样式:文本 span标签、a标签、input标签、img标签等行内和行内块元素要水平居中 text-align : center 需要给以上元素的 父元素设置 属性 作用 说明 color 字体颜色 px text-indent 首行缩进 em&#x2F; 数值 1em &#x3D; 1个字符 ( text-indent: 2em; ) text-align 水平对齐方式 left 左对齐 &#x2F; center 居中对齐 &#x2F; right 右对齐 text-decroation 文本装饰 overline 添加上划线 &#x2F; underline 添加下划线 none 删除下划线 &#x2F; line-through 添加删除线 line-height 行高 px&#x2F;数值倍数 (上间距+文本高度+下间距) line-height&#x3D;height 单行文字垂直居中 09. margin : 0 auto可以通过margin : 0 auto ; 给 div、p、h(大盒子) 块级元素水平居中 独自占一行的标签 要先给宽度 如果大盒子没有设置宽度，此时会默认占满父元素的宽度 10. Chrome调试工具叹号报错 删除线层叠或注释 注释前面没有对钩 11. 常见颜色取值 rgba(a 0-1取值) 关键词 十六进制 day0201. 后代选择器说明：选择子孙后代，中间用空格隔开 1元素1 元素2 &#123;属性：属性值;...&#125; 02. 子代选择器说明：选亲儿子元素.用**&gt;（大于号）** 1元素1 &gt; 元素2 &#123;属性：属性值;...&#125; 03. 并集选择器说明：通常用于集体声明，和的意思，元素之间用逗号隔开； 注意：并集选择器需要竖排编写，最后一个元素不需要添加逗号； 1234元素1,元素2 &#123; 属性：属性值;...&#125; 04. 交集选择器说明：a) 由两个选择器构成， 第一个必须为标签选择器，第二个为class&#x2F;id选择器，针对某个标签设置； ​ b) 没有任何符号，连在一起的；即…又…的意思 1标签名1.选择器名&#123;属性1：值1;...&#125; 标签名2#id名&#123;属性1：值1;...&#125; 05. 链接伪类选择器符号： :(英文冒号) 注意：为确保样式生效，必须按照:link &#x2F; :visited &#x2F; :hover &#x2F; :active顺序编写；一般情况下使用:hover即可；任何元素都可以设置； 1234- 标签名:link /* 未访问的链接 */- 标签名:visited /* 已访问过的链接 */- 标签名:hover /* 悬停时链接 */- 标签名:active /* 按下时链接 */ 06. 结构伪类选择器符号： :(英文冒号) 权重是：0,0,1,0 n 如果是数字 就是选择第 n 个子元素 里面数字从1开始 如果n是公式从0开始计算 元素名 作用 :first-child 匹配父元素的第一个元素（同一种类型的子级） :last-child 匹配父元素的最后一个元素（同一种类型的子级） :nth-child(n) 匹配父元素的第n个元素，从头开始（同一种类型的子级） :nth-last-child(n) 匹配父元素倒数第n个元素，末尾开始（同一种类型的子级） 注意：(n) 分为数字、关键词（even偶数&#x2F;odd 奇数)、公式（注意n是从0开始）、单独写n代表全部 :nth-of-type(n) 指定同类型第n个 :nth-last-of-type(n) 指定同类型倒数第n个 :first-of-type 指定同类型的第一个 :last-of-type 指定同类型的最后一个 区别： nth-child ： 对父元素里面所有的孩子进行排序，nth-of-type: 对父元素里面指定同类型元素进行排序选择，先匹配元素，再找第n个孩子 首先看 E 指定的元素，之后再去看 :nth-of-type的第几个孩子 07. :focus 获取焦点的表单元素伪类选择器符号： :(英文冒号) 注意：需要和input表单属性搭配使用； 1input:focus&#123;属性：属性值;&#125; 08. :: placeholder 占位符伪元素选择器符号： ::(两个冒号) 注意：需要和input表单属性一起搭配使用； 1input::placeholder&#123;属性:属性值;&#125; 09. 属性选择器注意：[] 中括号里面的值可以是双引号&#x2F;单引号；属性选择器的权重是0,0,1,0 12345input[type]&#123;&#125;input[type=&quot;text&quot;]&#123;&#125;div[class^=&quot;icon&quot;]div[class$=&quot;txt&quot;]div[class*=&quot;icon&quot;] 选择器 含义 选择器[属性] 存在属性即可 选择器[属性&#x3D; “值”] 属性值完全等于值 选择器[属性 *&#x3D; “值”] 任意元素值 选择器[属性 ^&#x3D; “值”] 开始元素值 选择器[属性 $&#x3D; “值”] 结束元素值 10. 伪元素选择器::before &#x2F; ::after 权重是0,0,0,1 a ）选择器**::before** 在选择器内部的开始位置创建一个元素，为行内元素，必须要和 content属性使用。 1234div::before &#123; /* 注意：content 属性必须存在，否则无效，可以是单引号&#x27;xx&#x27;/ 双引号 &quot;xx&quot; 推荐使用单引号 content */ content:&quot;开始添加文字内容&quot;; &#125; b ) 选择器**::after** 在选择器内部的结束位置创建一个元素，为行内元素，必须要和 content属性使用。 1234div::after &#123; /* 注意：content 属性必须存在，否则无效，可以是单引号&#x27;xx&#x27;/ 双引号 &quot;xx&quot; 推荐使用单引号 content */ content:&quot;结束添加文字内容&quot;; &#125; c ) ::before 、 ::after 伪元素 注意事项： ​ 伪元素:before和:after添加的内容默认是行内元素； ​ 两个伪元素的content属性，表示伪元素的内容,设置:before和:after时必须设置其**content属性**，否则伪元素就不起作用。 ​ input img不支持伪元素 11. 选择器总结 选择器 作用 符号 后代选择器 子孙后代 空格隔开 子代选择器 选亲儿子 **&gt;(**大于号) 并集选择器 和的意思 **,**（英文逗号） 交集选择器 即….又…的意思 没有任何符号，连在一起写 伪类选择器 分为：链接&#x2F;结构&#x2F;获取表单元素焦点 :（英文冒号） 属性选择器 选取html属性值 [ ] (英文中括号) 伪元素选择器 必须和content搭配使用，否则无效 ::(两个冒号) 12. emmet语法1ul*2&gt;li*3 div.red div#red div&gt;p&#123;内容&#125;*3 div.red$ div&#123;$&#125;*3 div. red#pink css写首字母 13. 背景颜色：background-color1background-color: xxx; 14. 背景图片：background-image1background-image:url(图片路径); 15. 背景平铺：background-repeat1background-repeat: 平铺（默认）repeat / 不平铺 no-repeat / 纵向平铺 repeat-y / 横向平铺 repeat-x; 16. 背景位置：background-position1background-position: x | y ; 说明 说明 单位： px % 方向词 左：left 右：right 上：top 下：bottom 居中：center 1个值：其中固定的是居中 2个值：先左右水平位置 后上下垂直位置 方向名词没有前后顺序 单位有前后顺序，先是x 左右水平 后是y上下垂直 单位词和方向词可以混合编辑，分为先x 后y 混合单位(第一个取值水平，第二个取值垂直)方位名词可换顺序 精确单位(数字+px)和混合单位不可以 方位名词省略第二个默认居中 只指定一个数值 是X 另一个默认居中 17. 背景滚动&#x2F;固定：background-attachment1background-attachment:scorll; 滚动（默认） / fixed 固定; 18. 背景综合写法注意：属性是没有前后顺序区分的，推荐使用下方编写； 12background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置background:color image repeat attachment position; 19. 背景透明度：rgba透明取值：0~1之间，取值越小越透明； 写法：0.3 或者是 .3 1background：rgba(0~1); 20. 背景总结 背景图和背景色在盒子里不会溢出 属性 说明 背景颜色：background-color 颜色值&#x2F;十六进制&#x2F;rgb 背景图片：background-image url(图片路径) 背景平铺：background-repeat 平铺：repeat 不平铺：no-repeat x轴：repeat-x y轴：repeat-y 背景位置：background-position 分别是x和y坐标， 单位是px 和 方向名词 背景滚动：bakcground-attachment 背景滚动：scroll（默认） 背景固定：fixed 背景简写：bakcground: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 color image repeat attchment position 背景色半透明：background:rgba(red,green,blue,0~1)， 0~1透明色取值范围，取值越小越透明 21. img和背景图片区别 img标签可以撑开盒子,背景图片不可以撑开盒子(需要设置盒子的宽高) 22. 元素分类块级元素: 独占一行（一行只能显示一个） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高 可以存放其他行内元素和块级元素和文本 1如 div、p、h、ul、li、ol、dl p和h不能相互嵌套h p不能嵌套div/p 行内元素: 一行可以显示多个 宽度和高度默认由内容撑开 不可以设置宽高 只能容纳文本或其他行内元素 1如 span a em a标签可以嵌套任意元素(最好转换显示模式) a里面不可以嵌套a 行内块元素: 一行可以显示多个 可以设置宽高 如input button textarea img 23. 元素显示模式：display注意：三个元素可以相互转换： 行内转块级&#x2F;行内转行内块&#x2F;块级转行内块 元素名 属性 说明 display : block; 块级元素 独占一行，可以设置宽、高、内外边距，默认宽度是100% display : inline; 行内元素 一行占多个，不可以设置宽高，默认宽度就是内容的宽度 display : inline-block; 行内块元素 一行占多个，可以设置宽、高、内外边距默认宽度就是内容的宽度，盒子中间有间距 行内元素或块级元素转换成行内块元素若没有设置宽度和高度默认由内容撑开 24. css三大特性 CSS层叠性（就近原则） ​ a) 设置样式冲突时，遵循的是就近原则。（哪个样式离html近，就执行哪个样式） ​ b) 样式不冲突时，不会层叠，共同作用在标签上(前提选择器优先级相同) 。 CSS继承性（子承父业） ​ a) 指在父级书写CSS样式表时，子标签会继承父标签的某些样式（子承父业） ​ b) 可以继承元素：text-，font-，line-开头元素，color属性。 ​ c) 继承失效元素：a标签的颜色，h标题系列的大小、div盒子的高度但是宽度有类似于继承的效果； css优先级（等级） 权重叠加 不会有进位问题 贡献值（由小到大排序） 权重值 注意 继承元素 、*通配符选择器 0,0,0,0 1.权重可以叠加 标签选择器、伪元素选择器 0,0,0,1 2.数位之间没有进制 .类、：伪类选择器、[xx]属性选择器 0,0,1,0 3.值从左到右，从大到小依次排序 #ID选择器 0,1,0,0 4.!important 无穷大给父级元素添加无效 行内样式 1,0,0,0 5.∞给继承的选择器添加等级是无效的 !important（需要在样式属性值后面写）如：color : red!important; ∞ 无穷大 6. !important不能加在继承 写在;前 25. 去除列表默认样式给ul设置 list-style:none 属性， 26. 解决行内块元素之间默认间隙给父元素加font-size: 0; html行内或行内块元素不让换行 day0301. 盒子的组成content padding border margin 02. 边框复合写法123border : 10px solid red; border-left:10px solid red; /*也可单独设置上下边框等*/ 03. 内边距边框与内容区域 之间的距离 12345padding: 5px; 上下左右都是5px / padding: 5px 10px;上下5px左右10px padding: 5px 10px 20px; /*上5px左右10px下20px / padding: 5px 10px 20px 30px; 上右下左(顺时针)*/padding-top: 10px; /*也可以单独设置*/ 边框和内边距会撑大盒子 box-sizing: border-box; 解决边框和padding会撑开盒子的问题 一般导航栏 给a转成块级元素或者行内块设置高&#x2F;行高 不给宽用padding撑开盒子宽度 04. 外边距盒子与盒子之间的距离 1margin: 5px 10px 20px 30px; 上右下左(顺时针) (参考内边距) 05. 外边距折叠现象–合并现象垂直布局的块级元素上下的margin会合并 解决方法只给其中一个盒子设置margin 06. 外边距折叠现象–塌陷现象互相嵌套的块级元素，子元素的margin-top 会作用在父元素上解决方法: 1234给父元素设置border-top 或者 padding-top（分隔父子元素的margin-top）给父元素设置overflow：hidden(推荐使用) 转换成行内块元素设置浮动 07. 不会撑大盒子的特殊情况(块级元素) 子盒子没有指定宽度和高度 子盒子宽度默认就是父盒子的宽度 此时padding或者border不会撑大盒子 08. 行内元素的margin和padding无效情况 水平方向有效：设置左右的外边距和内边距是有效的 垂直方向无效：设置上下的外边距和内边距是无效的（想要垂直方向有效，必须转换为块级和行内块元素） magin padding 无法改变行内标签的垂直位置 可以通过行高改变 检查的时候 magin padding 会存在 但不改变位置 day0401. 浮动：早期作用：文字环绕 现在主要用于让垂直布局的盒子变成水平布局 02. 浮动特点浮动元素会脱离标准流(脱标) 浮动元素比标准流高半个级别，可以覆盖标准流中的元素 浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动 浮动元素会受到上面元素边界的影响 浮动元素会一行显示并且元素顶部对齐,可以设置宽高(行内块相似) 如果父级盒子宽度不够，子级的盒子浮动会自动换行 说明： 行内、块级元素只要加了浮动都会具有行内块元素特点，可以设置宽高，若是没有给盒子设置宽高，则以内容大小为准： 1float：left：左浮动 / right:右浮动 03. 清除浮动方式 清除浮动方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差 父级overflow:hidden; 书写简单 溢出隐藏 父级 :after伪元素 结构语义化正确 由于IE6-7版本不支持:after，兼容性问题 父级双元素 (:before :after ) 结构语义化正确 由于IE6-7版本不支持:after，兼容性问题 04. css书写顺序先放浮动定位 再放盒子模型 再放文字样式 建议遵循以下顺序： 布局定义属性：display&#x2F;position&#x2F;float&#x2F;clear&#x2F;visibility&#x2F;overflow(建议第一个写display) 自身属性：width&#x2F;height&#x2F;margin&#x2F;padding&#x2F;border&#x2F;background…. 文本属性：color&#x2F;font&#x2F;text-decoration&#x2F;text-align&#x2F;vertical-align&#x2F;white-space&#x2F;break-word…. 其他属性(CSS3) :content&#x2F;cursor&#x2F;border-radius&#x2F;box-shadow&#x2F;text-shadow&#x2F;background:linear-gradient… day0501. 项目规范写项目要建根目录 里面放该项目图片文件夹 css文件夹等 index是首页 写网页遵循从上到下，从里到外的原则 若一个区域是纯文字区域可以不给宽 用padding撑开 一般导航栏 给a转成块级元素或者行内块设置高&#x2F;行高 不给宽用padding撑开盒子宽度 02. 图片垂直居中123vertical-align:middle; 行内块和文字 行内块和行内块要居中对齐就用这个代码 若vertical-align和行高都无法对齐用定位 day0601. 网页布局组成 标准流 浮动 定位 02. 定位组成定位 &#x3D; 定位模式 + 边偏移 123position：static / relative / absolute / fixed;top/bottm/right/left:npx; 边偏移 left 和 right同时有会执行left top和bottom同时有执行top 属性1 属性2 属性3 属性4 顶端偏移：top 底部偏移：bottom 左侧偏移：left 右侧偏移：right 03. 定位模式 相对 绝对 固定定位;1position:static 自动定位（默认） / relative 相对定位 / absolute 绝对定位 / fixed 固定定位; ① 静态定位：static(标准流) 特点： 相对于标准流摆放位置，没有边偏移； ② 相对定位：relative（自恋型-不脱标） 123position: relative; left:50px; top:-30px; 特点： 不脱标，保留原位置； 相对于自己原来的位置移动（以左上角移动）； 通常是给绝对定位当爹来使用； ③ 绝对定位：absolute（拼爹性-完全脱标） 特点： 完全脱标，不占用原先位置； 具备行内块特点 需要配合方位属性实现移动 若是没有给父元素添加定位，则以浏览器为准； 若是父元素有定位（相对、绝对、固定定位），则以最近的父元素并且带有定位属性为准； 子绝父相：因父亲要占有位置，所以是相对定位，子盒子不需要占有位置，则是绝对定位； 绝对定位盒子居中：（因绝对定位的盒子不能通过margin实现水平居中） ​ a）left&#x2F;top：50%；先让父盒子50%移动到中心位置； ​ b）margin-left&#x2F;top：-盒子一半值，然后盒子走自身大小的一半负值； ​ 或者直接设置位移属性，transform:translate(-50%,-50%); ④ 固定定位：fixed（认死理型） 特点： 完全脱标，不占有原先位置； 以浏览器的可视窗口为准（浏览器显示的大小） 和父元素没有任何关系，不能跟随滚动条滚动 具备行内块特点 尽量设置宽度高度或者内容 小技巧：固定在版心右侧位置： ​ a ）让固定定位的盒子left：50%，走到浏览器可视区的一半位置； ​ b ）再让固定定位盒子margin-left：版心宽度的一般距离即可； ⑤ 粘性定位：sitcky 特点： ​ 以浏览器的可视窗口为移动元素（固定定位特点） ​ 不脱标，占有原先位置（相对定位特点) ​ 必须添加其中一个边偏移属性才有效（top、bottom、right、left） ​ 跟页面滚动搭配使用，兼容性较差，IE目前不支持此功能； 04. z-index :叠放次序层级关系：标准流 &lt; 浮动 &lt; 定位 相对、绝对、固定默认层级相同 html中后面的会覆盖前面的 1选择器&#123;z-index:数字;&#125; 必须配合定位才能生效 说明： ① 默认是auto&#x2F;0，取值：正整数、负整数、0，后面不能添加单位； ​ ② 取值越大，定位元素在层叠元素中越居上（里外）； ​ ③ 如果属性值相同，则按照书写顺序，后来者居上制定； ​ ④ 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性; 05. 定位特殊性绝对定位absolute 、 固定定位fixed 、浮动float 类似 ① 行内元素添加绝对定位&#x2F;固定定位，是可以直接设置高度和宽度； ② 块级元素添加绝对定位&#x2F;固定定位，若不给宽度和高度，默认大小是内容的大小； 06. 脱标的盒子不会出发外边距塌陷说明：浮动元素、绝对定位、固定定位元素都不会出发外边距合并的问题。 07. 绝对定位&#x2F;固定定位会完全压住盒子① 浮动元素： 只会压住它下面的标准流盒子，不会压住下面标准流盒子里面的文字&#x2F;图片；（因浮动最初是为了做文字环绕效果） ② 定位元素：绝对定位&#x2F;相对定位会完全压住下面标准流所有的内容； 08. 总结 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 不脱标，占有位置 可以 相对自身位置移动 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置 固定定位fixed 完全脱标，不占有位置 可以 浏览器可视区 粘性定位sticky 占有位置 可以 浏览器可视区 09. 行内&#x2F;行内块元素垂直对齐方式1vertical-align: baseline | top | middle | bottom; 浏览器遇到行内和行内块标签当文字处理 默认基线对齐 可以解决: 1234561. 文本框和表单按钮无法对齐问题 input和img无法对齐问题(一般给大的加 ) 2. div中的文本框，文本框无法贴顶问题 3. div不设高度由img标签撑开，此时img标签下面会存在额外间隙问题(也可直接把图片转换成块级元素) 4. 使用line-height让img标签垂直居中问题 (父级盒子里面有图片 想要图片垂直居中 需要给父级加行高=高 再给图片加 vertical-align: middle; 水平对齐父级加text-align:center;) 10. 圆角边框123border-radius:数字px/百分比 圆形: border-radius:50% 盒子必须是正方形 胶囊按钮 border-radius：盒子高度的一半; 盒子是长方形 方向名词：标签 属性个数：border-radius:xxx; 左上角：border-top-left-radius 1个值：四角 右上角：border-top-right-radius 2个值：左上角&#x2F; 右下角 右上角&#x2F;左下角（x号） 左下角：border-bottom-left-radius 3个值：左上角 右上角&#x2F;左下角 右下角 右下角：border-bottom-right-radius 4个值：左上角 &#x2F; 右上角 &#x2F; 右下角 &#x2F; 左下角 11. 显示隐藏：display特点： 隐藏之后不占有原来位置，和js搭配使用网页特效； 1display:none 隐藏对象 / block 显示对象 12. 显示隐藏-可见性：visibility特点：隐藏之后继续占有原先位置 1visibility:hidden 元素隐藏 / visible 元素可视 13. 溢出显示隐藏：overflow本质：让一个元素在页面中隐藏或者显示出来 1overflow:visible /hidden / scroll / auto; 13.1多行文本溢出省略1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;overflow: hidden; 注意： 一般情况下，我们不像让溢出的内容显示出来，因为溢出的部分会影响布局； ​ 但是若有定位的盒子，请慎用overflow：hidden； 因为它会隐藏多余的部分； 属性 说明 visible 溢出显示（默认） hidden 超出部分溢出隐藏，不显示滚动条 scroll 超出&#x2F;不超出都显示滚动条 auto 超出显示滚动条，不超出不显示 14. 总结 属性 区别 display 显示隐藏元素，不保留位置 visibility 显示隐藏元素，占有原先位置 overflow 溢出显示隐藏，只是对于溢出来的部分进行处理 15. 元素整体透明度1opacity:0.5; 取值0-1之间, 1表示完全不透明, 0表示完全透明 16. 表格边框合并1border-collapse：collapse; 该属性要加在table标签 17. 小三角设置一个盒子四周不同颜色的边框 将盒子宽高设置为0仅保留边框 得到四个三角形 选择其中一个后 其他边框设置颜色为透明transparent 12345678910111213141516171819202122等边三角div &#123; width: 0px; height: 0px; border: 100px solid transparent; border-bottom-color: blue;&#125;直角三角div &#123; width: 0; height: 0; /* 分开来写的 */ /* border-top: 100px solid transparent; border-bottom: 0px solid transparent; border-left: 0px solid transparent; border-right: 50px solid green; */ /* 代码简写 */ border-color: transparent red transparent transparent; border-width: 100px 50px 0 0; border-style: solid; &#125; 18. css用户界面样式 鼠标样式：cursor 特点：设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 12cursor:default 小白（指针箭头） / pointer 小手 move 移动（四个方向箭头） /text 工字符文本 /no-allowed 禁止 轮廓线：outline 特点：针对于表单控件的边框使用,去掉默认的蓝色边框。 1input\\textarea...&#123;outline:none/0 ;&#125; 去掉默认的边框。 防止拖拽文本域：resize 特点：针对于html里面的textarea文本域使用 1textarea&#123;resize:none;&#125; day0701. 精灵图步骤:设置盒子大小为图片大小 设置精灵图为盒子的背景图片 给背景图background-position：x y;(一般xy是负值) 一般精灵图标签用行内标签 加宽高要转模式 02. 背景图片大小：background-size1background-sizie: npx（像素） / % (百分比)/contain / 1cover 取值 场景 数字+px 简单方便，常用 % 百分比 相对于当前盒子自身的宽高百分比 contain 包含：将图片等比例缩放，直到不会超出盒子的最大 可能有部分空白区域（一旦宽度或高度满足其中一项就停止拉伸） cover 覆盖：将图片等比例索芳芳，直到刚好填满整个盒子没有空白 可能有部分背景图片显示不全 03. 盒子阴影：box-shadow注意：盒子阴影不占用空间，默认是外边距（outset）不能写，否则无效； ​ h-shadow：水平阴影 、v-shadow ： 垂直阴影必写，其他属性值可以忽略； 1一般用的较多的: box-shadow: 0 0 npx rgba(); 1box-shadow:h-shadow v-shadow blur spread color inset; 属性值 描述 h-shadow 水平阴影（x轴） 允许负值 v-shadow 垂直阴影（y轴） 允许负值 blur 模糊距离（里外） spread 阴影尺寸（大小） color 阴影颜色 inset 内部阴影 04. 文字阴影注意：h-shadow：水平阴影 、v-shadow ： 垂直阴影必写，其他属性值可以忽略； 1text-shadow: h-shadow v-shadow blur color; 属性值 描述 h-shadow 水平阴影（x轴） 允许负值 v-shadow 垂直阴影（y轴） 允许负值 blur 模糊距离(里外) color 阴影颜色 05. 过渡:transition口诀：谁做过渡给谁加； 说明：可以写多个属性，利用逗号进行分割即可； 注意：一般情况下是直接给过度属性的名称+all即可；记得在花费时间添加单位s，否则无法生效； 1234567transition: 要过渡的属性 花费时间 运动曲线 何时开始;transition: all 1s;/* 不能实现过渡效果 *//* display: none;visibility: hidden; */可通过 opacity: 0;结合过渡配合hover使用 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 过渡 属性的名称。（必写） transition-duration 花费的时间。（必写）默认是 0 transition-timing-function 运动曲线样式。 ease –低速开始-加快-变速(默认) linear -匀速 ease-in-加速（高速结束） ease-out-减速 （低俗结束） ease-in-out-先加速后减速 transition-delay 何时开始。默认是 0。（忽略） 06. SEO 三大标签-搜索引擎优化SEO：搜索引擎优化 作用：让网站在搜索引擎上的排名靠前： 提示SEO常见方法： 1.竞价排名 2. 将网页制作html后缀， 3. 标签语义化（在核实的地方使用合适的标签） seo三大标签： 注意：需要写在head头部标签里面 ① title:网页标题标签 ② description ： 网页描述 ③ keywords ： 网页关键词 12345678&lt;!-- 网页描述：description 快捷键是：mate:desc --&gt; &lt;meta name=&quot;description&quot; content=&quot;网页描述&quot;&gt; &lt;!-- 网页关键词：keywords 快捷键是：mate:kw --&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网页关键词&quot;&gt; &lt;!-- 网页标题 --&gt; &lt;title&gt;小兔鲜儿-新鲜、惠民、快捷！&lt;/title&gt; 07. ico图标12345&lt;!-- 引入ico图标： favicon 快捷键是：linnk:icon名称 --&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;ico图标路径&quot; type=&quot;image/x-icon&quot;&gt;icon小图标 放在根目录 &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; /&gt; 在线生成ico图标：https://www.bitbug.net/ day0801. 常用类名shortcut 快捷菜单 wrapper版心 prev上一个 next下一个 current&#x2F;active 当前的 02. logo做法h1&gt;a a里面放文字 h1设置fontsize:0 a转换成块元素背景图放logo 若行内或行内块和文字无法通过行高和**vertical-align:middle;**对齐 就用定位 03. banner图做法banner用ul&gt;li&gt;a&gt;img的形式放banner图 ol&gt;li 做下面的小圆点 04. 水平 垂直居中总结text-align 可控制文本在元素内部的位置; 可以让行内元素、行内块元素在父亲盒子中居中，text-align对块元素是无效；浮动的盒子具备行内块的特点但不能用 text-align使盒子居中,也不能用margin:0 auto居中margin:0 auto设置有宽的块级元素的居中 line-hight&#x3D;height 可以让单行文本垂直居中, 可结合vertical-align:middle让图片垂直居中,盒子垂直居中用margin或定位 05. min-height用于设置盒子的最小高度 超过会撑开盒子 06. 字体图标：iconfont网址： a ）icomoon 字库 （外国网站）http://icomoon.io b ) 阿里 iconfont 字库（免费） http://www.iconfont.cn/ 存放位置：下载好的字体库，单独把fonts文件夹拎出来放在网页的同一个文件夹，注意下载的字体包不要删 123456789101112131415161718192021注意：放在head头部标签里面，使用style引入追加样式 将icomoon.json上传重新选样式下载替换字体图标声明@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?7kkyc2&#x27;); src: url(&#x27;fonts/icomoon.eot?7kkyc2#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?7kkyc2&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?7kkyc2&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?7kkyc2#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal;&#125;调用：选择器&#123; font-family: &#x27;icomoon&#x27;; /*引入字体，注意icommon字体名称可以修改，注意和上面的引入字体保持一致即可*/ content=&quot;\\e91e&quot; /*引入小图标写法一 一般情况下需要和双伪元素搭配使用： ::before :: after*/ content=&#x27;&#x27; /*引入小图标写法二*/&#125; 阿里 iconfont： 123456789下载字体图标www.iconfont.cn 图标库/搜索--加入购物车--直接下载代码/添加项目再下载至本地文件放根目录fonts--引入图标iconfont.css样式---引入公共类名iconfont 引入自己的类名(不能随便更改) (demo.html中查类名)&lt;link rel=&quot;stylesheet&quot;href=&quot;./iconfont/iconfont.css&quot;&gt;&lt;span class=&quot;iconfont icon-liwuhuodong&quot;&gt; &lt;/span&gt; 通过类名如.icon-liwuhuodong修改样式大小颜色等 iconfont网站上传矢量图: SVG矢量图(放大缩小不会失真)—-上传—-去除颜色并提交 07. 单行文本溢出显示省略号：text-overflow123451.先强制一行内显示文本（强制换行nowrap / normal 自动换行默认） white-space:nowrap; 2.溢出部分隐藏：overflow：hidden;3. 文本超过用省略号代替： text-overflow:ellisis; 08. 常见布局技巧margin负值运用：针对于盒子边框合并问题 1margin-left/right/top/bottom:-npx; 说明： ① 让盒子设置margin负值移动正好压住相邻的盒子边框； ​ ② 鼠标经过盒子的时候，若是有定位，择使用z-index：数值;层叠性来设置 ​ ③ 鼠标经过盒子的时候，若是没有定位，择使用relative相对定位压住盒子即可； 文字环绕浮动元素： 说明 ：因浮动最初是为了做文字环绕效果，盒子浮动之后只会压住盒子，不会压住文字。 行内块运用： 说明：直接是可以给父元素添加text-align：center;文本直接居中对齐即可，不需要添加margin，因无效。 day0901. 滤镜（模糊）：filter1filter: 函数(); 例如： filter：blur(npx); blur模糊处理，数值越大越模糊 spread 02. calc 函数calc() 声明css属性值时执行一些计算，注意括号里面可以写 + - * &#x2F;来进行计算； 1样式（width\\height...:calc(数值 - 减 / + 加 / * 乘 / / 除 ) 03. 移动：translate改变盒子位置: 定位 外边距 位移 注意： 沿着x 和y轴移动元素，对行内标签没有效果。 ​ translate中的百分比是相对于自身元素移动位置，而不是浏览器的百分比； 优点：不会影响到其他的盒子（占原位置，不脱标） 12345678transform:translate(x,y); 单位是： % pxxy英文逗号隔开 x右正 y下正分开写法：transform:translateX(n);/transform:translate(n);transform:translateY(n);transform:translateX(n) translateY(n);常和过渡transition一起使用 1234绝对定位盒子居中：（因绝对定位的盒子不能通过margin实现水平居中）left:50%top:50%transform:translate(-50%,-50%); 04. 旋转：rotate说明：单位是deg，正数–顺时针， 负数–逆时针，默认以旋转的中心点旋转； 1transform:rotate(n deg) 注意：单位是deg 05. 旋转位置: transfrom-origin注意： 注意x 和 y 之间用空格隔开，默认是以50%中心点位置；则谁设置移动位置则给谁加；常用方位名词 单位： px –像素 % 百分比 方向名词（left 左 、 right 右 、 center 中心、top 上 、 bottom 下） 1234567891011transform-origin:x y; 单位：npx % 方位名词写在静态样式里/* 常用方位名词 */transform-origin: left bottom;/* 像素 */transform-origin: 100px 100px;/* 百分比 中心点*/transform-origin: 50% 50%;transform-origin: center;/* 左上角 */transform-origin: 0 0; 06. 倾斜 skew 单位: deg 12345678910结合坐标轴 以元素左上角为坐标轴原点/* x轴 负值向x轴负向 正值向x轴正向 */transform: skew(10deg);transform: skew(-10deg);transform: skewX(-10deg);/* Y轴 负值向Y轴负向 正值向Y轴正向 */transform: skewY(20deg);transform: skewY(-20deg);/* 无效 *//* transform: skew(10px, 10px); */ 07. 缩放：scale注意：x y 之间用逗号隔开 ，默认是1倍；写一个数值则是等比例缩放 单位：**数字 &#x3D; 倍数(没有单位)**， 0-1&#x3D;缩小 &gt;1 &#x3D; 放大 ，0缩小到没 负数先缩小再颠倒后放大 默认放大是1倍； 优势：默认以中心店缩放或者是放大盒子，是不会影响其他盒子的； 123456789101112transform:scale(x,y); 注意：没有单位，数字=倍数，写一个数值则是等比例缩放 一般只写一个值/* 缩小 0-1 */transform: scale(.5);/* 默认 */transform: scale(1);/* 放大&gt;1 */transform: scale(1.5);/* 缩小到没有 */transform: scale(0);/* 先缩小再颠倒放大 */transform: scale(-3); 07. 2D综合写法注意：有顺序的，需要按照下方来编写；记得位移必须写在最前面。 12transform:translate() roteta() scale();2D转换： 移动位置 旋转 缩放 08. 线性渐变方向： left 左 right 右 top 上 bottom 下度数： 0—360° 顺序是： 下 左 上 右（顺时针） 注意：可以写多个方向数值，以及多个颜色，以及to引用, 用逗号隔开 说明： to right 意思是，结束到右边 12345678910111213141516171819background-image: linear-gradient(to 方向/度数deg,开始颜色，结束颜色);默认从上到下 渐变背景会被子集其他元素遮住代码参考:/* 给盒子添加上一个从左到右的渐变背景, 从红色渐变到蓝色 */background-image: linear-gradient(to right, red, blue);/* 透明 =&gt; 半透明 */background-image: linear-gradient(transparent, rgba(0, 0, 0, .6));background-image: linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, .6)); /* 浏览器内核 css属性的兼容性写法*//* 兼容火狐 */background-image: -moz-linear-gradient();/* 兼容欧朋 */background-image: -o-linear-gradient();/* 兼容苹果和谷歌浏览器 有兼容性前缀 从top开始 不需要写to*/background-image: -webkit-linear-gradient(top, pink, skyblue); 多种颜色渐变： 1background:linear-gradient(to 方向词/度数deg... , 开始颜色,颜色2,颜色3....) 09. 径向渐变说明：颜色从内到外进行圆形渐变 注意：要加-webkit-;否则chrome不生效； 123456backgrond-image:radial-gradient( 圆角位置,形状,开始颜色,结束颜色);圆心位置：关键词： top bottom left right center长度值： npx；形状：ellipse 椭圆形（默认） circle 圆形 123 代码参考：background-image: radial-gradient(100px,rgba(0,0,0,.8),rgba(0,0,0,.1));background: -webkit-radial-gradient(100px,circle,rgba(0,0,0,.8),rgba(0,0,0,.1)); 移动web 移动webfont字体图标 特征：可以设置大小以及颜色，不会失帧；网页中的一些小图标可以使用 国内网站 阿里巴巴 iconfont （常用）需要注册才能下载上传素材，加入购物车后添加项目再下载 使用：下载后的文件中包含 iconfont.css文件，将其引入之css中，然后给元素类名格式为 iconfont icon-…… 1&lt;span class=&quot;iconfont icon-shoucang&quot;&gt;&lt;/span&gt; 国外网站 https://icomoon.io/ （作为了解） 使用：下载后在css文件中加入引用的字体声明属性，每个元素也要加字体声明属性，粘贴复制在html中显示未带问号的方框 123456789@font-face &#123; 字体声明 font-family: &#x27;icomoon&#x27;;（font字体声明） src: url(&#x27;../fonts/icomoon.eot?tomleg&#x27;); src: url(&#x27;../fonts/icomoon.eot?tomleg#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;../fonts/icomoon.ttf?tomleg&#x27;) format(&#x27;truetype&#x27;), url(&#x27;../fonts/icomoon.woff?tomleg&#x27;) format(&#x27;woff&#x27;), url(&#x27;../fonts/icomoon.svg?tomleg#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block;&#125; 平面转换transform 的各种用法 transform 要配合transition 使用，来达到缓慢过度的效果 例： transition: all 2s; 位移：需要添加定位属性，transform: translate(x,y) 可以是像素，也可以是%（%是取决于自身的宽高） 利用绝对定位达到居中 &#x2F; 若有放大或者其他 transform效果需要复写（hover中一样），否则属性不体现 &#96;&#96;&#96;htmlposition: absolute;top: 50%;right: 50%;transform: translate(-50%, -50%) 12345678910111213141516- 旋转：transform: rotate(*deg) 正值顺时针，负值逆时针 - origin设置旋转的中心原点 可加方向词，像素，百分比 - 例： *transform-origin*: right bottom；- 倾斜： *transform*: skew(*deg); - X 右倾为负值，左倾为正值 - Y 上倾为负值，下倾为正值- 注意想要同时位移旋转等效果，需要用复合写法，注意顺序 ```html 向右移动，旋转尺寸越来愈大 transform: translate(100px) rotate(3600deg) scale(4); 透明度属性 opacity 0，为透明，常用于隐藏当前盒子或者遮罩（类名mask）使用，在hover 中为 opacity 1， 再体现出来 ； 也可以配合overflow: hidden;和transform: translate(x,y)来达到沿着某一方向出现的效果 渐变色 3D转换位移&#x2F;&#x2F;&#x2F;旋转123456 /* 空间位移的写法一： */ transform: translate3d(100px,200px,100px); /* 空间位移的写法二： */ transform: translateX(100px) translateY(100px) translateZ(100px);角度同上写法transform: rotate3d(); 穿透效果，近大远小1234/* perspective 视距(透视距离) 建议取值（800-1200)*/body&#123; perspective:800px;&#125; 空间旋转掌握握拳方法判定旋转方向，顺正逆负 12/* 3d空间设置给父元素！！！默认为子元素有3d效果 */ transform-style: preserve-3d; 动画复合写法：animation:动画名称 动画时长 速度曲线 延迟执行时间 重复次数 动画方向 执行完毕时状态;animation: name1 duration 逐帧动画（steps (number) ） timing-function delay iteration-count direction fill-mode, name2 3s linear forwards; 调用上面name，一个盒子可以调用多个动画name实现同一个目标进行不同的动画效果！！！ 调用属性@keyframes name { 动画效果进度可以 from…to…&#x2F;&#x2F;&#x2F; 0%~100%,{里面可以设置需要的移动方式，例：（背景图&#x2F;精灵图做加载条&#x2F;轮播效果）background-position: -1680px 0; transform: translate(px&#x2F;%);left:px……} 12345678910111213141516171819@keyframes name1 &#123; from(0%) &#123; left: 0; transform: translateX(px) &#125; to (100%)&#123; left: -600px; transform: translateX(px) &#125;&#125; @keyframes name2 &#123; from(0%) &#123; transform: translateY(px) (上面用了tf位移，下面就不要用，同属性会覆盖) &#125; to (100%)&#123; transform: translateY(px) &#125;&#125; 无缝动画在动画完成一次循环之后，有空白区域，在最后加几张开头相同的目标（尺寸刚好填满空白区域即可），使其填充代替空白区域。 百分比布局宽百分比，高固定,也称流式布局&#x2F;弹性布局（老式布局方式） 12width: 100%;height: 40px; 特点：避免出现浮动脱标问题，适合结构化布局 Flex布局移动端组成：弹性容器 &#x2F; 弹性盒子 &#x2F; 主轴 &#x2F; 侧轴使用方式 给父元素设置 display:flex，子集会水平排列 /* 写在父元素内，star默认正向，end反向 */ display: flex; 主轴对齐方式：要和display:flex写在一起，在父容器中 123456789属性： justify-content: /* 居中排列 */ justify-content: center; /* 父集剩余的空间，子集之间的间距是均分的 */ justify-content: space-between; /* 均分间距在两侧，子集的间距是父集的2倍 */ justify-content: space-around; /* 所有间距相同 */ justify-content: space-evenly; 属性 值 描述 justify-content: flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 只在子集之间！子集之间的间距是均分父集剩余的空间 space-around 子集的间距是父集到子集间距的2倍 space-evenly 子集到父集&#x2F;子集之间的间距一致 侧轴对齐方式：要和display:flex写在一起，在父容器中 123456属性：align-items: align-items: start/flex-end; /* 沿着侧轴居中对齐 */ align-items: center; /* 子盒子没有给高度，沿着侧轴线拉伸铺满整个弹性容器 */ align-items: stretch; 属性 值 描述 align-items stretch 子集没有设置具体高度时，项目被拉伸以适应容器。 center 中心元素在容器内。 flex-start 位置元素在容器的开头。 flex-end 位置元素在容器的末端。 baseline 位置元素在容器的基线。 子元素设置，直接写在子元素内， flex: 1; 子元素需要多少大小占比就写多少，不加单位 ，子集不设置高度则一般和内容大小一致 123/* 单独某一元素的侧轴对齐取值方式,给控制的对象添加属性，并非父容器 */ .box .ni1:nth-child(1) &#123; align-self: start; &#125; 修改主轴方向： flex-direction: ; row 水平向左 row-reverse 水平向右 column 竖直向下 column-reverse 竖直向上 弹性盒子换行：12display: flex;flex-wrap: wrap;(nowrp,默认值不换行) 调整对齐方式：适用于多个盒子使用 属性 值 描述 align-content stretch 子集没有设置具体高度时，项目被拉伸以适应容器。 center 中心元素在容器内。 space-between 只在子集之间！子集之间的间距是均分父集剩余的空间 space-around 子集的间距是父集到子集间距的2倍 flex-start 位置元素在容器的开头。 flex-end 位置元素在容器的末端。 baseline 位置元素在容器的基线。 space-evenly 子集到父集&#x2F;子集之间的间距一致space-evenly rem的使用步骤：​ 1、网页跟标签 html 设置字号大小 ​ 2、使用rem单位 ​ 一个rem(37.5)&#x3D;一个根标签html字体大小&#x3D;1&#x2F;10可视窗口大小（当前标准375来计算），盒子的尺寸由 rem * 字号大小 来决定 ( body中设置字号无效) ​ 3、使用 vw 或 vh 单位 ​ vw(3.75)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;vh(6.67) 用法与rem相似，取值于标准宽高(375,667) ​ ！！！记得要引入 js 文件 1&lt;script src=&quot;./js/flexible.js&quot;&gt;&lt;/script&gt; 媒体查询特点：根据可视窗口的宽来调整根标签的样式；适应不同尺寸屏幕显示不同布局 12345678910111213141516171819202122232425262728293031323334 &lt;style&gt; /* 需求： 视口宽度 &gt;= 768px，网页背景色是 粉色 视口宽度 &gt;= 992px，网页背景色是 绿色 视口宽度 &gt;= 1200px，网页背景色是 skyblue */ @media (min-width:768px) &#123; body&#123; background-color: pink; &#125; &#125; @media (min-width:992px) &#123; body&#123; background-color: green; &#125; &#125; @media (min-width:1200px) &#123; body&#123; background-color: skyblue; &#125; &#125; /* 需求:当浏览器窗口 宽度 小于768, left 隐藏 */ @media (max-width:768px) &#123; .left&#123; display: none; &#125; &#125; &lt;/style&gt;&lt;!-- 使用外联式link完成媒体查询 --&gt; &lt;!-- 视口宽度 &gt;= 992px，网页背景色为粉色 one --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./one.css&quot; media=&quot;(min-width:992px)&quot;&gt; &lt;!-- 视口宽度 &gt;= 1200px，网页背景色为绿色 two --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./two.css&quot; media=&quot;(min-width:1200px)&quot;&gt; less文件脚本css的预处理器；自建.less文件 会自动生成对应的.css文件 less计算，除法需要放在括号内&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;多个单位参与计算，只取第一个 变量特点：存储数据，方便使用、修改&#x2F; 一个less文件可以用多个变量 123456789// 定义less变量 @name@hd:color(pink);//调用变量 .father&#123; color: @name; .son&#123; background-color: @name; &#125;&#125; 导入less12345678910// 导入less文件脚本// .less 可以省略@import url(./dm.less);@import url(./dm);// 括号内 &#x27;&#x27; 可以省略@import url(&#x27;./dm.less&#x27;);// 不用括号记得加上 &#x27;&#x27; ，都要以 分号结尾@import &#x27;./dm.less&#x27;; //不能导入 css html // @import url(./demo.css); 导出less123456固定文件夹导出 &quot;less.compile&quot;: &#123; // &quot;compress&quot;: true, // true =&gt; remove surplus whitespace // &quot;sourceMap&quot;: true, // true =&gt; generate source maps (.css.map files) &quot;out&quot;: &quot;../css/&quot; // false =&gt; DON&#x27;T output .css files (overridable per-file, see below),css文件路径设置 &#125;, 123单个文件设置职位、名称写法///多个用上面的插件设置// out:../css4/common.css// 创建css文件路径，以及文件名(首航写) 禁止导出less第一行写 out:false bootstrap使用可用插入font、引入写好的代码块 例：栅格系统，响应式布局随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 屏幕的类取值 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C .container 最大宽度 None （自动） 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列（column）数 12 12 12 12 最大列（column）宽 自动 ~62px ~81px ~97px 槽（gutter）宽 30px （每列左右均有 15px） 30px （每列左右均有 15px） 30px （每列左右均有 15px） 30px （每列左右均有 15px） 可嵌套&#x2F;偏移（Offsets）&#x2F;列排序 是 是 是 是 123456789&lt;!-- 宽度100%:自带左右各15px的padding --&gt; &lt;div class=&quot;container-fluid&quot;&gt;2&lt;/div&gt; &lt;!-- container 自带15的间距 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 栅格系统，一行共12个栅格，不同屏幕尺寸下的，超小屏：每一行(col)占12栅格/小屏：每一行占6栅格/中上：每一行占3栅格 --&gt; &lt;div class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;第1个盒子&lt;/div&gt; &lt;div class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;第2个盒子&lt;/div&gt; &lt;div class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;第3个盒子&lt;/div&gt; &lt;div class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;第4个盒子&lt;/div&gt; 例：font引入，类似于iconfont的使用123引入css文件&lt;link rel=&quot;stylesheet&quot; href=&quot;./bootstrap-3.4.1-dist/css/bootstrap.min.css&quot;&gt; &lt;i class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/i&gt; 例：轮播图JS插件步骤 JQ与DOM类名操作对比 web jQuery Dom对象.classlist.add() 添加 JQ对象.addClass() Dom对象.classlist.remove() 删除 JQ对象.removeClass() Dom对象.classlist.toggle() 切换 JQ对象.toggleClass() Dom对象.classlist.contains() 验证有无 JQ对象.hasClass() 12$(&#x27;video&#x27;).eq(0).play()//eq（index）获取的是JQ对象$(video).get(0).play()//get(index)获取的是Dom对象 修改透明度12// 修改透明度 fadeTo(speed,opacity) 这个速度和透明度要必须写 $(&quot;div&quot;).fadeTo(1000, 0.5); JQ动画效果123456789101112131415161718192021222324$(function () &#123; $(&#x27;.nav&gt;li&#x27;).mouseenter(function () &#123; // 直接显示,stop()方法放在动画前面用来结束上一个动画 // $(this).children(&#x27;ul&#x27;).stop().show() // 下拉显示效果 // $(this).children(&#x27;ul&#x27;).stop().slideDown(1000) // 淡入显示 // $(this).children(&#x27;ul&#x27;).stop().fadeIn(500) // fadeTo(speed,opacity) // $(this).children(&#x27;ul&#x27;).stop().fadeTo(500, .5) // 切换效果，移入显示，再移入隐藏 // $(this).children(&#x27;ul&#x27;).stop().fadeToggle(500) // $(this).children(&#x27;ul&#x27;).stop().slideToggle(500) $(this).children(&#x27;ul&#x27;).stop().toggle(500) &#125;) $(&#x27;.nav&gt;li&#x27;).mouseleave(function () &#123; // 直接隐藏 // $(this).children(&#x27;ul&#x27;).stop().hide() // 上拉隐藏 // $(this).children(&#x27;ul&#x27;).stop().slideUp(1000) // 淡出隐藏 // $(this).children(&#x27;ul&#x27;).stop().fadeOut(500) &#125;) &#125;) JQ的排他思想123456789$(function () &#123; //注册点击事件 $(&#x27;button&#x27;).click(function () &#123; // 先处当前的元素添加 ，与JS相反 $(this).css(&#x27;background&#x27;, &#x27;pink&#x27;) // 排它,再给其他兄弟元素去除,方法加（兄弟元素） $(this).siblings(&#x27;button&#x27;).css(&#x27;background&#x27;, &#x27;&#x27;) &#125;) &#125;) 链式编程123456789// 1. 隐式迭代 给所有的按钮都绑定了点击事件 $(&quot;button&quot;).click(function() &#123; // 2. 让当前元素颜色变为红色 // $(this).css(&quot;color&quot;, &quot;red&quot;); // 3. 让其余的姐妹元素不变色 // $(this).siblings().css(&quot;color&quot;, &quot;&quot;); // 链式编程,顺序正确书写 $(this).css(&quot;color&quot;, &quot;red&quot;).siblings().css(&quot;color&quot;, &quot;&quot;); &#125;); JQ操作样式之css方法123456789 // 如果是复合属性则必须采取驼峰命名法，如果值不是数字，则需要加引号// 设置单个样式 $(&#x27;div&#x27;).css(&#x27;width&#x27;, 300) // 设置多个样式,对象写法 $(&#x27;div&#x27;).css(&#123; // 键值对 key: value, color: &#x27;red&#x27;, fontSize: 30, &#125;) JQ默认遍历，可以直接根据下标来选择 12345 &lt;button&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/button&gt; &lt;button&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/button&gt; &lt;button&gt;&amp;gt;&lt;/button&gt; &lt;button&gt;&amp;lt;&lt;/button&gt;$(&#x27;button&#x27;).eq(0)===&lt;button&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/button&gt; JS进阶 作用域l链：作用域链实质：变量查找机制 从当前触发向上逐级寻找 子可找父，父不能找子 垃圾回收(GC)：垃圾回收器自动回收 不使用的内存 内存三阶段：分配 使用 回收 全局变量关闭页面回收 局部变量用完立刻就回收 引用计数：有缺点，弃用 引用次数为0时，回收； 嵌套引用，相互引用不会为0，无法被回收，会引起内存泄漏问题 标记清除法 从根部出发，找不到&#x2F;无法达到的 都清除 不再使用的对象定义为无法达到的对象 闭包闭包&#x3D;内层函数+外层函数的变量（要有两个函数且是嵌套关系） # 里面的函数访问到外部作用域的变量 作用：封闭数据，供引用，外部可以访问使用函数内部变量；数据私有化，保护数据安全（防止污染） 风险：内存泄漏 解决方案： 定义接收的函数赋值&#x3D;null（其他值） 123456789101112 // 简单的写法function other()&#123; let i=22 function fn()&#123; console.log(i) &#125; return fn //fn是函数，是复杂数据类型，此处反出是return fn的内存地址&#125;let el=other()//获取fn函数调用的返回值===fn的内存地址console.log(el)//el此时储存的是fn的函数内存地址el()//调用fn函数 变量提升123456789101112// 1. 只有var可以变量提升，声明的变量提升到 当前作用域的最前面 // 2. 只提升声明， 不提升赋值 var num // console.log(num + &#x27;件&#x27;) num = 10 console.log(num) // fun() error var fun = function () &#123; console.log(&#x27;函数表达式&#x27;) &#125; fun() 动态参数123456789101112131415161718192021&lt;script&gt; // arguments 动态参数 只存在于 函数里面 function fn() &#123; let sum = 0 for (let i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i] &#125; console.log(sum) &#125; // arguments是伪数组 里面存储的是传递过来的实参 fn(1, 2, 3, 4) // 剩余参数 真数组 function getSum(a,b,...arr) &#123;//a,b,(除去ab之外剩下的实参arr)...arr arr可自命名 arr.shift() arr.pop() arr.splice(1,0,3) console.log(arr) &#125; getSum(1, 2, 3, 43, 5, 65) &lt;/script&gt; 展开运算符123456789101112&lt;script&gt; const arr1 = [1, 2, 3] // ...arr在数组、对象中是展开运算符 可以展开数组 // 在函数中是剩余参数，接收传进的实参的剩余数据 // console.log(...arr) // 1 求数组最大值 console.log(Math.max(...arr1)) // 2. 合并数组 const arr2 = [1, 2, 3] const arr = [...arr1, ...arr2] console.log(&quot;~ arr&quot;, arr); &lt;/script&gt; 箭头函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1. 箭头函数 基本语法// const fn1 = () =&gt; &#123; &#125;// 2. 只有一个形参的时候，可以省略小括号const fn2 = x =&gt; x// 3. 只有一行代码的时候，我们可以省略大括号const fn3 = x =&gt; &#123; return x + x &#125;// 4. 只有一行代码的时候，可以省略returnconst fn4 = x =&gt; x + x// 5. 箭头函数可以直接返回一个对象//const fn = (obj) =&gt; (&#123;obj：obj&#125;)const fn = (uname) =&gt; (&#123; uname: uname &#125;)console.log(fn(&#x27;刘德华&#x27;))// 利用箭头函数来求和const getSum = (...arr) =&gt; &#123; let sum = 0 for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum&#125; // 2. 箭头函数的this 寻找指向 上一层作用域的this 外层没有就指向全局的windows//箭头函数没有this 不推荐使用// 用箭头函数不用thisconst fn = () =&gt; &#123; console.log(this) // ?windows&#125;fn()// 对象方法箭头函数 thisconst obj2 = &#123; uname: &#x27;pink老师&#x27;, sayHi: () =&gt; &#123; console.log(this) // this &#125;&#125;obj2.sayHi()const obj3 = &#123; uname: &#x27;pink老师&#x27;, sayHi: function () &#123; console.log(this) // ?指向谁？obj3 let i = 10 const count = () =&gt; &#123; console.log(this) // ? 上一个this &#125; count() &#125;&#125;obj3.sayHi() 数组解构需要加分号情况：立即执行函数、数组结构[ ]开头的 1234567891011121314151617181920&lt;script&gt; const arr = [100, 60, 80] // const max = arr[0] // const min = arr[1] // const avg = arr[2] // 数组解构 从数组中取值 赋值给变量 //根据数组下标一一对应 const [max, min, avg] = [100, 60, 80] // const [max, min, avg] = arr console.log(max, min, avg) // 交换2个变量的值 let a = 1 let b = 2;//加分号 [b,a]=[a,b] console.log(a,b) &lt;/script&gt; // 多维数组解构 const arr = [1, 2, [3, 4]] const [a, b, c] = [1, 2, [3, 4]] 对象结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 1. 对象解构的变量名 可以重新改名 旧变量名: 新变量名 const &#123; uname: username, age: userage &#125; = &#123; uname: &#x27;pink老师&#x27;, age: 18 &#125; console.log(username, userage) // 2. 解构数组对象const pig = [&#123; uname: &#x27;佩奇&#x27;,age: 6&#125;] // 数组对象解构的变量名 可以重新改名 旧变量名: 新变量名 // uname:name const [&#123; uname: pigname, age: pigage &#125;] = pig console.log(pigname) console.log(pigage)const pig = &#123; name: &#x27;佩奇&#x27;, family: &#123; mother: &#x27;猪妈妈&#x27;, father: &#x27;猪爸爸&#x27;, sister: &#x27;乔治&#x27; &#125;, age: 6 &#125; // 多级对象解构,外层对象&#123;内层对象：&#123;&#125;&#125; const &#123; name, family: &#123; mother, father, sister &#125; &#125; = pig console.log(name) console.log(mother, father, sister) const person = [ &#123; name: &#x27;佩奇&#x27;, family: &#123; mother: &#x27;猪妈妈&#x27;, father: &#x27;猪爸爸&#x27;, sister: &#x27;乔治&#x27; &#125;, age: 6 &#125; ] const [&#123; name: uname, family: &#123; mother:mother2, father:father2, sister:sister2 &#125; &#125;] = person console.log(uname) console.log(mother2, father2, sister2 )//案例！！// 需求1： 请将以上msg对象 采用对象解构的方式 只选出 data 方面后面使用渲染页面 // const &#123; data &#125; = msg // console.log(&quot;~ data&quot;, data); // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数 // function render(&#123;data&#125;) &#123;//传参时直接进行结构===const &#123; data &#125; = msg // // 我们只要 data 数据 // // console.log(data) // &#125; // render(msg) // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData function render(&#123; data: myData &#125;) &#123;//对象重命名 // 要求将 获取过来的 data数据 更名为 myData console.log(myData) &#125; render(msg) 数组&#x2F;对象遍历方法1234567891011121314151617// 语法： 数组.方法名（function(item,index)&#123;&#125;） // forEach 就是单纯的遍历 加强版的for循环 适合于遍历数组对象 const arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;] arr.forEach(item =&gt; console.log(item)) //map可以便利，也可以输入一个新的数组，和join()一起使用，新数组的每一项由return的返回值决定 arr.map(item =&gt; console.log(item + &#x27;map方法制成&#x27;) ) //数组.filter（）筛选数据范围使用，也可return const arr = [10, 20, 30] // 返回的符合条件的新数组 const newArr = arr.filter(items =&gt; items &gt;= 15)//箭头函数简写 // arr.reduce(function(累计值, 当前元素)&#123;&#125;, 起始值)起始值要写，求和使用，也可return const arr = [1, 2, 3, 4, 5, 6, 6, 7, 8, 9] const more = arr.reduce((prev, item) =&gt; prev + item, 0) 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 构造函数构造函数是专门用于创建 对象的函数，如果一个函数被使用 new + 首字母大写 关键字 调用，那么这个函数就是构造函数。 1234567891011//构造函数 function Pa(book, els) &#123; //this指向构造的新对象 this.name = book//形参 this.els = els//形参 &#125;// new + Object (首字母大写) const a1 = new Pa(&#x27;三国&#x27;, &#x27;罗贯中&#x27;)//实参传参 console.log(&quot;~ a1&quot;, a1) const a2=new Pa(&#x27;水浒&#x27;,&#x27;施耐庵&#x27;) console.log(&quot;~ a2&quot;, a2) 总结： 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 () 构造函数的返回值即为新创建的对象 构造函数内部的 return+简单数据类型 返回的值无效！return+复杂类型数据可以反出！ 注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。 1.2 实例成员通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 总结： 构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象、 实例成员增加的实例成员自己用，静态成员不能使用，反之同理。 1.3 静态成员在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数1.Object1234567891011121314&lt;script&gt; const o = &#123; uname: &#x27;pink&#x27;, age: 18 &#125; // Object.keys()//values() 键、值 方式获取属性名和属性值//是数组结构 // 1.获得所有的属性名 console.log(Object.keys(o)) // 2. 获得所有的属性值 console.log(Object.values(o)) // 3. 对象的拷贝 // Object.assign(a,b) 将b拷贝进给a，可用于追加属性Object.assign(a,&#123;&#125;） let o2 = &#123; // 展开运算符，脱去外衣 ...o//...0=== uname: &#x27;pink&#x27;, age: 18 &#125; console.log(&quot;~ o2&quot;, o2); 原型对象123456789101112131415161718// 原型（原型对象）是个对象，是构造函数的prototype属性的值，它的值是个对象&#123;&#125;// 构造函数.prototype.方法=function()&#123;&#125;// 公共的方法写在原型对象中，可以让实例对象共享使用// 构造函数 公共的属性和方法 封装到 Pass 构造函数里面了// 1. 公共的属性写到 构造函数里面// 2. 公共的方法写到原型对象身上 节约了内存function Pass(uname, age) &#123;this.uname = unamethis.age = age&#125; // 这么写会出现浪费内存问题，要用原型对象写 // this.sex=function()&#123;console.log(&#x27;ever&#x27;)&#125;// 构造函数.prototype.方法=function()&#123;&#125;Pass.prototype.sex = function () &#123; console.log(&#x27;ever&#x27;) &#125;// 公共的方法写在原型对象中，可以让实例对象共享使用const P1 = new Pass(&#x27;张三&#x27;, 28)const P2 = new Pass(&#x27;李七&#x27;, 16)console.log(&quot;~ P1&quot;, P1);console.log(&quot;~ P2&quot;, P2);// console.log(P1.sex)P1.sex() 构造函数-原型对象-对象原型 关系 字符串处理方法12345678910111213141516171819202122// 1. split 把字符串 转换为 数组 和 join() 相反const str1 = &#x27;pink,red&#x27;const re = str1.split(&#x27;,&#x27;)console.log(&quot;~ re&quot;, re); // 2. 字符串的截取 substring(开始的索引号[， 结束的索引号])// 2.1 如果省略 结束的索引号，默认取到最后// 2.2 结束的索引号不包含想要截取的部分const str2 = &#x27;今天又要做核酸了&#x27;console.log(str2.substring(5,7))// 3. startsWith 判断是不是以某个字符开头const str3 = &#x27;pink老师上课中&#x27;console.log(str3.startsWith(&#x27;pink&#x27;))//tconsole.log(str3.startsWith(&#x27;pinks&#x27;))//f// 4. includes 判断某个字符是不是包含在一个字符串里面const str4 = &#x27;我是pink老师&#x27;console.log(str4.includes(&#x27;老&#x27;))//tconsole.log(str4.includes(&#x27;l&#x27;))//f// toFixed() 方法可以让数字指定保留的小数位数 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 数组求值方法123456789101112131415161718192021// 自己定义 数组扩展方法 求和 和 最大值 const arr = [2, 3, 4, 5, 6, 7, 87]// 1. 我们定义的这个方法，任何一个数组实例对象都可以使用// Array是内置构造函数Array.prototype.max = function () &#123; return Math.max(...this)//this指向new实例对象&#125;// 2. 自定义的方法写到 数组.prototype 身上// 1. 最大值console.log(arr.max())// 2. 最小值Array.prototype.min = function () &#123; return Math.min(...this)//this指向new实例对象&#125;console.log(arr.min())// 3. 求和 方法 Array.prototype.sum = function () &#123;// prev数组的第一项开始，0是起始量return this.reduce((prev, item) =&gt; prev + item, 0)&#125;console.log(arr.sum()) 伪数组转真1234// Array.from() 把伪数组转换为真数组const lis = document.querySelectorAll(&#x27;ul li&#x27;)const tlis = Array.from(lis)const tlis2 = [...lis]//展开运算符 购物车案例123456789101112131415161718192021222324const arr2 = goodsList.map(item =&gt; &#123; const &#123; name, price, count, spec, gift, picture &#125; = item//解构 // join()是数组方法，将对象值提取为数组再转换为字符串 const txt = Object.values(spec).join(&#x27;/&#x27;) // console.log(&quot;~ txt&quot;, txt); // gift有无需要判断,有则转为数组，再map遍历反出，map()..join() ; 没有直接反出 &#x27;&#x27; const free = gift ? gift.split(&#x27;,&#x27;).map(item =&gt; `&lt;span class=&quot;tag&quot;&gt;【赠品】$&#123;item&#125;&lt;/span&gt;`).join(&#x27;&#x27;) : &#x27;&#x27; // 计价=单价*数量,保留两位小数 const subTotal = (price * 100 * count) / 100//*100避免小数计算出现不精确 return ` &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;$&#123;picture&#125;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;name&quot;&gt;$&#123;name&#125; $&#123;free&#125;&lt;/p&gt; &lt;p class=&quot;spec&quot;&gt;$&#123;txt&#125;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;$&#123;price.toFixed(2)&#125;&lt;/p&gt; &lt;p class=&quot;count&quot;&gt;$&#123;count&#125;&lt;/p&gt; &lt;p class=&quot;sub-total&quot;&gt;$&#123;subTotal.toFixed(2)&#125;&lt;/p&gt; &lt;/div&gt; ` &#125;) //总价,求和每个小价之后再相加求和 const total = goodsList.reduce((prev, item) =&gt; (prev + (item.price * 100 * item.count) / 100), 0) document.querySelector(&#x27;.total&#x27;).innerHTML = `&lt;div&gt;合计：&lt;span class=&quot;amount&quot;&gt;$&#123;total.toFixed(2)&#125;&lt;/span&gt;&lt;/div&gt;` // 渲染页面 document.querySelector(&#x27;.list&#x27;).innerHTML = arr2 面向对象面向对象编程是一种程序设计思想，它具有 3 个显著的特征：封装、继承、多态。 1 封装封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。 总结： 构造函数体现了面向对象的封装特性 构造函数实例创建的对象彼此独立、互不影响 命名空间式的封装无法保证数据的独立性 1.2 继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 更改this指向call 直接更改 this 指向， 传入的是普通参数，调用函数apply 直接更改 this 指向， 传入的是数组，调用函数bild，方法并不会调用函数，而是创建一个指定了 this 值的新函数12345678910111213141516171819202122&lt;button&gt;发送短信&lt;/button&gt; &lt;script&gt; const obj = &#123; age: 18 &#125; function fn() &#123; console.log(this) &#125; // 1. bind 不会调用函数 // 2. 能改变this指向 // 3. 返回值是个函数, 但是这个函数里面的this是更改过的obj const fun = fn.bind(obj) fun() // 需求，有一个按钮，点击里面就禁用，2秒钟之后开启 document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; // 禁用按钮 this.disabled = true setTimeout(() =&gt; &#123; this.disabled = false &#125;, 2000) &#125;) &lt;/script&gt; 报错预处理123456789101112131415161718192021222324function fn(x, y) &#123; if (!x || !y) &#123; // 提示错误并终止函数往下运行 throw new Error(&#x27;没有参数传递进来&#x27;) &#125; return x + y &#125; // console.log(fn(1, 2))//正确 console.log(fn()) function fn() &#123; try &#123; // 可能发送错误的代码，写在try里 const p = document.querySelector(&#x27;.p&#x27;) p.style.color = &#x27;pink&#x27; &#125; catch (err) &#123; // 出现错误，会执行catch拦截错误信息，但不会中断函数程序 throw new Error(&#x27;选择器出错了&#x27;) &#125; finally&#123; console.log(&#x27;错不错都不会被终止，还会执行&#x27;) &#125; &#125; fn() 递归函数 &#x2F;&#x2F;递归函数：函数在自己内部调用自己 12345*function* time() &#123; document.querySelector(&#x27;div&#x27;).innerHTML = new *Date*() setTimeout(time, 1000)//定时器在内部调用此函数&#125;time()//页面调用函数 浅拷贝 只拷贝地址，和第一层的方法和属性，如果里层还有对象则不会拷贝到 拷贝出来的对象和原数据还会有影响的(内层的数据) 深拷贝 &#x2F;&#x2F; 深拷贝怎么实现？ 优点：通过深拷贝出来的新对象不会影响旧对象 1.深拷贝用到函数递归 2.普通拷贝可以直接赋值，遇到数组要先把数组提出来再处理对象，再次调用递归处理就可以了 3.遇到对象，再次调用递归来处理对象 2、通过引入 ladash.js 文件中的_.cloneDeep() 3、JOSN（先转为字符串再转回对象）也可以实现 节流、防抖节流：控制频繁触发事件的频率，一个时间内只发生一次 防抖：平凡触发的事件，只会执行最后一次 12345678910111213141516171819202122232425262728293031323334353637const box = document.querySelector(&#x27;.box&#x27;) let i = 1 function mouseMove() &#123; box.innerHTML = i++ &#125; function throttle(fn, t) &#123; // 充当事件处理函数 let st = 0 return function () &#123; let nt = Date.now() if (nt - st &gt;= t) &#123; fn() st = nt &#125; &#125; &#125; // box.addEventListener(&#x27;mousemove&#x27;, mouseMove) box.addEventListener(&#x27;mousemove&#x27;, throttle(mouseMove, 500))//防抖 &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 function mouseMove() &#123; box.innerHTML = ++i &#125; function debounce(fn, t) &#123; let timeId return function () &#123; // 清除事件 if (timeId) clearTimeout(timeId) // 开启事件 timeId = setTimeout(function () &#123; fn(), t &#125;) &#125; &#125; box.addEventListener(&#x27;mousemove&#x27;, debounce(mouseMove, 200)) &lt;/script&gt; 综合：本地存储播放记录 1234567891011// 获取元素 要对视频进行操作 const video = document.querySelector(&#x27;video&#x27;) video.ontimeupdate = _.throttle(() =&gt; &#123; console.log(video.currentTime)//获取当前时间;可读写 // 获取时间做好 本地存储 localStorage.setItem(&#x27;currentTime&#x27;, video.currentTime) &#125;, 1000) // 接着播放，读取本地存储时间 || 若是新打开网页没有记录时间则从0开始（逻辑中断） video.onloadeddata = () =&gt; &#123; video.currentTime = localStorage.getItem(&#x27;currentTime&#x27;) || 0 &#125; JS基础 书写位置​ 外部，在结束的 body 标签上方直接引入 ​ 内部，写在body标签中。 ​ 行内配合btn使用。 1234 &lt;body&gt; &lt;!-- 外部js ,标签中间的会被忽略，不要写任何东西--&gt; &lt;script src=&quot;./my.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 输出方式123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 使用 innerHTML 写入到 HTML 元素。 --&gt; &lt;p id=&quot;name&quot;&gt; 这行文字可以用javascript更改内容 &lt;/p&gt; &lt;script&gt; document.getElementById(&#x27;name&#x27;).innerHTML = &quot;第一次修改&quot;; &lt;/script&gt; &lt;!-- 替换内容 --&gt; &lt;script&gt; function myFunction() &#123; // 找到标签 x = document.getElementById(&quot;name&quot;) // 改变标签的内容 x.innerHTML = &quot;HELLO!第二次修改&quot; &#125; &lt;/script&gt; &lt;!-- 配合btn点击按钮使用 --&gt; &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt; &lt;!-- 使用 document.write() 方法将内容写到 HTML 文档中。 --&gt; &lt;script&gt; // 如果在文档已加载后使用它（比如在函数中），会覆盖整个文档。 function myfunction() &#123; document.write(&#x27;在输出流生效后再执行此操作，会覆盖之前的所有输出内容&#x27;); &#125; document.write(&#x27;&lt;h2&gt;html中的script输出流&lt;h2&gt;&#x27;) document.write(Date()) &lt;/script&gt; &lt;button type=&quot;button&quot; onclick=&quot;myfunction()&quot;&gt;点击这里2&lt;/button&gt; &lt;!-- 使用 window.alert() 弹出警告框。 --&gt; &lt;script&gt; // 括号内加了 &quot;&quot; 则被认为是字符串 // window.alert(&#x27;输入错误&#x27;) &lt;/script&gt; &lt;!-- 使用 console.log() 写入到浏览器的控制台。 --&gt; &lt;!-- 外部js ,标签中间的会被忽略，不要写任何东西--&gt; &lt;script src=&quot;./my.js&quot;&gt;&lt;/script&gt; &lt;!-- 输入方式 --&gt; &lt;script&gt; prompt(&#x27;年级&#x27;) &lt;/script&gt; 输入填表案例，配合变量使用1234567891011121314151617181920212223// 单价 let price = +prompt(&#x27;输入价格&#x27;) // 数量 let num = +prompt(&#x27;输入数量&#x27;) // 地址 let address = prompt(&#x27;输入地址&#x27;) // 将JS的效果引入，渲染 document.write(` &lt;table&gt; &lt;tr&gt; &lt;th&gt;商品名&lt;/th&gt; &lt;th&gt;单价&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;anything&lt;/td&gt; &lt;td&gt;$&#123;price&#125;&lt;/td&gt; &lt;td&gt;$&#123;num&#125;&lt;/td&gt; &lt;td&gt;$&#123;address&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; `) 变量1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; // 声明一个变量，赋值，调用 // 错误命名 let 2error = 404S let nameall = &#x27;weq&#x27; let nameAll = wqd let if = 23 let let = 23 let @qwr = 23 let na-na = 23 // 正确符号 let $age = 13 let age_man = 23 // 注意 &#x27;&#x27; 字符串跟数值的区别 let age = 18 // 更新新值 age = 20 let sex = &#x27;man&#x27; sex = &#x27;woman&#x27; console.log(age) console.log(sex) // 用户输入 值，存储到变量中 // let uname = prompt(&#x27;请输入名字&#x27;) // 输出变量获取到的值 // document.write(uname) // 交换变量值，类似虚拟内存，一个变量容器只储存一个值，调用了容器就等于空了，这时候可以通过一个临时的变量做中转，给他赋予其他值 let num1 = 10 let num2 = 20 let temp //右边的值给左边 temp = num1 num1 = num2 num2 = temp console.log(num1, num2) &lt;/script&gt; 数组123456// 数组，一个变量可以存放多个数据，用中括号表示数组， let arr = [&#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;, &#x27;星期天&#x27;] //length为数据总量 console.log(arr.length) // 数组的下标，下标从 0~ 开始计数，下面结果为 星期四 ，对应第四个下标(3)的数据 console.log(arr[3]) 模板字符串123456&lt;script&gt; let uname = prompt(&#x27;请输出姓名&#x27;) let age = prompt(&#x27;请输出年龄&#x27;) // 模板字符串 `字符串$&#123;变量名&#125;字符串` document.write(`你好，我是$&#123;uname&#125;今年$&#123;age&#125;岁了。`)&lt;/script&gt; 常量123456&lt;script&gt; const PI = 3.14 console.log(PI) // 常量赋值不能为空白, 值不能更改 // const PI&lt;/script&gt; 字面量转化123456789101112 // 隐式转化，除了 + 号，其他计算符号都会转化为 数字类型 console.log(1 + 1) console.log(&#x27;2&#x27; / 1) console.log(+&#x27;2&#x27; + 1)// 显式转化 let PI = 3.1345 console.log(typeof Number(str)) console.log(&#x27;age&#x27;) // 保留小数 console.log(parseFloat(PI)) // 取整数 console.log(parseInt(PI)) 赋值计算123456let num1 = 2 // num1 = num1 + 2 // console.log(num1) // 简写方式 += 2 &lt;===&gt; = num1 + 2 num1 += 2 console.log(&quot;~ num1&quot;, num1); 逻辑运算符123456789101112// 逻辑运算符，计算顺序：非（！）、与（&amp;&amp;）、或（||） let a = 3 &gt; 5 &amp;&amp; 2 &lt; 7 &amp;&amp; 3 == 4 //与：一假为假 // false true false console.log(a)// false let b = 3 &lt;= 4 || 3 &gt; 1 || 3 != 2 //或：一真为真 // true true true console.log(b)// true let c = 2 === &#x27;2&#x27; console.log(c) // false let d = !c || b &amp;&amp; a //先算&amp;&amp; 再算 || // true f console.log(d) // t 自增运算12345678910111213// 自增符只能 +1 ，一般使用 R++这种写法，都是直接单独使用， let r = 1 //如果使用前自增，操作符在操作数之前(例如，++x)，自增操作符将自增并返回自增后的值。 ++r console.log(&quot;~ r&quot;, r); console.log(++r + 1) console.log(&#x27;-------------&#x27;) let R = 1 // 如果使用后缀，操作符放在操作数之后(例如，x++)，则自增操作符递增并返回自增之前的值。 R++ console.log(&quot;~ R&quot;, R); console.log(R++ + 1) 比较运算12345678910111213141516// 结论 // 返回的是一个布尔类型的值，会有隐式转化的特性 // 日常开发中，必须用三等全类型比较 // = 赋值 将等号右边的值赋予给左边, 要求左边必须是一个容器 // == 只判断值，不判断类型(有个隐式类型转化) // === 既判断值，也判断类型 console.log(2 &gt; 4) //F console.log(2 &gt; 1) //T console.log(2 != 2) //F console.log(2 != 4) //T console.log(&#x27;----------------------&#x27;) console.log(2 == &#x27;2&#x27;) //T console.log(2 === &#x27;2&#x27;) //F console.log(2 != &#x27;2&#x27;) //F console.log(2 !== &#x27;2&#x27;) //Tconsolo.log(NaN === NaN) //F 三元运算1234567 // 三目计算，逻辑性：三目运算符 ? : 第一个返回true,第二个返回false let num1 = 5 let num2 = 10 let num = num1 &gt; num2 ? num1 : num2 2 &gt; 1 ? &#x27;正确的tip&#x27; : &#x27;错误的tip&#x27; console.log(&quot;~ num&quot;, num); // out:10 switch123456789101112131415let weekday = prompt(&#x27;输入日期&#x27;) // switch语句计算表达式，将表达式的值与case子句匹配，并执行与该case关联的语句，以及在匹配的case之后的语句。 switch (weekday) &#123; // 内容后面加 ： case &#x27;周一&#x27;://case须是固定内容 // 输出内容 console.log(&#x27;周一&#x27;) break;//终止循环 case &#x27;周天&#x27;: console.log(&#x27;双休日&#x27;) break; default: // 类似于else console.log(&#x27;周周&#x27;) break; &#125; while12345678910111213141516171819202122232425// while语句创建一个循环，只要（）内条的结果为true，该循环就执行指定的语句。先求值，在执行语句。 while (condition)//=结果 statement//结果为true的执行语句 // exp: let i = 0; while (i &lt; 6) &#123; if (i === 3) &#123; break; //达到此条件，退出这个循环 &#125; i = i + 1; &#125; console.log(i); // expected output: 3 console.log(&#x27;continue用法&#x27;) let num = 0 while (num &lt; 8) &#123; if (num % 2 === 0) &#123; // console.log(&#x27;continue终止循环中的此项事件为$&#123;num&#125;&#x27;) num += 1 continue//结束此次循环（跳过这条件），下面代码不再执行 &#125; console.log(`这是第$&#123;num&#125;次循环`) num += 1 &#125; for循环1234567891011121314151617// for循环，（起始值，终止条件，变化量）for (let index = 0; index &lt; array.length; index++) &#123; // for嵌套for，外层的for先开始一次循环，被包裹的for开始循环，直到循环结束以后再次开始回到外层的for进行循环 for (let index = 0; index &lt; array.length; index++) &#123; &#125;&#125;// 例：乘法口诀// 外层循环for (let i = 1; i &lt;= 9; i++) &#123; // 内层循环 for (let j = 1; j &lt;= 9; j++) &#123; // 内层循环全都完成之后输出 document.write(`&lt;span&gt;$&#123;j&#125;*$&#123;i&#125;=$&#123;i * j&#125;&lt;/span&gt;`) &#125; // 执行完一次外层循环之后的输出 document.write(`&lt;br&gt;`)&#125; 遍历数组看到数组就要想到把它用 for 遍历 删加 12345678910111213141516171819 let array = [&#x27;张三&#x27;, &#x27;任一&#x27;, &#x27;瘸子&#x27;, &#x27;麻子&#x27;, &#x27;柳七&#x27;, &#x27;王五&#x27;, &#x27;李四&#x27;] for (let i = 0; i &lt; array.length; i++) &#123; const element = array[i]; console.log(element) &#125; //首尾添加数据进去 array.unshift(&#x27;细沙&#x27;, &#x27;流沙&#x27;) array.push(&#x27;王二&#x27;, &#x27;薛六&#x27;) console.log(&quot;~ array&quot;, array); //删除首尾数据 array.shift() array.pop() console.log(&quot;~ array&quot;, array); //（pos,n） pos:指定下标位置开始到结束，n:移除数量 array.splice(3, 2) console.log(&quot;~ array&quot;, array);//也可以指定位置添加数据array.aplice(3,0,add) 取极值 1234567891011121314let array = [2, 4, 8, 5, 3, 7, 33, 88, 2, 8762]//从数组中选取一个数据作为比较值let max = 2for (let i = 0; i &lt; array.length; i++) &#123; const element = array[i]; // 用随随机选出来的数据跟其他一一对比值的大小 if (max &lt; array[i]) &#123; //对比较的结果赋值 max = array[i] //这里输出结果是每一次比较出来的较大值 &#125;&#125;console.log(&quot;~ max&quot;, max);//循环都结束后，输出唯一的值 筛选数据 12345678910111213141516 let array = [1, 2, 52, &#x27;似的&#x27;, 5, 35, &#x27;张三&#x27;, &#x27;柳七&#x27;] //目标数组 let chose = [] for (let i = 0; i &lt; array.length; i++) &#123; const element = array[i]; //筛选条件, //数据类型为 数字输出,注意类型 number的大小写 if (typeof element === &#x27;number&#x27;) &#123; chose = element console.log(&quot;~ chose&quot;, chose); &#125;/* else if (typeof element === &quot;string&quot;) &#123; chose = element console.log(&quot;~ chose&quot;, chose); &#125; */ &#125; 函数命名规则与变量相同， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 两数求和,形参x y 若不给默认值 0，且实参也不写值，那x y 就是 undefined function getSum(x = 0, y = 0) &#123; return x + y//return 会反出函数的结果，可以给外部拿出使用， console.log(&#x27;return下面的代码不会被执行！！&#x27;) &#125; let sum = getSum(2, 4)//将结果赋值给一个变量，这样利于使用书写分类 console.log(&quot;~ sum&quot;, sum); // 调用的值跟实参对应 getSum(3, 9) console.log(&quot;~ getSum(3,9)&quot;, getSum(3, 9)); getSum(1, 8) console.log(&quot;~ getSum(1,8)&quot;, getSum(1, 8)); // 取极值 function mNum(x = 0, y = 0) &#123; // return x &gt; y ? max = x : max = y return x &lt; y ? max = x : max = y &#125; mNum(4, 9) console.log(&quot;~ mNum(4,9)&quot;, mNum(4, 9)); mNum(12, 8) console.log(&quot;~ mNum(12,8)&quot;, mNum(12, 8)); // 数组求和 // 声明数组 let arr1 = [1, 2, 3, 4, 5] let arr2 = [1, 2, 3, 4, 5, 6, 4, 0] // 函数封装 function getArrSum(arrXc = []) &#123; // 设置求和结果变量 let sum = 0 //求和循环 for (let i = 0; i &lt; arrXc.length; i++) &#123; sum = sum + arrXc[i]//每一次循环求和的结果 &#125; return sum//循环结束后返回总和 &#125; getArrSum(arr1) console.log(&quot;~ getArrSum(arr1)&quot;, getArrSum(arr1)); getArrSum(arr2) console.log(&quot;~ getArrSum(arr2)&quot;, getArrSum(arr2)); // 数组取极值 function getM(arrM = []) &#123; // 先声明极值 let max2 = arrM[0] let min2 = arrM[0] // 开始循环 for (let i = 1; i &lt; arrM.length; i++) &#123; // 筛选条件 if (max2 &lt; arrM[i]) (max2 = arrM[i]) if (min2 &gt; arrM[i]) (min2 = arrM[i]) &#125; return [min2, max2] &#125; let re = getM(arr1) let re2 = getM(arr2) console.log(&quot;~ re2&quot;, re2); console.log(&quot;~ re&quot;, re); // 同名函数，下面的会覆盖上面的值 function getSum(x = 0, y = 0) &#123; return x + y &#125; getSum(2, 6) console.log(&quot;~ getSum(2, 6)&quot;, getSum(2, 6)); function getSum(x = 0, y = 0) &#123; return x - y &#125; //输入控制函数求和function getSum() &#123; let num1 = +prompt(&#x27;输入第一个数字&#x27;) let num2 = +prompt(&#x27;输入第二个数字&#x27;) return num1 + num2 &#125; let sum = getSum() console.log(&quot;~ sum&quot;, sum); 函数表达式123456789101112// 函数表达式，匿名函数命名，用let 声明 let num = function () &#123; document.write(&#x27;函数表达式写法&#x27;) &#125; // 调用 num() // document.write(`&lt;br&gt;`) let sum = function (x, y) &#123; return x + y &#125; document.write(sum(1, 4)) 立即执行函数1234// 立即函数两种写法，好处是立刻执行，无需调用，更不会引起函数污染,(function (x, y) &#123; document.write(x + y) &#125;(1, 6));//一定要写分号！！！前后都可//; (function () &#123; document.write(&#x27;立即执行函数&#x27;) &#125;)(); 对象1234567891011121314151617181920//let 对象名 =&#123;属性：属性值&#125;;属性命名若有组合的写法要写在 &#x27;&#x27; 里面 let myself = &#123; uname: &#x27;xss&#x27;, age: 17, &#x27;sex-two&#x27;: &#x27;man&#x27;//最有一个属性后面可以不加 ，其他必须加 &#125; // 打印出对象里面所有的内容=&gt; 属性+属性值 console.log(myself) // 只打印对象中的具体属性的属性值 console.log(myself.uname)//写法一，对象.属性 console.log(myself[&#x27;sex-two&#x27;])//写法二，对象[&#x27;属性&#x27;]， // 增加对象中的内容 myself.weight = &#x27;70kg&#x27; console.log(myself) // 修改对象中的内容 myself.age = 22 console.log(myself) // 删除对象中的数据 delete myself.uname console.log(myself) 便利对象 12345// 便利对象 for infor (let k in myself) &#123; console.log(k)//直接打印出属性名 console.log(myself[k])//直接打印出 所有 属性值&#125; 便利数组对象12345678910111213let arr = [ &#123; name: &#x27;李李&#x27;, age: 18, class: &#x27;four&#x27;, &#x27;index&#x27;: &#x27;always&#x27; &#125;, &#123; name: &#x27;张三&#x27;, age: 18, class: &#x27;four&#x27;, &#x27;index&#x27;: &#x27;second&#x27; &#125;, &#123; name: &#x27;董一&#x27;, age: 18, class: &#x27;four&#x27;, &#x27;index&#x27;: &#x27;first&#x27; &#125;, &#123; name: &#x27;朱八&#x27;, age: 18, class: &#x27;four&#x27;, &#x27;index&#x27;: &#x27;maybe&#x27; &#125;, &#123; name: &#x27;王四&#x27;, age: 18, &#x27;class-qwe&#x27;: &#x27;four&#x27;, &#x27;index&#x27;: &#x27;litter&#x27; &#125;, ] for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i])//所有内容 console.log(arr[i].name)//具体的某一项所有值 console.log(arr[0].name)//具体的下标的某一值 console.log(arr[i][&#x27;class-qwe&#x27;])//具体的下标的某一项所有值 &#125; 作用域123456789101112// 作用域有就近原则，向上一级一级查找输出值，记得函数要调用，不设置return值会返回默认值 undefined let num = 10 function fn() &#123; let num = 20 function fn() &#123; let num = 30 console.log(num) &#125; // console.log(num) fn()//调用内部的函数 &#125; fn()//调用最外层函数 逻辑中断123456789101112131415// “或” 一真则真 console.log(3 &gt; 4 || 22) console.log(null || 22) console.log(NaN || 22) console.log(undefined || 22) console.log(0 || 22) console.log(&#x27;&#x27; || 22) console.log(11 || 22)//一真则直接输出 console.log(&#x27;------------------------&#x27;) // “于” 一假则家 console.log(0 &amp;&amp; 11)//遇假直接输出 console.log(22 &amp;&amp; 11)//都真则输出最后一个结果 console.log(3 &lt; 4 &amp;&amp; 11) console.log(1 &amp;&amp; 11) console.log(11 &amp;&amp; 2233) Webapi将整个网页作为对象，Document是最大的对象，使用Document对网页内容操作实质上跟操作对象是一样的 1234// DOM(文档对象模型), 操作网页内容,将网页整体当做对象处理// Document是最大的网页对象，html中的标签在DOM中叫 dom对象，//api中用 const 声明 document+查询选择+(&#x27;CSS选择器&#x27;)// querySelector 获取匹配的第一个 !!对象!! 实现过程选取对象，实行操作！！！！ 基础操作 12345// 修改对象里面的内容用 innerText/innerHTML，他们是属性， // innerText 它不解析标签，只显示纯文本 p[0].innerText = &#x27;&lt;b&gt;innerHTML是属性+行为&lt;/b&gt;&#x27; // innerHTML解析标签 p[0].innerHTML = &#x27;&lt;b&gt;innerHTML是属性+行为&lt;/b&gt;&#x27; 伪数组 12// querySelectorAll 修改选取所有的对象,获取的全是伪数组！！ const lis = document.querySelectorAll(&#x27;ul li&#x27;)//伪数组，只有长度和下标；遇到数组就要遍历 class修改1234567 // 更改,className 会覆盖之前的类，不推荐使用// div.className = &#x27;nav&#x27;// 推荐使用classListdiv.classList.add(&#x27;nav&#x27;)//增加类,不会覆盖之前的类div.classList.remove(&#x27;nav&#x27;)//删除类div.classList.toggle(&#x27;nav&#x27;)//交换类div.classList.contains(&#x27;nav&#x27;)//判断是否存在这个类 回调函数把一个函数作为参数传给另一个函数，该函数为回调函数 Ajax01. URL地址的组成部分 客户端与服务器之间的通信协议 存有该资源的服务器名称 资源在服务器上具体的存放位置 02. 客户端与服务器的通信过程 客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤 03. 网页中如何请求数据 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象 最简单的用法 const xhr &#x3D; new XMLHttpRequest() 04. 资源的请求方式 get 请求通常用于获取服务端资源（向服务器要资源） post 请求通常用于向服务器提交数据（往服务器发送资源） 05. Ajax概念 Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML） 在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax Ajax能让我们轻松实现网页与服务器之间的数据交互 06. jQuery中的Ajax 浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数 jQuery 中发起 Ajax 请求最常用的三个方法如下： $.get() $.post() $.ajax() 07. $.get()函数的语法1$.get(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 12345// $.get()发起不带参数的请求// 获取到所有的$.get(&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, function(res) &#123; console.log(res) // 这里的 res 是服务器返回的数据&#125;) 12345// $.get()发起带参数的请求// 获取id为1的$.get(&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, &#123; id: 1 &#125;, function(res) &#123; console.log(res)&#125;) 08. $.post()函数的语法1$.post(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 1234567$.post( &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;, // 请求的URL地址 &#123; bookname: &#x27;水浒传&#x27;, author: &#x27;施耐庵&#x27;, publisher: &#x27;上海图书出版社&#x27; &#125;, // 提交的数据 function(res) &#123; // 回调函数 console.log(res) &#125;) 09. $.ajax()函数的语法1234567// 只有一个参数 是对象$.ajax(&#123; type: &#x27;&#x27;, // 请求的方式，例如 GET 或 POST url: &#x27;&#x27;, // 请求的 URL 地址 data: &#123; &#125;,// 这次请求要携带的数据 success: function(res) &#123; &#125; // 请求成功之后的回调函数&#125;) 123456789// 使用$.ajax()发起GET请求$.ajax(&#123; type: &#x27;GET&#x27;, // 请求的方式 method:&#x27;GET&#x27; url: &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, // 请求的 URL 地址 data: &#123; id: 1 &#125;,// 这次请求要携带的数据 success: function(res) &#123; // 请求成功之后的回调函数 console.log(res) &#125;&#125;) 12345678910111213// 使用$.ajax()发起POST请求$.ajax(&#123; type: &#x27;POST&#x27;, // 请求的方式 url: &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;, // 请求的 URL 地址 data: &#123; // 要提交给服务器的数据 bookname: &#x27;水浒传&#x27;, author: &#x27;施耐庵&#x27;, publisher: &#x27;上海图书出版社&#x27; &#125;, success: function(res) &#123; // 请求成功之后的回调函数 console.log(res) &#125;&#125;) 10. 接口 概念: 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）, 同时，每个接口必须有请求方式 通过GET方式请求接口的过程 (post类似) 11. 接口测试工具PostMan 使用PostMan测试GET接口 选择请求的方式 填写请求的URL地址 填写请求的参数 点击Send 按钮发起GET 请求 查看服务器响应的结果 使用PostMan测试POST接口 选择请求的方式 填写请求的URL地址 选择Body 面板并勾选数据格式 填写要发送到服务器的数据 点击Send 按钮发起POST请求 查看服务器响应的结果 12. 接口文档 是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明 接口文档的组成部分: 接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等 接口URL：接口的调用地址 调用方式：接口的调用方式，如 GET 或 POST 参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容 响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容 返回示例（可选）：通过对象的形式，例举服务器返回数据的结构 01. form表单 表单作用：收集表单数据，从而提交给服务器 组成：表单标签form、表单域、提交按钮 其中表单域包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等 02. form表单属性表单属性: 用来规定如何把采集到的数据发送到服务器 属性 值 描述 action URL地址 规定当提交表单时，向何处发送表单数据 method get或post 规定以何种方式把表单数据提交到action URL enctype application&#x2F;x-www-form-urlencoded multipart&#x2F;form-datatext&#x2F;plain 规定在发送表单数据之前如何对其进行编码 target _ blank _ self _ parent _top framename 规定在何处打开 action URL action action 属性用来规定当提交表单时，向何处发送表单数据 action 属性的值是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。当表单在未指定 action 属性值，action 的默认值为当前页面的 URL 地址 注意：当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址 target target 属性用来规定在何处打开 action URL _blank 在新窗口中打开 _self 默认 在相同的框架中打开 _parent 在父框架集中打开（很少用） _top 在整个窗口中打开（很少用） framename 在指定的框架中打开（很少用） method method 属性用来规定以何种方式把表单数据提交到 action URL 它的可选值有两个，分别是 get 和 post 默认为 get，表示通过URL地址的形式，把表单数据提交到 action URL 提交的数据的格式：url地址?键&#x3D;值&amp;键&#x3D;值?键&#x3D;值&amp;键&#x3D;值 是查询字符串 指要提交的数据 在实际开发中， 表单的 post 提交方式用的最多 get post 区别 get 方式适合用来提交少量的、简单的数据 post 方式适合用来提交大量的、复杂的、或包含文件上传的数据, 数据大小不受限制 get 提交数据的时候，把数据放到url地址后面 post 提交数据的时候，没有数据放到url地址后面，放到请求体里面了 enctype enctype 属性用来规定在发送表单数据之前如何对数据进行编码 application&#x2F;x-www-form-urlencoded 在发送前编码所有字符（默认） multipart&#x2F;form-data 不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值 text&#x2F;plain 空格转换为 “+” 加号，但不对特殊字符编码。（很少用 03. 表单的同步提交 概念: 通过点击 submit 按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交 缺点: 网页发生了跳转,用户体验差 状态 + 数据丢失了 解决：表单只收集数据，ajax将数据提交给服务器 04. 通过Ajax提交表单数据 步骤: 给表单form 注册submit事件 阻止其默认行为 e.preventDefault() 收集表单数据， jQ提供了 serialize(), 必须要有name属性 ajax去发送请求 05. serialize()函数快速获取表单中的数据 1$(selector).serialize() // 必须要有name属性 1234567891011&lt;form id=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt; $(&#x27;#form1&#x27;).serialize() // 调用的结果：键=值&amp;键=值 // username=用户名的值&amp;password=密码的值&lt;/script&gt; 01. 使用xhr发起GET请求XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源 1234567891011121314// 1. 创建 xhr 对象var xhr = new XMLHttpRequest()// 2. 调用 open 函数，指定 请求方式 与 URL地址xhr.open(&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;) // 3. 调用 send 函数，发起 Ajax 请求xhr.send()// 4. 监听 onreadystatechange 事件xhr.onreadystatechange = function() &#123; // 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; // 4.2 打印服务器响应回来的数据 console.log(xhr.responseText) &#125;&#125; 1234// 使用xhr发起带参数的GET请求// 在调用 xhr.open 期间，为 URL 地址指定参数即可// 这种在 URL 地址后面拼接的参数，叫做查询字符串xhr.open(&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&#x27;) XMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态 值 状态 描述 0 UNSENT XMLHttpRequest 对象已被创建，但尚未调用 open方法 1 OPENED open() 方法已经被调用 2 HEADERS_RECEIVED send() 方法已经被调用，响应头也已经被接收 3 LOADING 数据接收中，此时 response 属性中已经包含部分数据 4 DONE Ajax 请求完成，这意味着数据传输已经彻底完成或失败 02. 使用xhr发起POST请求1234567891011121314// 1. 创建 xhr 对象var xhr = new XMLHttpRequest()// 2. 调用 open()xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;)// 3. 设置 Content-Type 属性（固定写法）xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)// 4. 调用 send()，同时将数据以查询字符串的形式，提交给服务器xhr.send(&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=天津图书出版社&#x27;)// 5. 监听 onreadystatechange 事件xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125; 03. 查询字符串 定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量） 格式：将英文的 ? 放在URL 的末尾，然后再加上 参数＝值 ，想加上多个参数的话，使用 &amp; 符号进行分隔 GET请求携带参数的本质: 将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的 1234567$.get(&#x27;url&#x27;, &#123;name: &#x27;zs&#x27;, age: 20&#125;, function() &#123;&#125;)// 等价于$.get(&#x27;url?name=zs&amp;age=20&#x27;, function() &#123;&#125;)$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;url&#x27;, data: &#123;name: &#x27;zs&#x27;, age: 20&#125;, success: function() &#123;&#125; &#125;)// 等价于$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;url?name=zs&amp;age=20&#x27;, success: function() &#123;&#125; &#125;) 04. URL编码与解码URL编码原则：使用英文字符去表示非英文字符 encodeURI() 编码的函数 decodeURI() 解码的函数 1234encodeURI(&#x27;程序员&#x27;)// 输出字符串 %E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98decodeURI(&#x27;%E9%BB%91%E9%A9%AC&#x27;)// 输出字符串 05. 数据交换格式数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式 (XML 和 JSON) JSON: 本质：字符串 字符串表示JS数组和对象 数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型 规律： JSON 数据中不能出现 undefined 和 函数 键必须是双引号（不能没有双引号，不能使用单引号） 值如果是字符串的话，也必须使用双引号 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 2个方法 JSON.parse() 把JSON字符串转成 js对象 反序列化 JSON.stringify() 把 js对象转成 JSON字符串 序列化 06. XMLHttpRequest Level2的新特性 旧版XMLHttpRequest的缺点 只支持文本数据的传输，无法用来读取和上传文件 传送和接收数据时，没有进度信息，只能提示有没有完成 XMLHttpRequest Level2的新功能 可以设置 HTTP 请求的时限 可以使用 FormData 对象管理表单数据 可以上传文件 可以获得数据传输的进度信息 07. 设置HTTP请求时限123xhr.timeout = 3000 // 将最长等待时间设为 3000 毫秒 // 过了这个时限，就自动停止HTTP请求 1234// timeout 事件，用来指定回调函数xhr.ontimeout = function()&#123; alert(&#x27;请求超时！&#x27;)&#125; 08. FormData对象管理表单数据 模拟表单操作 1234567891011// 1. 新建 FormData 对象const fd = new FormData()// 2. 为 FormData 添加表单项fd.append(&#x27;uname&#x27;, &#x27;zs&#x27;)fd.append(&#x27;upwd&#x27;, &#x27;123456&#x27;)// 3. 创建 XHR 对象const xhr = new XMLHttpRequest()// 4. 指定请求类型与URL地址xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/formdata&#x27;)// 5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样xhr.send(fd) 获取网页表单的值 123456789101112// 获取表单元素const form = document.querySelector(&#x27;#form1&#x27;)// 监听表单元素的 submit 事件form.addEventListener(&#x27;submit&#x27;, function(e) &#123; e.preventDefault() // 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中 const fd = new FormData(form) const xhr = new XMLHttpRequest() xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/formdata&#x27;) xhr.send(fd) xhr.onreadystatechange = function() &#123;&#125;&#125;) 09. 上传文件 步骤: 定义 UI 结构 验证是否选择了文件 向 FormData 中追加文件 使用 xhr 发起上传文件的请求 监听 onreadystatechange 事件 12345&lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt; const file = document.querySelector(&#x27;#file&#x27;)file.files.length // 判断是否选择文件// files是属性 以对象形式存储数据 10. 显示文件上传进度 xhr.upload.onprogress 事件，可以获取到文件的上传进度 : 1234567891011// 创建 XHR 对象const xhr = new XMLHttpRequest()// 监听 xhr.upload 的 onprogress 事件xhr.upload.onprogress = function(e) &#123; // e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度 if (e.lengthComputable) &#123; // e.loaded 已传输的字节 // e.total 需传输的总字节 const percentComplete = Math.ceil((e.loaded / e.total) * 100) &#125;&#125; xhr.upload.onload , 监听上传完成的事件 1xhr.upload.onload = function() &#123;&#125; 11. jQuery发起上传文件的请求123456789101112$.ajax(&#123; method: &#x27;POST&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;, data: fd, // 不修改 Content-Type 属性，使用 FormData 默认的 Content-Type 值 contentType: false, // 不对 FormData 中的数据进行 url 编码，而是将 FormData 数据原样发送到服务器 processData: false, success: function(res) &#123; console.log(res) &#125;&#125;) 12. ajaxStart(callback) Ajax 请求开始时，执行 ajaxStart 函数 $(document).ajaxStart() 函数会监听当前文档内所有的 Ajax 请求 1234// 在 ajaxStart 的 callback 中显示 loading 效果$(document).ajaxStart(function() &#123; $(&#x27;#loading&#x27;).show()&#125;) 13. ajaxStop(callback) Ajax 请求结束时，执行 ajaxStop 函数 1234// 在 ajaxStop 的 callback 中隐藏 loading 效果$(document).ajaxStop(function() &#123; $(&#x27;#loading&#x27;).hide()&#125;) 14. axios Axios 是专注于网络数据请求的库 相比于原生的 XMLHttpRequest 对象，axios 简单易用 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。 15. axios发起GET请求1axios.get(&#x27;url&#x27;, &#123; params: &#123; /*参数*/ &#125; &#125;).then(callback) 12345678910// 请求的 URL 地址const url = &#x27;http://www.liulongbin.top:3006/api/get&#x27;// 请求的参数对象const paramsObj = &#123; name: &#x27;zs&#x27;, age: 20 &#125;// 调用 axios.get() 发起 GET 请求axios.get(url, &#123; params: paramsObj &#125;).then(function(res) &#123; // res.data 是服务器返回的数据 const result = res.data console.log(res)&#125;) 16. axios发起POST请求1axios.post(&#x27;url&#x27;, &#123; /*参数*/ &#125;).then(callback) 12345678910// 请求的 URL 地址const url = &#x27;http://www.liulongbin.top:3006/api/post&#x27;// 要提交到服务器的数据const dataObj = &#123; location: &#x27;北京&#x27;, address: &#x27;顺义&#x27; &#125;// 调用 axios.post() 发起 POST 请求axios.post(url, dataObj).then(function(res) &#123; // res.data 是服务器返回的数据 const result = res.data console.log(result)&#125;) 17. 直接使用axios发起请求123456axios(&#123; method: &#x27;请求类型&#x27;, url: &#x27;请求的URL地址&#x27;, data: &#123; /* POST数据 */ &#125;, params: &#123; /* GET参数 */ &#125;&#125;) .then(callback) 1234567891011// 发起GET请求axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/get&#x27;, params: &#123; // GET 参数要通过 params 属性提供 name: &#x27;zs&#x27;, age: 20 &#125;&#125;).then(function(res) &#123; console.log(res.data)&#125;) 1234567891011// 发起POST请求axios(&#123; method: &#x27;POST&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/post&#x27;, data: &#123; // POST 数据要通过 data 属性提供 bookname: &#x27;程序员的自我修养&#x27;, price: 666 &#125;&#125;).then(function(res) &#123; console.log(res.data)&#125;) 数据可视化 DAY01-可视化项目01-项目介绍​ 应对现在数据可视化的趋势，越来越多企业需要在很多场景(营销数据，生产数据，用户数据)下使用，可视化图表来展示体现数据，让数据更加直观，数据特点更加突出。我们引入 ‘立可得’ 数据可视化项目。 ​ 该项目除了使用了基础的DIV+CSS布局，还引入了一些C3技术，还引入了各类图表的绘制，以及高级的地图数据可视化案例。主要功能有：饼状图、柱状图、线形图、地图 … 02-使用技术完成该项目需要具备以下知识： div + css 布局 flex 布局 css3动画 css3渐变 css3边框图片 原生js + jquery 使用 rem适配 echarts基础 粗略代码统计： css 580行 html 450行 js 400行 (有效) 03-Echarts-介绍 ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8&#x2F;9&#x2F;10&#x2F;11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 大白话： 是一个JS插件 性能好可流畅运行PC与移动设备 兼容主流浏览器 提供很多常用图表，且可定制。 折线图、柱状图、散点图、饼图、K线图 04-Echarts-体验官方教程：[五分钟上手ECharts](https://www.echartsjs.com/zh/tutorial.html#5 分钟上手 ECharts) 自己步骤： 下载echarts https://github.com/apache/incubator-echarts/tree/4.5.0 引入echarts dist/echarts.min.js 准备一个具备大小的DOM容器 1&lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; 初始化echarts实例对象 1var myChart = echarts.init(document.getElementById(&#x27;main&#x27;)); 指定配置项和数据(option) 12345678910111213var option = &#123; xAxis: &#123; type: &#x27;category&#x27;, data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;] &#125;, yAxis: &#123; type: &#x27;value&#x27; &#125;, series: [&#123; data: [820, 932, 901, 934, 1290, 1330, 1320], type: &#x27;line&#x27; &#125;]&#125;; 将配置项设置给echarts实例对象 1myChart.setOption(option); 05-Echarts-基础配置 需要了解的主要配置：series xAxis yAxis grid tooltip title legend color series 系列列表。每个系列通过 type 决定自己的图表类型 大白话：图标数据，指定什么类型的图标，可以多个图表重叠。 xAxis：直角坐标系 grid 中的 x 轴 boundaryGap: 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。 yAxis：直角坐标系 grid 中的 y 轴 grid：直角坐标系内绘图网格。 title：标题组件 tooltip：提示框组件 legend：图例组件 color：调色盘颜色列表 数据堆叠，同个类目轴上系列配置相同的stack值后 后一个系列的值会在前一个系列的值上相加。 演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var option = &#123; color: [&#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;skyblue&#x27;, &#x27;red&#x27;], title: &#123; text: &#x27;我的折线图&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, legend: &#123; data: [&#x27;直播营销&#x27;, &#x27;联盟广告&#x27;, &#x27;视频广告&#x27;, &#x27;直接访问&#x27;] &#125;, grid: &#123; left: &#x27;3%&#x27;, right: &#x27;3%&#x27;, bottom: &#x27;3%&#x27;, // 当刻度标签溢出的时候，grid 区域是否包含坐标轴的刻度标签。如果为true，则显示刻度标签 // 如果left right等设置为 0% 刻度标签就溢出了，此时决定是否显示刻度标签 containLabel: true &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, xAxis: &#123; type: &#x27;category&#x27;, // 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。 boundaryGap: false, data: [&#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;周三&#x27;, &#x27;周四&#x27;, &#x27;周五&#x27;, &#x27;周六&#x27;, &#x27;周日&#x27;] &#125;, yAxis: &#123; type: &#x27;value&#x27; &#125;, series: [ &#123; name: &#x27;直播营销&#x27;, // 图表类型是线形图 type: &#x27;line&#x27;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: &#x27;联盟广告&#x27;, type: &#x27;line&#x27;, data: [220, 182, 191, 234, 290, 330, 310] &#125;, &#123; name: &#x27;视频广告&#x27;, type: &#x27;line&#x27;, data: [150, 232, 201, 154, 190, 330, 410] &#125;, &#123; name: &#x27;直接访问&#x27;, type: &#x27;line&#x27;, data: [320, 332, 301, 334, 390, 330, 320] &#125; ] &#125;; 06-REM适配 设计稿是1920px PC端适配： 宽度在 1024~1920之间页面元素宽高自适应 flexible.js 把屏幕分为 24 等份 cssrem 插件的基准值是 80px 插件-配置按钮—配置扩展设置–Root Font Size 里面 设置。 但是别忘记重启vscode软件保证生效 要把屏幕宽度约束在1024~1920之间有适配，实现代码： 123456789101112// 实现rem适配@media screen and (max-width: 1024px) &#123; html &#123; font-size: 42.66px !important; &#125; &#125; @media screen and (min-width: 1920px) &#123; html &#123; font-size: 80px !important; &#125; &#125; 07-基础布局html结构： 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;div class=&quot;viewport&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;!--概览--&gt; &lt;div&gt;&lt;/div&gt; &lt;!--监控--&gt; &lt;div&gt;&lt;/div&gt; &lt;!--点位--&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;!--地图--&gt; &lt;div&gt;&lt;/div&gt; &lt;!--用户--&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;!--订单--&gt; &lt;div&gt;&lt;/div&gt; &lt;!--销售--&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;!--渠道--&gt; &lt;div&gt;&lt;/div&gt; &lt;!--季度--&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--排行--&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果图： 1920px * 1078px body 设置背景图 ，行高1.15 viewport 主体容器，限制最小宽度1024px，与最大宽度1920px，最小高度780px。 需要居中显示 使用logo.png做为背景图，在容器内显示 内间距 88px 20px 0 column 列容器，分三列，占比 3：4：3 中间容器外间距 32px 20px 0 css样式： 12345678910111213141516171819202122232425262728293031323334353637/* 基础布局 */body&#123; font-family: Arial, Helvetica, sans-serif; margin: 0; padding: 0; font-size: 0.5rem; line-height: 1.15; background: url(../images/bg.jpg) no-repeat 0 0 / cover;&#125;h4,h3,ul&#123; margin: 0; padding: 0; font-weight: normal;&#125;ul&#123; list-style: none;&#125;a&#123; text-decoration: none;&#125;.viewport&#123; max-width: 1920px; min-width: 1024px; margin: 0 auto; min-height: 780px; padding: 3.667rem 0.833rem 0; background: url(../images/logo.png) no-repeat 0 0 / contain; display: flex;&#125;.column&#123; flex: 3; position: relative;&#125;.column:nth-child(2)&#123; flex: 4; margin: 1.333rem 0.833rem 0;&#125; 08-边框图片 css3中自适应边框图片运用： 组合写法： 1border-image: url(&quot;images/border.jpg&quot;) 167/20px round; 拆分写法： 1234border-image-source: url(&quot;images/border.jpg&quot;);border-image-slice: 167 167 167 167;border-image-width: 20px;border-image-repeat: round; 解释： 边框图片资源地址 裁剪尺寸（上 右 下 左）单位默认px，可使用百分百。 边框图片的宽度，默认边框的宽度。 平铺方式： stretch 拉伸（默认） repeat 平铺，从边框的中心向两侧开始平铺，会出现不完整的图片。 round 环绕，是完整的使用切割后的图片进行平铺。 DEMO代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;边框图片&lt;/title&gt; &lt;style&gt; ul&#123; margin: 0; padding: 0; list-style: none; &#125; li&#123; width: 350px; height: 160px; border: 20px solid #ccc; margin-top: 20px; &#125; li:nth-child(1)&#123; /*border-image: url(&quot;images/border.jpg&quot;) 167/20px round;*/ border-image-source: url(&quot;images/border.jpg&quot;); border-image-slice: 167 167 167 167; border-image-width: 20px; /*环绕 是完整的使用切割后的图片进行平铺*/ border-image-repeat: round; &#125; li:nth-child(2)&#123; /*平铺 从边框的中心向两侧开始平铺 会出现不完整的图片*/ border-image: url(&quot;images/border.jpg&quot;) 167/20px repeat; &#125; li:nth-child(3)&#123; /*默认的平铺方式*/ border-image: url(&quot;images/border.jpg&quot;) 167/20px stretch; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 09-公用面板样式 所有的面板的基础样式是一致的，提前布局好。 切割示例图： 面板 .panel 容器 .inner 内边距是 上下24px 左右 36px 1234567891011121314151617181920212223/* 公共面板样式 */.panel &#123; position: relative; border: 15px solid transparent; border-width: .6375rem .475rem .25rem 1.65rem; border-image-source: url(../images/border.png); border-image-slice: 51 38 20 132; margin-bottom: .25rem;&#125;.inner &#123; position: absolute; top: -0.6375rem; left: -1.65rem; right: -0.475rem; bottom: -0.25rem; padding: .3rem .45rem; &#125;.panel h3 &#123; font-size: 0.25rem; color: #fff; font-weight: 400;&#125; 10-概览区域(overview)-布局html结构： 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;overview panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;h4&gt;2,190&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #006cff&quot;&gt;&lt;/i&gt; 设备总数 &lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;item&quot;&gt; &lt;h4&gt;190&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #6acca3&quot;&gt;&lt;/i&gt; 季度新增 &lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;h4&gt;3,001&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #6acca3&quot;&gt;&lt;/i&gt; 运营设备 &lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;h4&gt;108&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #ed3f35&quot;&gt;&lt;/i&gt; 异常设备 &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 样式描述： 容器高度 110px h4字体 28px #fff 左边距 4.8px 下间隙 8px span字体 16px #4c9bfd 123456789101112131415161718/* 概览区域 */.overview &#123; height: 1.375rem;&#125;.overview ul &#123; display: flex; justify-content: space-between;&#125;.overview ul li h4 &#123; font-size: .35rem; color: #fff; margin: 0 0 .1rem .06rem;&#125;.overview ul li span &#123; font-size: .2rem; color: #4c9bfd;&#125; 11-监控区域(monitor)-布局html结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;!--监控--&gt;&lt;div class=&quot;monitor panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;tabs&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;active&quot;&gt;故障设备监控&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; &gt;异常设备监控&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;span class=&quot;col&quot;&gt;故障时间&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;设备地址&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;异常代码&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;marquee-view&quot;&gt; &lt;div class=&quot;marquee&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20180701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;11北京市昌平西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000001&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190601&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190704&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000003&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20180701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000004&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000005&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000006&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000007&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000008&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000009&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190710&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000010&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;span class=&quot;col&quot;&gt;异常时间&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;设备地址&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;异常代码&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;marquee-view&quot;&gt; &lt;div class=&quot;marquee&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000001&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190701&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190703&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190704&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190705&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190706&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190707&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190708&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190709&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;col&quot;&gt;20190710&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;北京市昌平区建材城西路金燕龙写字楼&lt;/span&gt; &lt;span class=&quot;col&quot;&gt;1000002&lt;/span&gt; &lt;span class=&quot;icon-dot&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 监控区域 monitor 大盒子的高度是 480px 结构解释： .tabs 标签选项 加上active激活选项 默认激活第一个选项 .content 切换内容 加上style=&quot;display: block;&quot;显示内容 默认激活第一个内容 样式描述： .inner 容器内间距 24px 0 .tabs 容器内间距 0 36px a 容器 颜色： #1950c4 内间距：0 27px 字体：18px 第一个a容器 去除左侧内间距 加上右侧2px宽度边框#00f2f1 激活的时候 颜色白色 .content容器 占满剩余高度 flex:1 默认隐藏 .head 容器 行高 1.05 背景 rgba(255, 255, 255, 0.1) 内间距 12px 36px 颜色 #68d8fe 字体大小 14px row 容器 行高 1.05 内间距 12px 36px 颜色 #68d8ff 字体大小 12px .icon-dot 字体图标 绝对定位 左边0.2rem 透明度0 鼠标经过后：背景 rgba(255, 255, 255, 0.1) 透明度1 col容器 宽度：1rem 2.5rem 1rem 第二个col 一行不换行 溢出 省略 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 监控区域 */.monitor&#123; height: 6rem;&#125;.monitor .inner&#123; padding: .3rem 0; display: flex; flex-direction: column;&#125;.monitor .tabs&#123; padding: 0 .45rem; margin-bottom: 0.225rem; display: flex;&#125;.monitor .tabs a&#123; color:#1950c4; font-size: 0.225rem; padding: 0 .3375rem;&#125;.monitor .tabs a:first-child&#123; padding-left: 0; border-right: 0.025rem solid #00f2f1;&#125;.monitor .tabs a.active&#123; color: #fff;&#125;.monitor .content&#123; flex: 1; position: relative; display: none;&#125;.monitor .head&#123; display: flex; justify-content: space-between; line-height: 1.05; background-color: rgba(255, 255, 255, 0.1); padding: 0.15rem 0.45rem; color: #68d8fe; font-size: 0.175rem;&#125;.monitor .marquee-view &#123; position: absolute; top: 0.5rem; bottom: 0; width: 100%; overflow: hidden;&#125;.monitor .row&#123; display: flex; justify-content: space-between; line-height: 1.05; font-size: 0.15rem; color: #61a8ff; padding: 0.15rem 0.45rem;&#125;.monitor .row .icon-dot&#123; position: absolute; left: 0.2rem; opacity: 0;&#125;.monitor .row:hover &#123; background-color: rgba(255, 255, 255, 0.1); color: #68d8fe;&#125;.monitor .row:hover .icon-dot&#123; opacity: 1;&#125;.monitor .col:first-child&#123; width: 1rem;&#125;.monitor .col:nth-child(2)&#123; width: 2.5rem; white-space: nowrap; text-overflow: ellipsis; overflow: hidden;&#125;.monitor .col:nth-child(3)&#123; width: 1rem;&#125; 12-监控区域-效果切换功能： 绑定 标签页点击 事件 当前容器加active其他容器移除active index对应的内容容器显示其他容器隐藏 1234567 // 切换$(&quot;.monitor .tabs&quot;).on(&quot;click&quot;, &quot;a&quot;, function() &#123; $(this).addClass(&quot;active&quot;).siblings(&quot;a&quot;).removeClass(&quot;active&quot;); // console.log($(this).index()); // 选取对应索引号的content $(&quot;.monitor .content&quot;).eq($(this).index()).show().siblings(&quot;.content&quot;).hide(); &#125;); 动画功能： 实现思路： 先克隆列表，追加在后面 marquee-view 占满剩余高度，溢出隐藏 绝对定位，top 1.6rem bottom 0 宽度100%，溢出隐藏 使用animation实现动画 使用 translateY 向上位移 50% 动画时间15s，匀速播放，循环执行。 js代码： 123456// 动画$(&quot;.marquee-view .marquee&quot;).each(function() &#123; // console.log($(this)); var rows = $(this).children().clone(); $(this).append(rows);&#125;); css代码： 123456789101112131415/* 通过CSS3动画滚动marquee */.marquee-view .marquee &#123; animation: move 15s linear infinite;&#125;@keyframes move &#123; 0% &#123; &#125; 100% &#123; transform: translateY(-50%); &#125;&#125;/* 3.鼠标经过marquee 就停止动画 */.marquee-view .marquee:hover &#123; animation-play-state: paused;&#125; 13-点位区域(point)-布局html结构： 12345678910111213141516171819202122232425&lt;!-- 点位 --&gt;&lt;div class=&quot;point panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;h3&gt;点位分布统计&lt;/h3&gt; &lt;div class=&quot;chart&quot;&gt; &lt;div class=&quot;pie&quot;&gt;&lt;/div&gt; &lt;div class=&quot;data&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;320,11&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #ed3f35&quot;&gt;&lt;/i&gt; 点位总数 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;418&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #eacf19&quot;&gt;&lt;/i&gt; 本月新增 &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css样式： point 盒子高度为 340px 1234567891011121314151617181920212223242526272829303132333435/* 点位 */.point &#123; height: 4.25rem;&#125;.point .chart &#123; display: flex; margin-top: 0.3rem; justify-content: space-between;&#125;.point .pie &#123; width: 3.9rem; height: 3rem; margin-left: -0.125rem; background-color: pink;&#125;.point .data &#123; display: flex; flex-direction: column; justify-content: space-between; width: 2.1rem; padding: .45rem .375rem; box-sizing: border-box; background-image: url(../images/rect.png); background-size: cover;&#125;.point h4 &#123; margin-bottom: 0.15rem; font-size: .35rem; color: #fff;&#125;.point span &#123; display: block; color: #4c9bfd; font-size: .2rem;&#125; 14-点位区域-饼图ECharts图表实现步骤： 从官方示例中找到类似图表，适当修改，引入到HTML页面中。 按照产品需求，来定制图表。 1. HTML引入图表123456789101112131415161718192021222324252627282930313233343536// 点位分布统计模块(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.pie&quot;)); // 2. 指定配置项和数据 var option = &#123; tooltip: &#123; trigger: &quot;item&quot;, formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, series: [ &#123; name: &quot;面积模式&quot;, type: &quot;pie&quot;, radius: [30, 110], center: [&quot;75%&quot;, &quot;50%&quot;], roseType: &quot;area&quot;, data: [ &#123; value: 10, name: &quot;rose1&quot; &#125;, &#123; value: 5, name: &quot;rose2&quot; &#125;, &#123; value: 15, name: &quot;rose3&quot; &#125;, &#123; value: 25, name: &quot;rose4&quot; &#125;, &#123; value: 20, name: &quot;rose5&quot; &#125;, &#123; value: 35, name: &quot;rose6&quot; &#125;, &#123; value: 30, name: &quot;rose7&quot; &#125;, &#123; value: 40, name: &quot;rose8&quot; &#125; ] &#125; ] &#125;; // 3. 配置项和数据给我们的实例化对象 myChart.setOption(option);&#125;)(); 2. 定制需求第一步：参考官方例子，熟悉里面参数具体含义 12345678910111213141516171819202122232425262728293031323334353637383940option = &#123; // 提示框组件 tooltip: &#123; // trigger 触发方式。 非轴图形，使用item的意思是放到数据对应图形上触发提示 trigger: &#x27;item&#x27;, // 格式化提示内容： // a 代表series系列图表名称 // b 代表series数据名称 data 里面的name // c 代表series数据值 data 里面的value // d代表 当前数据/总数据的比例 formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, // 控制图表 series: [ &#123; // 图表名称 name: &#x27;点位统计&#x27;, // 图表类型 type: &#x27;pie&#x27;, // 南丁格尔玫瑰图 有两个圆 内圆半径10% 外圆半径70% // 饼形图半径。 可以是像素。也可以是百分比（ 基于DOM容器大小）第一项是内半径，第二项是外半径（通过它可以实现饼形图大小） radius: [&#x27;10%&#x27;, &#x27;70%&#x27;], // 图表中心位置 left 50% top 50% 距离图表DOM容器 center: [&#x27;50%&#x27;, &#x27;50%&#x27;], // radius 半径模式，另外一种是 area 面积模式 roseType: &#x27;radius&#x27;, // 数据集 value 数据的值 name 数据的名称 data: [ &#123;value:10, name:&#x27;rose1&#x27;&#125;, &#123;value:5, name:&#x27;rose2&#x27;&#125;, &#123;value:15, name:&#x27;rose3&#x27;&#125;, &#123;value:25, name:&#x27;rose4&#x27;&#125;, &#123;value:20, name:&#x27;rose5&#x27;&#125;, &#123;value:35, name:&#x27;rose6&#x27;&#125;, &#123;value:30, name:&#x27;rose7&#x27;&#125;, &#123;value:40, name:&#x27;rose8&#x27;&#125; ] &#125; ]&#125;; 第二步：按照需求定制 需求1：颜色设置 1color: [&#x27;#006cff&#x27;, &#x27;#60cda0&#x27;, &#x27;#ed8884&#x27;, &#x27;#ff9f7f&#x27;, &#x27;#0096ff&#x27;, &#x27;#9fe6b8&#x27;, &#x27;#32c5e9&#x27;, &#x27;#1d9dff&#x27;], 需求2：修改饼形图大小 ( series对象) 1radius: [&#x27;10%&#x27;, &#x27;70%&#x27;], 需求3： 把饼形图的显示模式改为 半径模式 1roseType: &quot;radius&quot;, 需求4：数据使用更换（series对象 里面 data对象） 12345678&#123; value: 20, name: &#x27;云南&#x27; &#125;,&#123; value: 26, name: &#x27;北京&#x27; &#125;,&#123; value: 24, name: &#x27;山东&#x27; &#125;,&#123; value: 25, name: &#x27;河北&#x27; &#125;,&#123; value: 20, name: &#x27;江苏&#x27; &#125;,&#123; value: 25, name: &#x27;浙江&#x27; &#125;,&#123; value: 30, name: &#x27;四川&#x27; &#125;,&#123; value: 42, name: &#x27;湖北&#x27; &#125; 需求5：字体略小些 10 px ( series对象里面设置 ) 饼图图形上的文本标签可以控制饼形图的文字的一些样式。 label 对象设置 1234567891011121314series: [ &#123; name: &quot;面积模式&quot;, type: &quot;pie&quot;, radius: [30, 110], center: [&quot;50%&quot;, &quot;50%&quot;], roseType: &quot;radius&quot;, // 文本标签控制饼形图文字的相关样式， 注意它是一个对象 label: &#123; fontSize: 10 &#125;, &#125; ] &#125;; 需求6：防止缩放的时候，引导线过长。引导线略短些 (series对象里面的 labelLine 对象设置 ) 连接图表 6 px 连接文字 8 px 1234567891011121314+ // 文字调整+ label:&#123;+ fontSize: 10+ &#125;,+ // 引导线调整+ labelLine: &#123;+ // 连接扇形图线长+ length: 6,+ // 连接文字线长+ length2: 8+ &#125; + &#125;+ ], 需求6：浏览器缩放的时候，图表跟着自动适配。 1234// 监听浏览器缩放，图表对象调用缩放resize函数window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;); 点位统计完整JavaScript代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 点位分布统计模块(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.pie&quot;)); // 2. 指定配置项和数据 var option = &#123; tooltip: &#123; trigger: &quot;item&quot;, formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, // 注意颜色写的位置 color: [ &quot;#006cff&quot;, &quot;#60cda0&quot;, &quot;#ed8884&quot;, &quot;#ff9f7f&quot;, &quot;#0096ff&quot;, &quot;#9fe6b8&quot;, &quot;#32c5e9&quot;, &quot;#1d9dff&quot; ], series: [ &#123; name: &quot;点位统计&quot;, type: &quot;pie&quot;, // 如果radius是百分比则必须加引号 radius: [&quot;10%&quot;, &quot;70%&quot;], center: [&quot;50%&quot;, &quot;50%&quot;], roseType: &quot;radius&quot;, data: [ &#123; value: 20, name: &quot;云南&quot; &#125;, &#123; value: 26, name: &quot;北京&quot; &#125;, &#123; value: 24, name: &quot;山东&quot; &#125;, &#123; value: 25, name: &quot;河北&quot; &#125;, &#123; value: 20, name: &quot;江苏&quot; &#125;, &#123; value: 25, name: &quot;浙江&quot; &#125;, &#123; value: 30, name: &quot;四川&quot; &#125;, &#123; value: 42, name: &quot;湖北&quot; &#125; ], // 修饰饼形图文字相关的样式 label对象 label: &#123; fontSize: 10 &#125;, // 修饰引导线样式 labelLine: &#123; // 连接到图形的线长度 length: 6, // 连接到文字的线长度 length2: 8 &#125; &#125; ] &#125;; // 3. 配置项和数据给我们的实例化对象 myChart.setOption(option); // 4. 当我们浏览器缩放的时候，图表也等比例缩放 window.addEventListener(&quot;resize&quot;, function() &#123; // 让我们的图表调用 resize这个方法 myChart.resize(); &#125;);&#125;)(); 15-地图区域 (map) -预留布局html结构： 12345678910&lt;!-- 地图 --&gt;&lt;div class=&quot;map&quot;&gt; &lt;h3&gt; &lt;span class=&quot;icon-cube&quot;&gt;&lt;/span&gt; 设备数据统计 &lt;/h3&gt; &lt;div class=&quot;chart&quot;&gt; &lt;div class=&quot;geo&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css样式： 1234567891011121314151617181920212223242526/* 地图 */.map &#123; height: 7.225rem; margin-bottom: 0.25rem; display: flex; flex-direction: column;&#125;.map h3 &#123; line-height: 1; padding: 0.2rem 0; margin: 0; font-size: 0.25rem; color: #fff; font-weight: 400;&#125;.map .icon-cube &#123; color: #68d8fe;&#125;.map .chart &#123; flex: 1; background-color: rgba(255, 255, 255, 0.05);&#125;.map .geo &#123; width: 100%; height: 100%;&#125; 注意第二列（column) 有个外边距（上面 32px 左右 20px 下是 0） 1234.viewport .column:nth-child(2) &#123; flex: 4; margin: .4rem .25rem 0;&#125; 16-用户统计 (users) -布局html结构： 12345678910111213141516171819202122232425&lt;!-- 用户 --&gt;&lt;div class=&quot;users panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;h3&gt;全国用户总量统计&lt;/h3&gt; &lt;div class=&quot;chart&quot;&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;data&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;120,899&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #ed3f35&quot;&gt;&lt;/i&gt; 用户总量 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;248&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #eacf19&quot;&gt;&lt;/i&gt; 本月新增 &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css样式： 123456789101112131415161718192021222324252627282930313233/* 用户模块 */.users &#123; height: 4.25rem; display: flex;&#125;.users .chart &#123; display: flex; margin-top: .3rem;&#125;.users .bar &#123; width: 7.35rem; height: 3rem;&#125;.users .data &#123; display: flex; flex-direction: column; justify-content: space-between; width: 2.1rem; padding: .45rem .375rem; box-sizing: border-box; background-image: url(../images/rect.png); background-size: cover;&#125;.users h4 &#123; margin-bottom: .15rem; font-size: .35rem; color: #fff;&#125;.users span &#123; display: block; color: #4c9bfd; font-size: 0.2rem;&#125; 17-用户统计 (users) -柱状图实现步骤： 从官方示例中找到最接近项目需求的例子，适当修改, 引入到HTML页面中 按照产品需求，来定制图表。 第一步：参考官方示例 + 分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364(function () &#123;// 1. 实例化对象var myChart = echarts.init(document.querySelector(&quot;.bar&quot;));// 2. 指定配置和数据var option = &#123; // 工具提示 tooltip: &#123; // 触发类型 经过轴触发axis 经过轴触发item trigger: &#x27;axis&#x27;, // 轴触发提示才有效 axisPointer: &#123; // 默认为直线，可选为：&#x27;line&#x27; 线效果 | &#x27;shadow&#x27; 阴影效果 type: &#x27;shadow&#x27; &#125; &#125;, // 图表边界控制 grid: &#123; // 距离 上右下左 的距离 left: &#x27;3%&#x27;, right: &#x27;4%&#x27;, bottom: &#x27;3%&#x27;, // 是否包含文本 containLabel: true &#125;, // 控制x轴 xAxis: [ &#123; // 使用类目，必须有data属性 type: &#x27;category&#x27;, // 使用 data 中的数据设为刻度文字 data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;], // 刻度设置 axisTick: &#123; // true意思：图形在刻度中间 // false意思：图形在刻度之间 alignWithLabel: true &#125; &#125; ], // 控制y轴 yAxis: [ &#123; // 使用数据的值设为刻度文字 type: &#x27;value&#x27; &#125; ], // 控制x轴 series: [ &#123; // 图表数据名称 name: &#x27;用户统计&#x27;, // 图表类型 type: &#x27;bar&#x27;, // 柱子宽度 barWidth: &#x27;60%&#x27;, // 数据 data: [10, 52, 200, 334, 390, 330, 220] &#125; ] &#125;; // 3. 把配置给实例对象 myChart.setOption(option);&#125;)(); 第二步：按照需求修改 需求1： 修改柱子的颜色 1234567891011121314151617181920212223// 修改线性渐变色方式 1color: new echarts.graphic.LinearGradient( // (x1,y2) 点到点 (x2,y2) 之间进行渐变 0, 0, 0, 1, [ &#123; offset: 0, color: &#x27;#00fffb&#x27; &#125;, // 0 起始颜色 &#123; offset: 1, color: &#x27;#0061ce&#x27; &#125; // 1 结束颜色 ] ),// 修改线性渐变色方式 2color: &#123; type: &#x27;linear&#x27;, x: 0, y: 0, x2: 0, y2: 1, colorStops: [&#123; offset: 0, color: &#x27;red&#x27; // 0% 处的颜色 &#125;, &#123; offset: 1, color: &#x27;blue&#x27; // 100% 处的颜色 &#125;], globalCoord: false // 缺省为 false&#125;, 需求2： 提示框组件放到柱子上触发， 没有阴影等效果 1234567//提示框组件tooltip: &#123; trigger: &#x27;item&#x27;, // axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 这个模块我们此时不需要删掉即可 // type: &#x27;shadow&#x27; // 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27; // &#125;&#125;, 需求3： 修改柱形图表大小， 以及相关网格。 饼形图修改图表大小是通过 series 对象里面的 radius 柱形图修改图标大小是通过 series 对象里面的 grid 对象 left right 等 显示网格 show: true，网格颜色是 borderColor 1234567891011121314// 直角坐标系内绘图网格（区域）grid: &#123; top: &#x27;3%&#x27;, right: &#x27;3%&#x27;, bottom: &#x27;3%&#x27;, left: &#x27;0%&#x27;, // 图表位置紧贴画布边缘是否显示刻度以及label文字 防止坐标轴标签溢出跟grid 区域有关系 containLabel: true, // 是否显示直角坐标系网格 show: true, //grid 四条边框的颜色 borderColor: &#x27;rgba(0, 240, 255, 0.3)&#x27;&#125;, 需求4： X 轴调整 柱子在刻度之间 剔除刻度不显示 刻度标签文字颜色 #4c9bfd 通过 axisLabel 对象设置 修改x轴线的颜色 axisLine 里面的 lineStyle 12345678910111213141516171819202122232425262728// 控制x轴xAxis: [ &#123; // 使用类目，必须有data属性 type: &#x27;category&#x27;, // 使用 data 中的数据设为刻度文字 data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;], // 刻度设置 axisTick: &#123; // true意思：图形和刻度居中中间 // false意思：图形在刻度之间 alignWithLabel: false, // 不显示刻度 show: false &#125;, // x坐标轴文字标签样式设置 axisLabel: &#123; color: &#x27;#4c9bfd&#x27; &#125;, // x坐标轴颜色设置 axisLine:&#123; lineStyle:&#123; color:&#x27;rgba(0, 240, 255, 0.3)&#x27;, // width:8, x轴线的粗细 // opcity: 0, 如果不想显示x轴线 则改为 0 &#125; &#125; &#125; 需求5： Y 轴调整 剔除刻度不显示 Y轴文字颜色 #4c9bfd 通过 axisLabel 对象设置 Y轴分割线颜色 splitLine 对象里面 lineStyle 对象设置 12345678910111213141516171819202122232425262728293031// 控制y轴yAxis: [ &#123; // 使用类目，必须有data属性 type: &#x27;category&#x27;, // 使用 data 中的数据设为刻度文字 data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;], // 刻度设置 axisTick: &#123; // 不显示刻度 show: false &#125;, // y坐标轴文字标签样式设置 axisLabel: &#123; color: &#x27;#4c9bfd&#x27; &#125;, // y坐标轴颜色设置 axisLine:&#123; lineStyle:&#123; color:&#x27;rgba(0, 240, 255, 0.3)&#x27;, // width:8, x轴线的粗细 // opcity: 0, 如果不想显示x轴线 则改为 0 &#125; &#125;, // y轴 分割线的样式 splitLine: &#123; lineStyle: &#123; color: &#x27;rgba(0, 240, 255, 0.3)&#x27; &#125; &#125; ], 需求6：调整数据，与省略图形定制 12// seriesdata: [2100,1900,1700,1560,1400,1200,1200,1200,900,750,600,480,240] 12// xAxisdata: [&#x27;上海&#x27;, &#x27;广州&#x27;, &#x27;北京&#x27;, &#x27;深圳&#x27;, &#x27;合肥&#x27;, &#x27;&#x27;, &#x27;......&#x27;, &#x27;&#x27;, &#x27;杭州&#x27;, &#x27;厦门&#x27;, &#x27;济南&#x27;, &#x27;成都&#x27;, &#x27;重庆&#x27;] 省略图形 经过图形才显示提示，且省略的柱子不需要提示 图形单独设置颜色 12345678910111213141516171819// 中间省略的数据 准备三项var item = &#123; name:&#x27;&#x27;, value: 1200, // 柱子颜色 itemStyle: &#123; color: &#x27;#254065&#x27; &#125;, // 鼠标经过柱子颜色 emphasis: &#123; itemStyle: &#123; color: &#x27;#254065&#x27; &#125; &#125;, // 工具提示隐藏 tooltip: &#123; extraCssText: &#x27;opacity:0&#x27; &#125;, &#125; 12// series配置data选项在中使用data: [2100,1900,1700,1560,1400,item,item,item,900,750,600,480,240], 12345// 4. 当我们浏览器缩放的时候，图表也等比例缩放window.addEventListener(&quot;resize&quot;, function() &#123; // 让我们的图表调用 resize这个方法 myChart.resize();&#125;); 18-订单区域（order）-布局html结构： 1234567891011121314151617181920212223242526272829&lt;!-- 订单 --&gt;&lt;div class=&quot;order panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;!-- 筛选 --&gt; &lt;div class=&quot;filter&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;active&quot;&gt;365天&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; &gt;90天&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; &gt;30天&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; &gt;24小时&lt;/a&gt; &lt;/div&gt; &lt;!-- 数据 --&gt; &lt;div class=&quot;data&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;20,301,987&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #ed3f35;&quot;&gt;&lt;/i&gt; 订单量 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;99834&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #eacf19;&quot;&gt;&lt;/i&gt; 销售额(万元) &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css样式： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 订单 */.order &#123; height: 1.875rem;&#125;.order .filter &#123; display: flex;&#125;.order .filter a &#123; display: block; height: 0.225rem; line-height: 1; padding: 0 0.225rem; color: #1950c4; font-size: 0.225rem; border-right: 0.025rem solid #00f2f1;&#125;.order .filter a:first-child &#123; padding-left: 0;&#125;.order .filter a:last-child &#123; border-right: none;&#125;.order .filter a.active &#123; color: #fff; font-size: 0.25rem;&#125;.order .data &#123; display: flex; margin-top: 0.25rem;&#125;.order .item &#123; width: 50%;&#125;.order h4 &#123; font-size: 0.35rem; color: #fff; margin-bottom: 0.125rem;&#125;.order span &#123; display: block; color: #4c9bfd; font-size: 0.2rem;&#125; 18-订单区域（order）-效果 ( 课后作业 )实现步骤： 提前准备数据 点击后切tab激活样式 点击后切换数据内容 开启定时器动态切换数据 123456789101112131415161718192021222324252627282930// 订单功能(function()&#123; // 1. 准备数据 var data = &#123; day365: &#123; orders: &#x27;20,301,987&#x27;, amount: &#x27;99834&#x27; &#125;, day90: &#123; orders: &#x27;301,987&#x27;, amount: &#x27;9834&#x27; &#125;, day30: &#123; orders: &#x27;1,987&#x27;, amount: &#x27;3834&#x27; &#125;, day1: &#123; orders: &#x27;987&#x27;, amount: &#x27;834&#x27; &#125; &#125; // 获取显示 订单数量 容器 var $h4Orders = $(&#x27;.order h4:eq(0)&#x27;) // 获取显示 金额数量 容器 var $h4Amount = $(&#x27;.order h4:eq(1)&#x27;) $(&#x27;.order&#x27;).on(&#x27;click&#x27;,&#x27;.filter a&#x27;,function()&#123; // 2. 点击切换激活样式 $(this).addClass(&#x27;active&#x27;).siblings().removeClass(&#x27;active&#x27;) // 3. 点击切换数据 var currdata = data[this.dataset.key] $h4Orders.html(currdata.orders) $h4Amount.html(currdata.amount) &#125;) // 4. 开启定时器切换数据 var index = 0 var $allTab = $(&#x27;.order .filter a&#x27;) setInterval(function()&#123; index ++ if (index &gt;= 4) index = 0 $allTab.eq(index).click() &#125;,5000)&#125;)(); 19-销售统计( sales )-布局html结构： 12345678910111213141516&lt;!-- 销售额 --&gt;&lt;div class=&quot;sales panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h3&gt;销售额统计&lt;/h3&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;active&quot; &gt;年&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; &gt;季&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; &gt;月&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; &gt;周&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;chart&quot;&gt; &lt;div class=&quot;label&quot;&gt;单位:万&lt;/div&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css样式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 销售区域 */.sales &#123; height: 3.1rem;&#125;.sales .caption &#123; display: flex; line-height: 1;&#125;.sales h3 &#123; height: 0.225rem; padding-right: 0.225rem; border-right: 0.025rem solid #00f2f1;&#125;.sales a &#123; padding: 0.05rem; font-size: 0.2rem; margin: -0.0375rem 0 0 0.2625rem; border-radius: 0.0375rem; color: #0bace6;&#125;.sales a.active &#123; background-color: #4c9bfd; color: #fff;&#125;.sales .inner &#123; display: flex; flex-direction: column;&#125;.sales .chart &#123; flex: 1; padding-top: 0.1875rem; position: relative;&#125;.sales .label &#123; position: absolute; left: 0.525rem; top: 0.225rem; color: #4996f5; font-size: 0.175rem;&#125;.sales .line &#123; width: 100%; height: 100%;&#125; 19-销售统计( sales )-线形图实现步骤： 寻找官方的类似示例，给予分析, 引入到HTML页面中 按照需求来定制它。 第一步：寻找官方的类似示例，给予分析。 官方参考示例：https://www.echartsjs.com/examples/zh/editor.html?c=line-stack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 销售统计模块(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.line&quot;)); // 2. 指定配置和数据 var option = &#123; tooltip: &#123; trigger: &quot;axis&quot; &#125;, legend: &#123; data: [&quot;邮件营销&quot;, &quot;联盟广告&quot;] &#125;, grid: &#123; left: &quot;3%&quot;, right: &quot;4%&quot;, bottom: &quot;3%&quot;, containLabel: true &#125;, xAxis: &#123; type: &quot;category&quot;, boundaryGap: false, data: [&quot;周一&quot;, &quot;周二&quot;] &#125;, yAxis: &#123; type: &quot;value&quot; &#125;, series: [ &#123; name: &quot;邮件营销&quot;, type: &quot;line&quot;, stack: &quot;总量&quot;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: &quot;联盟广告&quot;, type: &quot;line&quot;, stack: &quot;总量&quot;, data: [220, 182, 191, 234, 290, 330, 310] &#125; ] &#125;; // 3. 把配置和数据给实例对象 myChart.setOption(option);&#125;)(); 第二步：按照需求来定制它。 需求1： 修改折线图大小，显示边框设置颜色：#012f4a，并且显示刻度标签。 12345678910// 设置网格样式grid: &#123; top: &#x27;20%&#x27;, left: &#x27;3%&#x27;, right: &#x27;4%&#x27;, bottom: &#x27;3%&#x27;, show: true,// 显示边框 borderColor: &#x27;#012f4a&#x27;,// 边框颜色 containLabel: true // 包含刻度文字在内&#125;, 需求2： 修改图例组件中的文字颜色 #4c9bfd， 距离右侧 right 为 10% 1234567// 图例组件 legend: &#123; textStyle: &#123; color: &#x27;#4c9bfd&#x27; // 图例文字颜色 &#125;, right: &#x27;10%&#x27; // 距离右边10% &#125;, 需求3： x轴相关配置 刻度去除 x轴刻度标签字体颜色：#4c9bfd 剔除坐标轴线颜色（将来使用Y轴分割线) 轴两端是不需要内间距 boundaryGap 1234567891011121314 xAxis: &#123; type: &#x27;category&#x27;, data: [&quot;周一&quot;, &quot;周二&quot;],axisTick: &#123; show: false // 去除刻度线 &#125;, axisLabel: &#123; color: &#x27;#4c9bfd&#x27; // 文本颜色 &#125;, axisLine: &#123; show: false // 去除轴线 &#125;, boundaryGap: false // 去除轴内间距 &#125;, 需求4： y轴的定制 刻度去除 字体颜色：#4c9bfd 分割线颜色：#012f4a 1234567891011121314yAxis: &#123; type: &#x27;value&#x27;, axisTick: &#123; show: false // 去除刻度 &#125;, axisLabel: &#123; color: &#x27;#4c9bfd&#x27; // 文字颜色 &#125;, splitLine: &#123; lineStyle: &#123; color: &#x27;#012f4a&#x27; // 分割线颜色 &#125; &#125;&#125;, 需求5： 两条线形图定制 颜色分别：#00f2f1 #ed3f35 把折线修饰为圆滑 series 数据中添加 smooth 为 true 12345678910111213 color: [&#x27;#00f2f1&#x27;, &#x27;#ed3f35&#x27;],series: [&#123; name:&#x27;预期销售额&#x27;, data: [820, 932, 901, 934, 1290, 1330, 1320], type: &#x27;line&#x27;, // 折线修饰为圆滑 smooth: true, &#125;,&#123; name:&#x27;实际销售额&#x27;, data: [100, 331, 200, 123, 233, 543, 400], type: &#x27;line&#x27;, smooth: true, &#125;] 需求6： 配置数据 1234// x轴的文字xAxis: &#123; type: &#x27;category&#x27;, data: [&#x27;1月&#x27;, &#x27;2月&#x27;, &#x27;3月&#x27;, &#x27;4月&#x27;, &#x27;5月&#x27;, &#x27;6月&#x27;, &#x27;7月&#x27;, &#x27;8月&#x27;, &#x27;9月&#x27;, &#x27;10月&#x27;, &#x27;11月&#x27;, &#x27;12月&#x27;], 12345678910111213// 图标数据 series: [&#123; name:&#x27;预期销售额&#x27;, data: [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120], type: &#x27;line&#x27;, smooth: true &#125;,&#123; name:&#x27;实际销售额&#x27;, data: [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79], type: &#x27;line&#x27;, smooth: true &#125; &#125;] 总结：现在给的是年份数据，还需要切换效果。 19-销售统计( sales )-切换效果实现步骤： 准备切换需要依赖的数据 4组 绑定点击事件 切换激活 tab 的样式 切换图表依赖的数据（重新渲染图表） 开启定时器，进行切换， 鼠标经过sales停止定时器，离开开启定时器 第一步：准备数据，使用数据 123456789101112131415161718var data = &#123; year: [ [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120], [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79] ], quarter: [ [23, 75, 12, 97, 21, 67, 98, 21, 43, 64, 76, 38], [43, 31, 65, 23, 78, 21, 82, 64, 43, 60, 19, 34] ], month: [ [34, 87, 32, 76, 98, 12, 32, 87, 39, 36, 29, 36], [56, 43, 98, 21, 56, 87, 43, 12, 43, 54, 12, 98] ], week: [ [43, 73, 62, 54, 91, 54, 84, 43, 86, 43, 54, 53], [32, 54, 34, 87, 32, 45, 62, 68, 93, 54, 54, 24] ]&#125; 1234567891011121314151617series: [&#123; name:&#x27;预期销售额&#x27;, data: data.year[0], type: &#x27;line&#x27;, smooth: true, itemStyle: &#123; color: &#x27;#00f2f1&#x27; &#125;&#125;,&#123; name:&#x27;实际销售额&#x27;, data: data.year[1], type: &#x27;line&#x27;, smooth: true, itemStyle: &#123; color: &#x27;#ed3f35&#x27; &#125;&#125;] 第二步：点击后切换 1234567891011121314// 切换$(&#x27;.sales&#x27;).on(&#x27;click&#x27;, &#x27;.caption a&#x27;, function()&#123; // 样式 $(this).addClass(&#x27;active&#x27;).siblings().removeClass(&#x27;active&#x27;) // currData 当前对应的数据 // this.dataset.type 标签上的data-type属性值，对应data中的属性 var currData = data[this.dataset.type] // 修改图表1的数据 option.series[0].data = currData[0] // 修改图表2的数据 option.series[1].data = currData[1] // 重新设置数据 让图标重新渲染 myChart.setOption(option)&#125;) 第三步：tab栏自动切换效果 开启定时器每隔3s，自动让a触发点击事件即可 鼠标经过sales，关闭定时器，离开开启定时器 123456789101112131415161718192021var as = $(&quot;.sales .caption a&quot;); var index = 0; var timer = setInterval(function() &#123; index++; if (index &gt;= 4) index = 0; as.eq(index).click(); &#125;, 1000); // 鼠标经过sales，关闭定时器，离开开启定时器 $(&quot;.sales&quot;).hover( function() &#123; clearInterval(timer); &#125;, function() &#123; clearInterval(timer); timer = setInterval(function() &#123; index++; if (index &gt;= 4) index = 0; as.eq(index).click(); &#125;, 1000); &#125; ); 自动缩放 12345// 当我们浏览器缩放的时候，图表也等比例缩放 window.addEventListener(&quot;resize&quot;, function() &#123; // 让我们的图表调用 resize这个方法 myChart.resize(); &#125;); 20-渠道区域&amp;销售进度-布局html结构： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 渠道 季度 --&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;channel panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;h3&gt;渠道分布&lt;/h3&gt; &lt;div class=&quot;data&quot;&gt; &lt;div class=&quot;radar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;quarter panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;h3&gt;一季度销售进度&lt;/h3&gt; &lt;div class=&quot;chart&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;gauge&quot;&gt;&lt;/div&gt; &lt;div class=&quot;label&quot;&gt;75&lt;small&gt; %&lt;/small&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;data&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;1,321&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #6acca3&quot;&gt;&lt;/i&gt; 销售额(万元) &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;h4&gt;150%&lt;/h4&gt; &lt;span&gt; &lt;i class=&quot;icon-dot&quot; style=&quot;color: #ed3f35&quot;&gt;&lt;/i&gt; 同比增长 &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; css样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 渠道区块 */.wrap &#123; display: flex;&#125;.channel,.quarter &#123; flex: 1; height: 2.9rem;&#125;.channel &#123; margin-right: 0.25rem;&#125;.channel .data &#123; overflow: hidden;&#125;.channel .data .radar &#123; height: 2.1rem; width: 100%; background-color: pink;&#125;.channel h4 &#123; color: #fff; font-size: 0.4rem; margin-bottom: 0.0625rem;&#125;.channel small &#123; font-size: 50%;&#125;.channel span &#123; display: block; color: #4c9bfd; font-size: 0.175rem;&#125;/* 季度区块 */.quarter .inner &#123; display: flex; flex-direction: column; margin: 0 -0.075rem;&#125;.quarter .chart &#123; flex: 1; padding-top: 0.225rem;&#125;.quarter .box &#123; position: relative;&#125;.quarter .label &#123; transform: translate(-50%, -30%); color: #fff; font-size: 0.375rem; position: absolute; left: 50%; top: 50%;&#125;.quarter .label small &#123; font-size: 50%;&#125;.quarter .gauge &#123; height: 1.05rem;&#125;.quarter .data &#123; display: flex; justify-content: space-between;&#125;.quarter .item &#123; width: 50%;&#125;.quarter h4 &#123; color: #fff; font-size: 0.3rem; margin-bottom: 0.125rem;&#125;.quarter span &#123; display: block; width: 100%; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; color: #4c9bfd; font-size: 0.175rem;&#125; 21-渠道分布(channel)-雷达图实现步骤： 寻找官方的类似示例，给予分析，并引入到HTML页面中 按照需求来定制它 第一步： 参考类似实例： https://www.echartsjs.com/examples/zh/editor.html?c=radar-aqi 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.radar&quot;)); // 2.指定配置 var dataBJ = [[55, 9, 56, 0.46, 18, 6, 1]]; var lineStyle = &#123; normal: &#123; width: 1, opacity: 0.5 &#125; &#125;; var option = &#123; backgroundColor: &quot;#161627&quot;, radar: &#123; indicator: [ &#123; name: &quot;AQI&quot;, max: 300 &#125;, &#123; name: &quot;PM2.5&quot;, max: 250 &#125;, &#123; name: &quot;PM10&quot;, max: 300 &#125;, &#123; name: &quot;CO&quot;, max: 5 &#125;, &#123; name: &quot;NO2&quot;, max: 200 &#125;, &#123; name: &quot;SO2&quot;, max: 100 &#125; ], shape: &quot;circle&quot;, splitNumber: 5, name: &#123; textStyle: &#123; color: &quot;rgb(238, 197, 102)&quot; &#125; &#125;, splitLine: &#123; lineStyle: &#123; color: [ &quot;rgba(238, 197, 102, 0.1)&quot;, &quot;rgba(238, 197, 102, 0.2)&quot;, &quot;rgba(238, 197, 102, 0.4)&quot;, &quot;rgba(238, 197, 102, 0.6)&quot;, &quot;rgba(238, 197, 102, 0.8)&quot;, &quot;rgba(238, 197, 102, 1)&quot; ].reverse() &#125; &#125;, splitArea: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: &quot;rgba(238, 197, 102, 0.5)&quot; &#125; &#125; &#125;, series: [ &#123; name: &quot;北京&quot;, type: &quot;radar&quot;, lineStyle: lineStyle, data: dataBJ, symbol: &quot;none&quot;, itemStyle: &#123; color: &quot;#F9713C&quot; &#125;, areaStyle: &#123; opacity: 0.1 &#125; &#125; ] &#125;; // 3.把配置和数据给对象 myChart.setOption(option);&#125;)(); 第二步： 按照需求来定制它 需求1： 去掉背景颜色，调整雷达图大小 65% 12345radar:&#123; center: [&#x27;50%&#x27;, &#x27;50%&#x27;], // 外半径占据容器大小 radius: &#x27;65%&#x27;,&#125; 需求2： 指示器轴的分割段数为4条（4个圆圈） 1234567radar:&#123; center: [&#x27;50%&#x27;, &#x27;50%&#x27;], // 外半径占据容器大小 radius: &#x27;65%&#x27;, // 指示器轴的分割段数 splitNumber: 4,&#125; 需求3： 雷达图分割线设为白色半透明 0.5 12345678// 坐标轴在 grid 区域中的分隔线（圆圈） splitLine: &#123; lineStyle: &#123; color: &#x27;rgba(255, 255, 255, 0.5)&#x27;, // width: 2, // type: &#x27;dashed&#x27; &#125; &#125;, 需求4： 雷达图 坐标轴轴线相关设置(竖线) axisLine 123456789// 坐标轴轴线相关设置(竖线)axisLineaxisLine: &#123; show: true, lineStyle: &#123; color: &#x27;rgba(255, 255, 255, 0.5)&#x27; // width: 1, // type: &#x27;solid&#x27; &#125; &#125;, 需求5： 修饰雷达图文字颜色为 #4c9bfd 123456name: &#123; // 修饰雷达图文本颜色 textStyle: &#123; color: &#x27;#4c9bfd&#x27; &#125;&#125;, 需求6： 修饰 区域填充样式 series 对象 区域填充的背景颜色设置为： rgba(238, 197, 102, 0.6) 123 areaStyle: &#123; color: &#x27;rgba(238, 197, 102, 0.6)&#x27;,&#125;, 区域填充的线条颜色为白色 1234567// 线条样式 lineStyle: &#123; normal: &#123; color: &#x27;#fff&#x27;, // width: 1 &#125;&#125;, 需求7： 标记的图形(拐点）设置 注意 series 里面设置 用圆点显示， 拐点的大小设置为 5 小圆点设置为白色 在小圆点上显示相关数据，颜色设置为白色，10像素 1234567891011121314// symbol 标记的样式(拐点），还可以取值&#x27;rect&#x27; 方块 ,&#x27;arrow&#x27; 三角等symbol: &#x27;circle&#x27;, // 拐点的大小 symbolSize: 5, // 小圆点（拐点）设置为白色itemStyle: &#123; color: &#x27;#fff&#x27;&#125;,// 在圆点上显示相关数据label: &#123; show: true, color: &#x27;#fff&#x27;, fontSize: 10&#125;, 需求8： 鼠标经过显示提示框组件 12345tooltip: &#123; show: true, // 控制提示框组件的显示位置 position: [&#x27;60%&#x27;, &#x27;10%&#x27;],&#125;, 需求9： 更换数据 12345678// 雷达图的指示器 内部填充数据 indicator: [ &#123; name: &#x27;机场&#x27;, max: 100 &#125;, &#123; name: &#x27;商场&#x27;, max: 100 &#125;, &#123; name: &#x27;火车站&#x27;, max: 100 &#125;, &#123; name: &#x27;汽车站&#x27;, max: 100 &#125;, &#123; name: &#x27;地铁&#x27;, max: 100 &#125;], 1data: [[90, 19, 56, 11, 34]], 整个代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 销售渠道模块 雷达图(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.radar&quot;)); // 2.指定配置 var option = &#123; tooltip: &#123; show: true, // 控制提示框组件的显示位置 position: [&quot;60%&quot;, &quot;10%&quot;] &#125;, radar: &#123; indicator: [ &#123; name: &quot;机场&quot;, max: 100 &#125;, &#123; name: &quot;商场&quot;, max: 100 &#125;, &#123; name: &quot;火车站&quot;, max: 100 &#125;, &#123; name: &quot;汽车站&quot;, max: 100 &#125;, &#123; name: &quot;地铁&quot;, max: 100 &#125; ], // 修改雷达图的大小 radius: &quot;65%&quot;, shape: &quot;circle&quot;, // 分割的圆圈个数 splitNumber: 4, name: &#123; // 修饰雷达图文字的颜色 textStyle: &#123; color: &quot;#4c9bfd&quot; &#125; &#125;, // 分割的圆圈线条的样式 splitLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255, 0.5)&quot; &#125; &#125;, splitArea: &#123; show: false &#125;, // 坐标轴的线修改为白色半透明 axisLine: &#123; lineStyle: &#123; color: &quot;rgba(255, 255, 255, 0.5)&quot; &#125; &#125; &#125;, series: [ &#123; name: &quot;北京&quot;, type: &quot;radar&quot;, // 填充区域的线条颜色 lineStyle: &#123; normal: &#123; color: &quot;#fff&quot;, width: 1, opacity: 0.5 &#125; &#125;, data: [[90, 19, 56, 11, 34]], // 设置图形标记 （拐点） symbol: &quot;circle&quot;, // 这个是设置小圆点大小 symbolSize: 5, // 设置小圆点颜色 itemStyle: &#123; color: &quot;#fff&quot; &#125;, // 让小圆点显示数据 label: &#123; show: true, fontSize: 10 &#125;, // 修饰我们区域填充的背景颜色 areaStyle: &#123; color: &quot;rgba(238, 197, 102, 0.6)&quot; &#125; &#125; ] &#125;; // 3.把配置和数据给对象 myChart.setOption(option); // 当我们浏览器缩放的时候，图表也等比例缩放 window.addEventListener(&quot;resize&quot;, function() &#123; // 让我们的图表调用 resize这个方法 myChart.resize(); &#125;);&#125;)(); 22-销售进度 (quarter) -饼状图实现步骤： 寻找官方的类似示例，给予分析,引入到HTML页面中 按照需求来定制它。 第一步：参考官方示例：https://www.echartsjs.com/examples/zh/editor.html?c=pie-doughnut 12345678910111213141516171819202122232425// 销售模块 饼形图 半圆形 设置方式(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.gauge&quot;)); // 2. 指定数据和配置 var option = &#123; series: [ &#123; name: &quot;销售进度&quot;, type: &quot;pie&quot;, radius: [&quot;50%&quot;, &quot;70%&quot;], //是否启用防止标签重叠策略 // avoidLabelOverlap: false, labelLine: &#123; normal: &#123; show: false &#125; &#125;, data: [&#123; value: 100 &#125;, &#123; value: 100 &#125;, &#123; value: 200 &#125;] &#125; ] &#125;; // 3. 把数据和配置给实例对象 myChart.setOption(option);&#125;)(); 第二步：进行定制 需求1：改成半圆，图表大一些，让50%文字在中心。 1234567891011121314151617181920212223var option = &#123; series: [ &#123; type: &#x27;pie&#x27;, // 放大图形 radius: [&#x27;130%&#x27;, &#x27;150%&#x27;], // 移动下位置 套住50%文字 center: [&#x27;48%&#x27;, &#x27;80%&#x27;], label: &#123; normal: &#123; show: false &#125; &#125;, // 起始角度，支持范围[0, 360] startAngle: 180, data: [ &#123; value: 100 &#125;, // 不需要名称 &#123; value: 100,&#125;, // 不需要名称 &#123; value: 200, itemStyle: &#123; color: &#x27;transparent&#x27; &#125; &#125; // 透明隐藏第三块区域 ] &#125; ]&#125; 需求2：鼠标经过无需变大，修改第一段颜色渐变#00c9e0-&gt;#005fc1，修改第二段颜色#12274d。 123456789101112131415161718192021// 鼠标经过不变大hoverOffset: 0, data: [ &#123; value: 100, itemStyle: &#123; // 颜色渐变#00c9e0-&gt;#005fc1 color: new echarts.graphic.LinearGradient( // (x1,y2) 点到点 (x2,y2) 之间进行渐变 0, 0, 0, 1, [ &#123; offset: 0, color: &quot;#00c9e0&quot; &#125;, // 0 起始颜色 &#123; offset: 1, color: &quot;#005fc1&quot; &#125; // 1 结束颜色 ] ) &#125; &#125;, &#123; value: 100, itemStyle: &#123; color: &#x27;#12274d&#x27; &#125; &#125;, // 颜色#12274d 23-热销排行（top）-布局html结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- 排行榜 --&gt;&lt;div class=&quot;top panel&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;all&quot;&gt; &lt;h3&gt;全国热榜&lt;/h3&gt; &lt;ul&gt; &lt;li&gt; &lt;i class=&quot;icon-cup1&quot; style=&quot;color: #d93f36;&quot;&gt;&lt;/i&gt; 可爱多 &lt;/li&gt; &lt;li&gt; &lt;i class=&quot;icon-cup2&quot; style=&quot;color: #68d8fe;&quot;&gt;&lt;/i&gt; 娃哈啥 &lt;/li&gt; &lt;li&gt; &lt;i class=&quot;icon-cup3&quot; style=&quot;color: #4c9bfd;&quot;&gt;&lt;/i&gt; 喜之郎 &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;province&quot;&gt; &lt;h3&gt;各省热销 &lt;i class=&quot;date&quot;&gt;// 近30日 //&lt;/i&gt;&lt;/h3&gt; &lt;div class=&quot;data&quot;&gt; &lt;ul class=&quot;sup&quot;&gt; &lt;li&gt; &lt;span&gt;北京&lt;/span&gt; &lt;span&gt;25,179 &lt;s class=&quot;icon-up&quot;&gt;&lt;/s&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;河北&lt;/span&gt; &lt;span&gt;23,252 &lt;s class=&quot;icon-down&quot;&gt;&lt;/s&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;上海&lt;/span&gt; &lt;span&gt;20,760 &lt;s class=&quot;icon-up&quot;&gt;&lt;/s&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;江苏&lt;/span&gt; &lt;span&gt;23,252 &lt;s class=&quot;icon-down&quot;&gt;&lt;/s&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;山东&lt;/span&gt; &lt;span&gt;20,760 &lt;s class=&quot;icon-up&quot;&gt;&lt;/s&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;!-- &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt; &lt;s class=&quot;icon-up&quot;&gt;&lt;/s&gt;&lt;/span&gt;&lt;/li&gt; --&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* 排行榜 */.top &#123; height: 3.5rem;&#125;.top .inner &#123; display: flex;&#125;.top .all &#123; display: flex; flex-direction: column; width: 2.1rem; color: #4c9bfd; font-size: 0.175rem; vertical-align: middle;&#125;.top .all ul &#123; padding-left: 0.15rem; margin-top: 0.15rem; flex: 1; display: flex; flex-direction: column; justify-content: space-around;&#125;.top .all li &#123; overflow: hidden;&#125;.top .all [class^=&quot;icon-&quot;] &#123; font-size: 0.45rem; vertical-align: middle; margin-right: 0.15rem;&#125;.top .province &#123; flex: 1; display: flex; flex-direction: column; color: #fff;&#125;.top .province i &#123; padding: 0 0.15rem; margin-top: 0.0625rem; float: right; font-style: normal; font-size: 0.175rem; color: #0bace6;&#125;.top .province s &#123; display: inline-block; transform: scale(0.8); text-decoration: none;&#125;.top .province .icon-up &#123; color: #dc3c33;&#125;.top .province .icon-down &#123; color: #36be90;&#125;.top .province .data &#123; flex: 1; display: flex; margin-top: 0.175rem;&#125;.top .province ul &#123; flex: 1; line-height: 1; margin-bottom: 0.175rem;&#125;.top .province ul li &#123; display: flex; justify-content: space-between;&#125;.top .province ul span &#123; display: block; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125;.top .province ul.sup &#123; font-size: 0.175rem;&#125;.top .province ul.sup li &#123; color: #4995f4; padding: 0.15rem;&#125;.top .province ul.sup li.active &#123; color: #a3c6f2; background-color: rgba(10, 67, 188, 0.2);&#125;.top .province ul.sub &#123; display: flex; flex-direction: column; justify-content: space-around; font-size: 0.15rem; background-color: rgba(10, 67, 188, 0.2);&#125;.top .province ul.sub li &#123; color: #52ffff; padding: 0.125rem 0.175rem;&#125;.clock &#123; position: absolute; top: -0.45rem; right: 0.5rem; font-size: 0.25rem; color: #0bace6;&#125;.clock i &#123; margin-right: 5px; font-size: 0.25rem;&#125;@media screen and (max-width: 1600px) &#123; .top span &#123; transform: scale(0.9); &#125; .top .province ul.sup li &#123; padding: 0.125rem 0.15rem; &#125; .top .province ul.sub li &#123; padding: 0.0625rem 0.15rem; &#125; .quarter span &#123; transform: scale(0.9); &#125;&#125; 23-热销排行（top）-效果实现思路： 准备后台返回的真实数据 利用数据渲染各省热销模块 sup 模块 (拼接html格式字符串，进行渲染) 当鼠标进入 tab 的时候 激活当前的tab样式，删除其他tab的样式 渲染各省热销 sub 模块 (拼接html格式字符串，进行渲染) 默认激活第一个tab的效果 开启定时器，按依次切换 预备知识： 扩展知识：ES6模版字符 12345678910// 模版字符var star = &#123; name: &quot;刘德华&quot;, age: 18 &#125;;// 以前的写法 拼接的时候引号很容易出问题console.log(&quot;我的名字是&quot; + star.name + &quot;我的年龄是&quot; + star.age);// ES6 模板字符写法console.log(`我的名字是$&#123;star.name&#125;我的年龄是$&#123;star.age&#125;`);console.log(`&lt;span&gt;$&#123;star.name&#125;&lt;/span&gt;&lt;span&gt;$&#123;star.age&#125;&lt;/span&gt;`); 开始实现： 第一步：得到后台数据（实际开发中，这个数据通过ajax请求获得） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var hotData = [ &#123; city: &#x27;北京&#x27;, // 城市 sales: &#x27;25, 179&#x27;, // 销售额 flag: true, // 上升还是下降 brands: [ // 品牌种类数据 &#123; name: &#x27;可爱多&#x27;, num: &#x27;9,086&#x27;, flag: true &#125;, &#123; name: &#x27;娃哈哈&#x27;, num: &#x27;8,341&#x27;, flag: true &#125;, &#123; name: &#x27;喜之郎&#x27;, num: &#x27;7,407&#x27;, flag: false &#125;, &#123; name: &#x27;八喜&#x27;, num: &#x27;6,080&#x27;, flag: false &#125;, &#123; name: &#x27;小洋人&#x27;, num: &#x27;6,724&#x27;, flag: false &#125;, &#123; name: &#x27;好多鱼&#x27;, num: &#x27;2,170&#x27;, flag: true &#125;, ] &#125;, &#123; city: &#x27;河北&#x27;, sales: &#x27;23,252&#x27;, flag: false, brands: [ &#123; name: &#x27;可爱多&#x27;, num: &#x27;3,457&#x27;, flag: false &#125;, &#123; name: &#x27;娃哈哈&#x27;, num: &#x27;2,124&#x27;, flag: true &#125;, &#123; name: &#x27;喜之郎&#x27;, num: &#x27;8,907&#x27;, flag: false &#125;, &#123; name: &#x27;八喜&#x27;, num: &#x27;6,080&#x27;, flag: true &#125;, &#123; name: &#x27;小洋人&#x27;, num: &#x27;1,724&#x27;, flag: false &#125;, &#123; name: &#x27;好多鱼&#x27;, num: &#x27;1,170&#x27;, flag: false &#125;, ] &#125;, &#123; city: &#x27;上海&#x27;, sales: &#x27;20,760&#x27;, flag: true, brands: [ &#123; name: &#x27;可爱多&#x27;, num: &#x27;2,345&#x27;, flag: true &#125;, &#123; name: &#x27;娃哈哈&#x27;, num: &#x27;7,109&#x27;, flag: true &#125;, &#123; name: &#x27;喜之郎&#x27;, num: &#x27;3,701&#x27;, flag: false &#125;, &#123; name: &#x27;八喜&#x27;, num: &#x27;6,080&#x27;, flag: false &#125;, &#123; name: &#x27;小洋人&#x27;, num: &#x27;2,724&#x27;, flag: false &#125;, &#123; name: &#x27;好多鱼&#x27;, num: &#x27;2,998&#x27;, flag: true &#125;, ] &#125;, &#123; city: &#x27;江苏&#x27;, sales: &#x27;23,252&#x27;, flag: false, brands: [ &#123; name: &#x27;可爱多&#x27;, num: &#x27;2,156&#x27;, flag: false &#125;, &#123; name: &#x27;娃哈哈&#x27;, num: &#x27;2,456&#x27;, flag: true &#125;, &#123; name: &#x27;喜之郎&#x27;, num: &#x27;9,737&#x27;, flag: true &#125;, &#123; name: &#x27;八喜&#x27;, num: &#x27;2,080&#x27;, flag: true &#125;, &#123; name: &#x27;小洋人&#x27;, num: &#x27;8,724&#x27;, flag: true &#125;, &#123; name: &#x27;好多鱼&#x27;, num: &#x27;1,770&#x27;, flag: false &#125;, ] &#125;, &#123; city: &#x27;山东&#x27;, sales: &#x27;20,760&#x27;, flag: true, brands: [ &#123; name: &#x27;可爱多&#x27;, num: &#x27;9,567&#x27;, flag: true &#125;, &#123; name: &#x27;娃哈哈&#x27;, num: &#x27;2,345&#x27;, flag: false &#125;, &#123; name: &#x27;喜之郎&#x27;, num: &#x27;9,037&#x27;, flag: false &#125;, &#123; name: &#x27;八喜&#x27;, num: &#x27;1,080&#x27;, flag: true &#125;, &#123; name: &#x27;小洋人&#x27;, num: &#x27;4,724&#x27;, flag: false &#125;, &#123; name: &#x27;好多鱼&#x27;, num: &#x27;9,999&#x27;, flag: true &#125;, ] &#125;] 第二步：根据数据渲染各省热销 sup 模块内容 删掉原先自带小li 遍历数据 $.each() 拼接字符串把数据渲染到 li 的span 里面 追加给 .sup 盒子 1234567var supHTML = &quot;&quot;; $.each(hotData, function(index, item) &#123; // console.log(item); supHTML += `&lt;li&gt;&lt;span&gt;$&#123;item.city&#125;&lt;/span&gt;&lt;span&gt; $&#123;item.sales&#125; &lt;s class= $&#123;item.flag ? &quot;icon-up&quot; : &quot;icon-down&quot;&#125;&gt;&lt;/s&gt;&lt;/span&gt;&lt;/li&gt;`; &#125;); $(&quot;.sup&quot;).html(supHTML); 第三步：当数据进入 tab 的时候 激活当前的tab样式，删除其他tab的样式 渲染各省热销 sub 模块 注意鼠标进入tab， 只遍历 当前索引号对应的 城市对象里面的 brands 拼接html格式字符串，进行渲染 1 第四步：默认激活第一个tab 1234// 所有的LIvar $lis = $(&#x27;.province .sup li&#x27;)// 第一个默认激活$lis.eq(0).mouseenter() 第五步：开启定时切换 定时器里面 mouseenter 冲突问题的解决方案 定时器里面不加mousenter 事件，而是直接重新渲染数据就可以(执行鼠标经过事件里面的代码) 最好把渲染的代码封装到函数里面 123456789101112131415161718192021222324var index = 0; var timer = setInterval(function() &#123; index++; if (index &gt;= 5) index = 0; // lis.eq(index).mouseenter(); render(lis.eq(index)); &#125;, 2000); $(&quot;.province .sup&quot;).hover( // 鼠标经过事件 function() &#123; clearInterval(timer); &#125;, // 鼠标离开事件 function() &#123; clearInterval(timer); timer = setInterval(function() &#123; index++; if (index &gt;= 5) index = 0; // lis.eq(index).mouseenter(); render(lis.eq(index)); &#125;, 2000); &#125; ); 24-Echarts-社区介绍 社区就是一些，活跃的echart使用者，交流和贡献定制好的图表的地方。 在这里可以找到一些基于echart的高度定制好的图表，相当于基于jquery开发的插件，这里是基于echarts开发的第三方的图表。 25-Echarts-map使用（扩展）参考社区的例子：https://gallery.echartsjs.com/editor.html?c=x0-ExSkZDM (模拟飞机航线) 实现步骤： 第一需要下载china.js提供中国地图的js文件 第二个因为里面代码比较多，我们新建一个新的js文件 myMap.js 引入 使用社区提供的配置即可。 需要修改： 去掉图例组件和标题组件 去掉背景颜色 修改地图省份背景 #142957 地图放大通过 zoom 设置为1.2即可 12345678910111213141516171819geo: &#123; map: &#x27;china&#x27;, zoom: 1.2, label: &#123; emphasis: &#123; show: false &#125; &#125;, roam: false, itemStyle: &#123; normal: &#123; areaColor: &#x27;#142957&#x27;, borderColor: &#x27;#0692a4&#x27; &#125;, emphasis: &#123; areaColor: &#x27;#0b1c2d&#x27; &#125; &#125;&#125;, AJAX 原生AJAXGET获取1234567891011121314151617// // 1. 创建 XHR 对象// // 2. 调用 open 函数// // 3. 调用 send 函数// // 4. 监听 onreadystatechange 事件// // 判断// if (xhr.Status === 200 &amp;&amp; readyState === 4) &#123;// console.log(xhr.responseText)// &#125;// &#125; const xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks?id=2&#x27;)//?键=值&amp;键=值 =&gt;查询字符串xhr.send()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;//固定判断条件 console.log(xhr.responseText) &#125;&#125; POST请求123456789const xhr = new XMLHttpRequest() xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;) xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)//固定格式 xhr.send(&#x27;bookname=小雪人时&amp;author=阿萨&amp;publisher=甜虾&#x27;)//查询字符串 xhr.onreadystatechange = function () &#123; if (xhr.status === 200 &amp;&amp; xhr.readyState === 4) &#123; console.log(xhr.responseText) &#125; &#125; JOSN 本质是字符串，用于处理数据 序列化：数据对象转为自字符串，JOSN.stringIfy() 反序列化：字符串转为数据对象，JOSN.parse() 自己封装ajax函数 12345678910111213141516171819202122232425262728293031323334353637// 封装函数 ，处理从服务器获取的数据中的 data 对象function resolveData(data) &#123; const arr = [] for (const k in data) &#123; let str = `$&#123;k&#125;=$&#123;data[k]&#125;`//取得对象中的每一组 键 值，转为 键=值 的格式 arr.push(str)//追加进对象中 &#125; return arr.join(&#x27;&amp;&#x27;)&#125;// 封装获取数据函数，itheimafunction itheima(options) &#123;//options形参， // console.log(options)//传入的实参 const xhr = new XMLHttpRequest() // 调用函数，遍历传参进来对象的data const str = resolveData(options.data) //未确定是 GET 还是 POST 先不写 // xhr.open() // xhr.setRequestHeader() // xhr.send() // 使用 if else 来判定method if (options.method.toUpperCase() === &#x27;GET&#x27;) &#123;//toUpperCase()方法将调用该方法的字符串转为大写形式并返回 xhr.open(options.method, `$&#123;options.url&#125;?$&#123;str&#125;`)//键值 查询字符串 xhr.send() &#125; else if (options.method.toUpperCase() === &#x27;POST&#x27;) &#123; xhr.open(options.method, options.url) xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) xhr.send(str) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; const re = JSON.parse(xhr.responseText)//获取响应数据，并转化为JS对象 // options.success,传参进来对象中的 options中的success（）函数 // 服务器成功响应后，调用success函数 options.success(re)//success()回调函数用来承载服务器反出的数据 re实参传给形参res &#125; &#125;&#125; Ajaxday0101. URL地址的组成部分 客户端与服务器之间的通信协议 存有该资源的服务器名称 资源在服务器上具体的存放位置 02. 客户端与服务器的通信过程 客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤 03. 网页中如何请求数据 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象 最简单的用法 const xhr &#x3D; new XMLHttpRequest() 04. 资源的请求方式 get 请求通常用于获取服务端资源（向服务器要资源） post 请求通常用于向服务器提交数据（往服务器发送资源） 05. Ajax概念 Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML） 在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax Ajax能让我们轻松实现网页与服务器之间的数据交互 06. jQuery中的Ajax 浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数 jQuery 中发起 Ajax 请求最常用的三个方法如下： $.get() $.post() $.ajax() 07. $.get()函数的语法1$.get(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 12345// $.get()发起不带参数的请求// 获取到所有的$.get(&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, function(res) &#123; console.log(res) // 这里的 res 是服务器返回的数据&#125;) 12345// $.get()发起带参数的请求// 获取id为1的$.get(&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, &#123; id: 1 &#125;, function(res) &#123; console.log(res)&#125;) 08. $.post()函数的语法1$.post(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 1234567$.post( &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;, // 请求的URL地址 &#123; bookname: &#x27;水浒传&#x27;, author: &#x27;施耐庵&#x27;, publisher: &#x27;上海图书出版社&#x27; &#125;, // 提交的数据 function(res) &#123; // 回调函数 console.log(res) &#125;) 09. $.ajax()函数的语法1234567// 只有一个参数 是对象$.ajax(&#123; type: &#x27;&#x27;, // 请求的方式，例如 GET 或 POST url: &#x27;&#x27;, // 请求的 URL 地址 data: &#123; &#125;,// 这次请求要携带的数据 success: function(res) &#123; &#125; // 请求成功之后的回调函数&#125;) 123456789// 使用$.ajax()发起GET请求$.ajax(&#123; type: &#x27;GET&#x27;, // 请求的方式 method:&#x27;GET&#x27; url: &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, // 请求的 URL 地址 data: &#123; id: 1 &#125;,// 这次请求要携带的数据 success: function(res) &#123; // 请求成功之后的回调函数 console.log(res) &#125;&#125;) 12345678910111213// 使用$.ajax()发起POST请求$.ajax(&#123; type: &#x27;POST&#x27;, // 请求的方式 url: &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;, // 请求的 URL 地址 data: &#123; // 要提交给服务器的数据 bookname: &#x27;水浒传&#x27;, author: &#x27;施耐庵&#x27;, publisher: &#x27;上海图书出版社&#x27; &#125;, success: function(res) &#123; // 请求成功之后的回调函数 console.log(res) &#125;&#125;) 10. 接口 概念: 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）, 同时，每个接口必须有请求方式 通过GET方式请求接口的过程 (post类似) 11. 接口测试工具PostMan 使用PostMan测试GET接口 选择请求的方式 填写请求的URL地址 填写请求的参数 点击Send 按钮发起GET 请求 查看服务器响应的结果 使用PostMan测试POST接口 选择请求的方式 填写请求的URL地址 选择Body 面板并勾选数据格式 填写要发送到服务器的数据 点击Send 按钮发起POST请求 查看服务器响应的结果 12. 接口文档 是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明 接口文档的组成部分: 接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等 接口URL：接口的调用地址 调用方式：接口的调用方式，如 GET 或 POST 参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容 响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容 返回示例（可选）：通过对象的形式，例举服务器返回数据的结构 day0201. form表单 表单作用：收集表单数据，从而提交给服务器 组成：表单标签form、表单域、提交按钮 其中表单域包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等 02. form表单属性表单属性: 用来规定如何把采集到的数据发送到服务器 属性 值 描述 action URL地址 规定当提交表单时，向何处发送表单数据 method get或post 规定以何种方式把表单数据提交到action URL enctype application&#x2F;x-www-form-urlencoded multipart&#x2F;form-datatext&#x2F;plain 规定在发送表单数据之前如何对其进行编码 target _ blank _ self _ parent _top framename 规定在何处打开 action URL action action 属性用来规定当提交表单时，向何处发送表单数据 action 属性的值是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。当表单在未指定 action 属性值，action 的默认值为当前页面的 URL 地址 注意：当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址 target target 属性用来规定在何处打开 action URL _blank 在新窗口中打开 _self 默认 在相同的框架中打开 _parent 在父框架集中打开（很少用） _top 在整个窗口中打开（很少用） framename 在指定的框架中打开（很少用） method method 属性用来规定以何种方式把表单数据提交到 action URL 它的可选值有两个，分别是 get 和 post 默认为 get，表示通过URL地址的形式，把表单数据提交到 action URL 提交的数据的格式：url地址?键&#x3D;值&amp;键&#x3D;值?键&#x3D;值&amp;键&#x3D;值 是查询字符串 指要提交的数据 在实际开发中， 表单的 post 提交方式用的最多 get post 区别 get 方式适合用来提交少量的、简单的数据 post 方式适合用来提交大量的、复杂的、或包含文件上传的数据, 数据大小不受限制 get 提交数据的时候，把数据放到url地址后面 post 提交数据的时候，没有数据放到url地址后面，放到请求体里面了 enctype enctype 属性用来规定在发送表单数据之前如何对数据进行编码 application&#x2F;x-www-form-urlencoded 在发送前编码所有字符（默认） multipart&#x2F;form-data 不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值 text&#x2F;plain 空格转换为 “+” 加号，但不对特殊字符编码。（很少用 03. 表单的同步提交 概念: 通过点击 submit 按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交 缺点: 网页发生了跳转,用户体验差 状态 + 数据丢失了 解决：表单只收集数据，ajax将数据提交给服务器 04. 通过Ajax提交表单数据 步骤: 给表单form 注册submit事件 阻止其默认行为 e.preventDefault() 收集表单数据， jQ提供了 serialize(), 必须要有name属性 ajax去发送请求 05. serialize()函数快速获取表单中的数据 1$(selector).serialize() // 必须要有name属性 1234567891011&lt;form id=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt; $(&#x27;#form1&#x27;).serialize() // 调用的结果：键=值&amp;键=值 // username=用户名的值&amp;password=密码的值&lt;/script&gt; day0301. 使用xhr发起GET请求XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源 1234567891011121314// 1. 创建 xhr 对象var xhr = new XMLHttpRequest()// 2. 调用 open 函数，指定 请求方式 与 URL地址xhr.open(&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;) // 3. 调用 send 函数，发起 Ajax 请求xhr.send()// 4. 监听 onreadystatechange 事件xhr.onreadystatechange = function() &#123; // 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; // 4.2 打印服务器响应回来的数据 console.log(xhr.responseText) &#125;&#125; 1234// 使用xhr发起带参数的GET请求// 在调用 xhr.open 期间，为 URL 地址指定参数即可// 这种在 URL 地址后面拼接的参数，叫做查询字符串xhr.open(&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&#x27;) XMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态 值 状态 描述 0 UNSENT XMLHttpRequest 对象已被创建，但尚未调用 open方法 1 OPENED open() 方法已经被调用 2 HEADERS_RECEIVED send() 方法已经被调用，响应头也已经被接收 3 LOADING 数据接收中，此时 response 属性中已经包含部分数据 4 DONE Ajax 请求完成，这意味着数据传输已经彻底完成或失败 02. 使用xhr发起POST请求1234567891011121314// 1. 创建 xhr 对象var xhr = new XMLHttpRequest()// 2. 调用 open()xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;)// 3. 设置 Content-Type 属性（固定写法）xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)// 4. 调用 send()，同时将数据以查询字符串的形式，提交给服务器xhr.send(&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=天津图书出版社&#x27;)// 5. 监听 onreadystatechange 事件xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125; 03. 查询字符串 定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量） 格式：将英文的 ? 放在URL 的末尾，然后再加上 参数＝值 ，想加上多个参数的话，使用 &amp; 符号进行分隔 GET请求携带参数的本质: 将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的 1234567$.get(&#x27;url&#x27;, &#123;name: &#x27;zs&#x27;, age: 20&#125;, function() &#123;&#125;)// 等价于$.get(&#x27;url?name=zs&amp;age=20&#x27;, function() &#123;&#125;)$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;url&#x27;, data: &#123;name: &#x27;zs&#x27;, age: 20&#125;, success: function() &#123;&#125; &#125;)// 等价于$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;url?name=zs&amp;age=20&#x27;, success: function() &#123;&#125; &#125;) 04. URL编码与解码URL编码原则：使用英文字符去表示非英文字符 encodeURI() 编码的函数 decodeURI() 解码的函数 1234encodeURI(&#x27;黑马程序员&#x27;)// 输出字符串 %E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98decodeURI(&#x27;%E9%BB%91%E9%A9%AC&#x27;)// 输出字符串 黑马 05. 数据交换格式数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式 (XML 和 JSON) JSON: 本质：字符串 字符串表示JS数组和对象 数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型 规律： JSON 数据中不能出现 undefined 和 函数 键必须是双引号（不能没有双引号，不能使用单引号） 值如果是字符串的话，也必须使用双引号 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 2个方法 JSON.parse() 把JSON字符串转成 js对象 反序列化 JSON.stringify() 把 js对象转成 JSON字符串 序列化 06. XMLHttpRequest Level2的新特性 旧版XMLHttpRequest的缺点 只支持文本数据的传输，无法用来读取和上传文件 传送和接收数据时，没有进度信息，只能提示有没有完成 XMLHttpRequest Level2的新功能 可以设置 HTTP 请求的时限 可以使用 FormData 对象管理表单数据 可以上传文件 可以获得数据传输的进度信息 07. 设置HTTP请求时限123xhr.timeout = 3000 // 将最长等待时间设为 3000 毫秒 // 过了这个时限，就自动停止HTTP请求 1234// timeout 事件，用来指定回调函数xhr.ontimeout = function()&#123; alert(&#x27;请求超时！&#x27;)&#125; 08. FormData对象管理表单数据 模拟表单操作 1234567891011// 1. 新建 FormData 对象const fd = new FormData()// 2. 为 FormData 添加表单项fd.append(&#x27;uname&#x27;, &#x27;zs&#x27;)fd.append(&#x27;upwd&#x27;, &#x27;123456&#x27;)// 3. 创建 XHR 对象const xhr = new XMLHttpRequest()// 4. 指定请求类型与URL地址xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/formdata&#x27;)// 5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样xhr.send(fd) 获取网页表单的值 123456789101112// 获取表单元素const form = document.querySelector(&#x27;#form1&#x27;)// 监听表单元素的 submit 事件form.addEventListener(&#x27;submit&#x27;, function(e) &#123; e.preventDefault() // 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中 const fd = new FormData(form) const xhr = new XMLHttpRequest() xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/formdata&#x27;) xhr.send(fd) xhr.onreadystatechange = function() &#123;&#125;&#125;) 09. 上传文件 步骤: 定义 UI 结构 验证是否选择了文件 向 FormData 中追加文件 使用 xhr 发起上传文件的请求 监听 onreadystatechange 事件 12345&lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt; const file = document.querySelector(&#x27;#file&#x27;)file.files.length // 判断是否选择文件// files是属性 以对象形式存储数据 10. 显示文件上传进度 xhr.upload.onprogress 事件，可以获取到文件的上传进度 : 1234567891011// 创建 XHR 对象const xhr = new XMLHttpRequest()// 监听 xhr.upload 的 onprogress 事件xhr.upload.onprogress = function(e) &#123; // e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度 if (e.lengthComputable) &#123; // e.loaded 已传输的字节 // e.total 需传输的总字节 const percentComplete = Math.ceil((e.loaded / e.total) * 100) &#125;&#125; xhr.upload.onload , 监听上传完成的事件 1xhr.upload.onload = function() &#123;&#125; 11. jQuery发起上传文件的请求123456789101112$.ajax(&#123; method: &#x27;POST&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;, data: fd, // 不修改 Content-Type 属性，使用 FormData 默认的 Content-Type 值 contentType: false, // 不对 FormData 中的数据进行 url 编码，而是将 FormData 数据原样发送到服务器 processData: false, success: function(res) &#123; console.log(res) &#125;&#125;) 12. ajaxStart(callback) Ajax 请求开始时，执行 ajaxStart 函数 $(document).ajaxStart() 函数会监听当前文档内所有的 Ajax 请求 1234// 在 ajaxStart 的 callback 中显示 loading 效果$(document).ajaxStart(function() &#123; $(&#x27;#loading&#x27;).show()&#125;) 13. ajaxStop(callback) Ajax 请求结束时，执行 ajaxStop 函数 1234// 在 ajaxStop 的 callback 中隐藏 loading 效果$(document).ajaxStop(function() &#123; $(&#x27;#loading&#x27;).hide()&#125;) 14. axios Axios 是专注于网络数据请求的库 相比于原生的 XMLHttpRequest 对象，axios 简单易用 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。 15. axios发起GET请求1axios.get(&#x27;url&#x27;, &#123; params: &#123; /*参数*/ &#125; &#125;).then(callback) 12345678910// 请求的 URL 地址const url = &#x27;http://www.liulongbin.top:3006/api/get&#x27;// 请求的参数对象const paramsObj = &#123; name: &#x27;zs&#x27;, age: 20 &#125;// 调用 axios.get() 发起 GET 请求axios.get(url, &#123; params: paramsObj &#125;).then(function(res) &#123; // res.data 是服务器返回的数据 const result = res.data console.log(res)&#125;) 16. axios发起POST请求1axios.post(&#x27;url&#x27;, &#123; /*参数*/ &#125;).then(callback) 12345678910// 请求的 URL 地址const url = &#x27;http://www.liulongbin.top:3006/api/post&#x27;// 要提交到服务器的数据const dataObj = &#123; location: &#x27;北京&#x27;, address: &#x27;顺义&#x27; &#125;// 调用 axios.post() 发起 POST 请求axios.post(url, dataObj).then(function(res) &#123; // res.data 是服务器返回的数据 const result = res.data console.log(result)&#125;) 17. 直接使用axios发起请求123456axios(&#123; method: &#x27;请求类型&#x27;, url: &#x27;请求的URL地址&#x27;, data: &#123; /* POST数据 */ &#125;, params: &#123; /* GET参数 */ &#125;&#125;) .then(callback) 1234567891011// 发起GET请求axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/get&#x27;, params: &#123; // GET 参数要通过 params 属性提供 name: &#x27;zs&#x27;, age: 20 &#125;&#125;).then(function(res) &#123; console.log(res.data)&#125;) 1234567891011// 发起POST请求axios(&#123; method: &#x27;POST&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/post&#x27;, data: &#123; // POST 数据要通过 data 属性提供 bookname: &#x27;程序员的自我修养&#x27;, price: 666 &#125;&#125;).then(function(res) &#123; console.log(res.data)&#125;) git sidebar: autopermalink: &#x2F;git_base Gitgit基础入门 Git是一款免费、开源的分布式 版本控制系统 ，用于敏捷高效地处理任何或小或大的项目。 思考：为什么要学习git 思考：git的好处是什么 git的安装下载地址 注意：不要安装在中文目录 安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。 说明：Mac的安装可以查看官网说明在 macOS 上安装 在终端里尝试首次运行 git 命令即可。如果没有安装过git，将会提示你安装。 git三个区 要对某个项目使用git进行管理，需要使用git init命令初始化git仓库 git init会在当前目录生成一个隐藏文件夹 .git 不要去修改这个文件夹下的任意东西。 git仓库会分成三个区 工作区：我们书写代码的地方，工作的目录就叫工作区。 暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。 仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。 git基本命令git init作用：初始化git仓库，想要使用git对某个项目进行管理，需要git init进行初始化 12# 初始化仓库， 在当前目录下生成一个隐藏文件夹.gitgit init git add作用：将文件由 工作区 添加到 暂存区，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。 命令：git add 文件名/目录名 123456789# 将index.html添加到暂存区git add index.html# 将css目录下所有的文件添加到暂存区git add css# 添加当前目录下所有的文件git add .git add --all git commit作用：将文件由 暂存区 添加到 仓库区，生成版本号（存档） 12345# 将文件从暂存区提交到仓库git commit -m &quot;提交说明&quot;# 如果不写提交说明，会进入vi编辑器，没有写提交说明，是提交不成功的。 需要知道如何退出 输入 :q!git commit git config配置如果是第一次提交，需要配置提交者信息 这两条配置是很重要的，每次提交 git 代码都会引用这两条信息，记录了谁提交了代码，会永久的记录在历史记录中。 12345678# 使用 --global 参数，配置全局的用户名和邮箱，只需要配置一次即可git config --global user.name &quot;web189&quot;git config --global user.email &quot;isdemo@qq.com&quot;# 可以再次通过运行命令来修改它们。# 查看配置信息git config --list git status作用：查看文件的状态 命令：git status 红色表示工作区中的文件需要提交 绿色表示暂存区中的文件需要提交 git log作用：查看提交日志 git log 查看提交的日志 git重置git reset作用：版本回退，将代码恢复到已经提交的某一个版本中。 git reset --hard 版本号 将代码回退到某个指定的版本(版本号只要有前几位即可) 当使用了git reset命令后，版本会回退，使用git log只能看到当前版本之前的信息。git reflog 查看仓库中所有的提交日志信息 git log –oneline 可以一行输出提交日志信息 git忽视文件 在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules文件夹等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。 在仓库的根目录创建一个.gitignore的文件，文件名是固定的。 将不需要被git管理的文件路径添加到.gitignore中 1234567891011# 忽视idea.txt文件idea.txt# 忽视css文件夹css/# 忽视css下的index.js文件css/index.js# 忽视css下的所有的js文件css/*.js 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 复习12345678910111213git init 初始化一个git仓库 让git管理项目git add . 工作区的代码文件添加到暂存区git commit -m &#x27;提交说明信息&#x27;git status 查看文件状态git log 查看提交日志 git reflog 更全git reset --hard 版本号git 忽视文件 文件.gitignore git分支操作分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 为什么要有分支？ 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。 git分支命令创建分支 git branch 分支名称创建分支，分支中的代码，在创建时与当前分支的内容完全相同。 git在第一次提交时，就有了一个叫master的主分支。 git branch dev，创建了一个叫做dev的分支 查看分支 git branch可以查看所有的分支 在当前分支的前面会有一个* 切换分支 git checkout 分支名称切换分支 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。 提交代码时，会生产版本号 创建并切换分支 git checkout -b 分支名称 创建并切换分支 删除分支 git branch -d 分支名称 可以删除分支 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。 注意：master分支是可以删除的，但是不推荐那么做。 合并分支 git merge 分支名称 将其他分支的内容合并到当前分支。 在master分支中执行git merge dev 将dev分支中的代码合并到master分支 分支合并 git合并冲突 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。 git远程仓库 以后公司会有一台服务器作为公司的远程仓库。 github与gitgit与github没有直接的关系。 git是一个版本控制工具。 github是一个代码托管平台，开源社区，是git的一个远程代码仓库。 gitHub是一个托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 创建git项目时，不能有中文。 github官网 开源中国-git git clone 作用：克隆远程仓库的代码到本地 git clone [远程仓库地址] git克隆默认会使用远程仓库的项目名字，也可以自己指定。 需要是使用以下命令：git clone [远程仓库地址] [本地项目名] git push 作用：将本地仓库中代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 git pull 作用：将远程的代码下载到本地 通常在push前，需要先pull一次。 12# 获取远程仓库的更新，并且与本地的分支进行合并git pull git remote每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名 1234567891011# 给远程仓库设置一个别名git remote add 仓库别名 仓库地址git remote add demo 仓库地址# 删除demo这个别名git remote remove demo# 通过git clone的仓库默认有一个origin的别名# 查看当前仓库中的所有别名git remote -v SSH免密码登陆git支持多种数据传输协议： https协议：https://github.com/webman158/demo76.git 需要输入用户名和密码 ssh协议：git@github.com:webman158/demo76.git 可以配置免密码登录 每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码 SSH免密码登录配置注意：这些命令需要在bash中敲 1 创建SSH Key：ssh-keygen -t rsa 敲3次回车 2 在文件路径 C:\\用户\\当前用户名\\ 找到 .ssh 文件夹 3 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 4 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 5 粘贴 公钥 id_rsa.pub 内容到对应文本框中 5 在github中新建仓库或者使用现在仓库，拿到git@github.com:用户名/仓库名.git 6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了 vue基操 定义：vue是渐进式js框架！现下载yarn（推荐）或者npm，搭配环境 下载地址: https://yarn.bootcss.com/docs/install/#windows-stable mac如果没安装过homeBrew先运行这个命令 1/usr/bin/ruby -e &quot;$(curl -fsSL http://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 上面命令不行: 试试这个: curl -o- -L https://yarnpkg.com/install.sh | bash (直接安装yarn) 安装vue及脚手架 命令：yarn global add @vue&#x2F;cli vue -V 查看版本 yarn使用设置淘宝镜像 123查询当前配置的镜像 npm get registry设置成淘宝镜像 npm config set registry http://registry.npm.taobao.org/换成原来的 npm config set registry https://registry.npmjs.org/ 123查询当前配置的镜像 yarn config get registry // 默认：https://registry.yarnpkg.com设置成淘宝镜像 yarn config set registry http://registry.npm.taobao.org/换成原来的 yarn config set registry http://registry.npmjs.org/ 12345678910111213141516171819202122# 1. 初始化, 得到package.json文件(终端路径所在文件夹下)yarn init# 2. 添加依赖(下包)# 命令: yarn add [package]# 命令: yarn add [package]@[version]yarn add jqueryyarn add jquery@3.5.1# 3. 移除包# 命令: yarn remove [package]yarn remove jquery # 4. 安装项目全部依赖(一般拿到别人的项目时, 缺少node_modules) yarn# 会根据当前项目package.json记录的包名和版本, 全部下载到当前工程中# 5. 全局# 安装: yarn global add [package]# 卸载: yarn global remove [package]# 注意: global一定在add左边yarn global add @vue/cli 创建项目 vue create vuecli-demo 可自行选择版本{vue2&#x2F;&#x2F;&#x2F;vue3}和配置{less….} vue.config.js配置修改后 要重新执行yarn serve（启动服务器） 命令 123456lintOnSave: false,//改完配置，重启开发服务器,关闭eslint功能devServer: &#123; host: &#x27;localhost&#x27;, port: 8080, // 指定端口号 open: true,//自动打开&#125;, 项目内文件src：业务文件夹​ assets ：静态资源（图片、字体图标等） ​ main.js 打包入口 文件，引入vue对象 {import App from ‘.&#x2F;09_vue_过滤器.vue’} ​ App.vue：整个应用的根组件 vue页面的入口，再次编写代码 过滤器 ：filters12345678910// todo ============= 方式1:main.js中书写 全局 - 过滤器 =============// 任意的.vue文件内&quot;直接&quot;使用,// 给过滤器传参 第一个参数是|前面要处理的数据 第二个参数形参 方便使用的时候传参// 语法: Vue.filter(&quot;过滤器名&quot;, 值 =&gt; 处理结果)Vue.filter(&#x27;reverse&#x27;, val =&gt; val.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;))// todo ============= 过滤器接参数 =============Vue.filter(&#x27;reverse&#x27;, (val, s) =&gt; &#123; return val.split(&#x27;&#x27;).reverse().join(s)&#125;) 123456789101112&lt;template&gt; &lt;div&gt; &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;!-- 2. 过滤器使用 语法: &#123;&#123; 值 | 过滤器名字 &#125;&#125; vue变量 | 过滤器(实参) --&gt; &lt;p&gt;使用翻转过滤器:&#123;&#123; msg | reverse(&#x27;😩&#x27;) &#125;&#125; &lt;/p&gt; &lt;!-- vue变量 | 过滤器1 | 过滤器2 --&gt; &lt;p :title=&quot;msg | toUp | reverse(&#x27;/&#x27;)&quot;&gt;鼠标长停&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 局部使用,写在需要使用的App.vue文件内，与data同级 12345678910111213141516&lt;p :title=&quot;msg | toUp | reverse(&#x27;|&#x27;)&quot;&gt;鼠标长停&lt;/p&gt; // 方式2: 局部 - 过滤器 // 只能在当前vue文件内使用 /* 语法: filters: &#123; 过滤器名字 (val) &#123; return 处理后的值 &#125; &#125; */ filters: &#123; toUp(val) &#123; return val.toUpperCase(); &#125;, &#125;, vue计算属性：computedcomputed：与data同级；计算属性和data属性都是变量-不能重名； 函数内变量变化, 会自动重新计算结果返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export default &#123; data()&#123; return &#123; a: 10, b: 20 &#125; &#125;, // 计算属性: // 场景: 一个变量的值, 需要用另外变量计算而得来 /* 语法: computed: &#123; 计算属性名 () &#123; return 值 &#125; &#125; */ // 注意: 计算属性和data属性都是变量-不能重名 // 注意2: 函数内变量变化, 会自动重新计算结果返回 computed: &#123; num()&#123; return this.a + this.b &#125; &#125;&#125; // 计算属性优势: // 带缓存 // 计算属性对应函数执行后, 会把return值缓存起来 // 依赖项不变, 多次调用都是从缓存取值 // 依赖项值-变化, 函数会&quot;自动&quot;重新执行-并缓存新的值 computed: &#123; //带缓存 reverseMessage()&#123; console.log(&quot;计算属性执行了&quot;); return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; &#125;, methods: &#123; //没缓存 每次都重新调用 getMessage()&#123; console.log(&quot;函数执行了&quot;); return this.msg.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; &#125;//完整写法computed: &#123; &quot;属性名&quot;: &#123; set(值)&#123; &#125;, get() &#123; return &quot;值&quot; &#125; &#125;&#125; 侦听器：watchwatch：与data同级 123456789101112//语法:watch: &#123; 变量名 (newVal, oldVal)&#123; // 变量名对应值改变这里自动触发 &#125;, 变量名: &#123; handler(newVal, oldVal)&#123;&#125;, deep: true, // 深度侦听(对象里面层的值改变) immediate: true // 立即侦听(网页打开handler执行一次) &#125;&#125; 侦听data computed 123456watch:&#123; 数据名(newVal,oldVal)&#123; newVal 修改后的新值 oldVal 上一次的值 &#125;&#125; 侦听复杂数据 1234567watch:&#123; 数据名:&#123; deep:true//开启深度侦听 handler(newVal,oldVal)&#123;&#125; immediate:true //立即执行 &#125;&#125; vue组件：component使用: 把组件名 当标签名来使用 全局123456789101112131415import Vue from &#x27;vue&#x27;import 组件对象 from &#x27;vue文件路径&#x27;Vue.component(&quot;组件名&quot;, 组件对象)// 目标: 全局注册 (一处定义到处使用)// 1. 创建组件 - 文件名.vue// 2. 引入组件import Pannel from &#x27;./components/Pannel&#x27;// 3. 全局 - 注册组件/* 语法: Vue.component(&quot;组件名&quot;, 组件对象)*/Vue.component(&quot;PannelG&quot;, Pannel) 局部123456789101112131415161718192021&lt;script&gt; //导入组件 import 组件对象 from &#x27;vue文件路径&#x27; export default &#123; components: &#123; &quot;组件名&quot;: 组件对象 &#125;&#125; &lt;/script&gt;//使用&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;!-- 4. 组件名当做标签使用 --&gt; &lt;!-- &lt;组件名&gt;&lt;/组件名&gt; --&gt; &lt;PannelG&gt;&lt;/PannelG&gt; &lt;PannelL&gt;&lt;/PannelL&gt; &lt;/div&gt;&lt;/template&gt; 2.vue组件-scoped作用目的: 解决多个组件样式名相同, 冲突问题 只在当前的组件内生效 123&lt;style scoped&gt; //css样式 &lt;/style&gt; 3.组件内通信 父传子1.在子组件上,通过props来指定 属性,将来通过属性来接收父传给子的数据 1props: [&quot;title&quot;, &quot;price&quot;, &quot;intro&quot;] //其中里面的属性必须要加 &quot;&quot; 2.在父组件上,通过属性来传值1&lt;MyProduct title=&quot;哈哈&quot; :price=&quot;demo&quot;&gt;&lt;/MyProduct&gt; 3.单向数据流 (从父到子的数据流向) 在vue中需要遵循单向数据流原则 1. 父组件的数据发生了改变，子组件会自动跟着变 2. 子组件不能直接修改父组件传递过来的props props是只读的 3. 父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，对象是引用类型, 互相更新 4.组件内通信 子传父1.在子组件上 通过this.$emit(‘自定义事件’,值)触发自定义事件,以及还可以传参 2.在父组件上,监听自定义事件 1&lt;MyProduct @自定义事件=&quot;事件处理函数&quot;&gt;&lt;/MyProduct&gt; components ：组件目录public 静态文件夹&#x3D;&gt;index.heml：浏览器真正运行的网页node_modules：第三方包 一般要在.gitignore文件进行忽略（根目录已经处理过）Vue语法 VUE-组件 1.组件进阶 - 动态组件 动态组件 vue内置的component 组件 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;typeName = &#x27;UserInfo&#x27;&quot;&gt;账号密码填写&lt;/button&gt; &lt;button @click=&quot;typeName = &#x27;UserName&#x27;&quot;&gt;个人信息填写&lt;/button&gt; &lt;p&gt;下面显示注册组件-动态切换:&lt;/p&gt; &lt;div style=&quot;border: 1px solid red&quot;&gt; &lt;!-- 动态组件 vue内置的component 组件 --&gt; &lt;component :is=&quot;typeName&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import UserInfo from &quot;../components/01/UserInfo.vue&quot;;import UserName from &quot;../components/01/UserName.vue&quot;;export default &#123; data() &#123; return &#123; typeName: &quot;UserInfo&quot;, &#125;; &#125;, components: &#123; UserInfo, UserName, &#125;,&#125;;&lt;/script&gt; 2.组件进阶 - 组件缓存目标: 组件切换会导致组件被频繁销毁和重新创建, 性能不高 使用Vue内置的keep-alive组件, 可以让包裹的组件保存在内存中不被销毁 12345&lt;!-- //缓存组件 使用vue 内置的keep-alive 组件 把想要缓存的组件给包裹起来 --&gt; &lt;keep-alive&gt; &lt;!-- 动态组件 vue内置的component 组件 --&gt; &lt;component :is=&quot;typeName&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; 3.组件进阶 - 激活和非激活 目标: 被缓存的组件不再创建和销毁, 而是激活和非激活 补充2个钩子方法名: ​ activated – 激活时触发 ​ deactivated – 失去激活状态触发 4.组件进阶 - 组件插槽语法口诀: 组件内用占位 使用组件时夹着的地方, 传入标签替换slot 12345678910&lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;!-- &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; --&gt; &lt;!-- slot 是vue内置的组件,当标签来使用,起到占位的作用 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;// 1. 组件内 &lt;slot&gt;&lt;/slot&gt; 占位// 2. 使用组件, 传入具体的标签替换 到slot位置上 5.组件进阶 - 插槽默认内容 目标: 如果外面不给传, 想给个默认显示内容 口诀: 夹着内容默认显示内容, 如果不给插槽slot传东西, 则使用夹着的内容在原地显示 1&lt;slot&gt;默认内容&lt;/slot&gt; 6.组件进阶 - 具名插槽 &#x2F;&#x2F; 目标: 具名插槽 &#x2F;&#x2F; 场景: 2处以上不确定的地方 &#x2F;&#x2F; 1. slot占位 - name属性起名字 &#x2F;&#x2F; 2. 使用组件, template配合v-slot:插槽名, 夹着传入具体标签 v-slot: 可以简化成# 总结: slot的name属性起插槽名, 使用组件时, template配合#插槽名传入具体标签 12345678910111213141516&lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;Pannel&gt; &lt;template v-slot:title&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;/template&gt; &lt;template #content&gt; &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/template&gt; &lt;/Pannel&gt; 7.组件进阶 - 作用域插槽&#x2F;&#x2F; 目标: 作用域插槽 &#x2F;&#x2F; 场景: 使用插槽, 使用组件内的变量 slot标签, 自定义属性和内变量关联 使用组件, template配合v-slot&#x3D;”变量名” 变量名会收集slot身上属性和值形成对象 123456789101112131415161718&lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;!-- obj是个变量名 ,自己命名 --&gt; &lt;slot name=&quot;content&quot; :obj=&quot;defaultObj&quot;&gt;&#123;&#123; defaultObj.defaultOne &#125;&#125;&lt;/slot&gt; &lt;/div&gt; &lt;Pannel&gt; &lt;!-- scope是变量名 ,可以自己命名 --&gt; &lt;!-- scope 变量 是个对象 --&gt; &lt;!-- scope 结果&#123;obj.defaultObj&#125; --&gt; &lt;!-- 简写 --&gt; &lt;!-- &lt;template #content=&quot;scope&quot;&gt; &lt;p&gt;&#123;&#123; scope.obj.defaultTwo &#125;&#125;&lt;/p&gt; &lt;/template&gt; --&gt; &lt;template v-slot:content=&quot;scope&quot;&gt; &lt;p&gt;&#123;&#123; scope.obj.defaultTwo &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/Pannel&gt; 8.自定义指令目标: 创建 “自定义指令”, 让输入框自动聚焦 创建自定义指令 全局 &#x2F; 局部 在标签上使用自定义指令 v-指令名 注意: inserted方法 - 指令所在标签, 被插入到网页上触发(一次) update方法 - 指令对应数据&#x2F;标签更新时, 此方法执行 1.全局注册 1234567891011// 全局指令 - 到处&quot;直接&quot;使用Vue.directive(&quot;gfocus&quot;, &#123; inserted(el) &#123; el.focus() // 触发标签的事件方法 &#125;&#125;)&lt;div&gt; &lt;!-- 使用自定义的全局指令--&gt; &lt;input type=&quot;text&quot; placeholder=&quot;演示全局指令2&quot; v-gfocus /&gt; &lt;/div&gt; 2.局部注册 12345678&lt;div&gt; &lt;!-- 使用自定义的局部指令 --&gt; &lt;input type=&quot;text&quot; placeholder=&quot;演示局部指令&quot; v-focus&gt; &lt;!-- &lt;p v-color=&quot;&#x27;pink&#x27;&quot;&gt;改变颜色&lt;/p&gt; --&gt; &lt;p v-color=&quot;res&quot;&gt;改变颜色&lt;/p&gt; &lt;!-- 指令的值 --&gt; &lt;/div&gt; 1234567891011121314151617181920export default &#123;directives: &#123; focus: &#123; inserted(el) &#123; //el形参表示指令所在的DOM元素 console.log(el); el.focus(); &#125;, &#125;, color: &#123; inserted(el, binding) &#123; el.style.color = binding.value; &#125;, //更新 update(el, binding) &#123; el.style.color = binding.value; &#125;, &#125;, &#125;,&#125; 9.案例123456789101112131415161718192021 &lt;!-- :class=&quot;&#123;类名:值来控制类名的有无&#125;&quot; --&gt; &lt;!-- :class=&quot;item.iconText&quot; 把item.iconText当成变量 动态设置类名 --&gt;//借助于validator 函数来实现 自定义校验规则props: &#123; arr: &#123; type: Array, require: true, //额外的校验 借助于validator 函数来实现 自定义校验规则 validator(value) &#123; // console.log(value); //接收的数据 是arr里面的数据 if (value.length &gt;= 2 &amp;&amp; value.length &lt;= 5) &#123; return true; //表示校验通过 &#125; else &#123; return false; //表示校验不通过 &#125; &#125;, &#125;, &#125;, router VUE-Router1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div&gt; &lt;div class=&quot;footer_wrap&quot;&gt; &lt;!-- &lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a&gt; &lt;a href=&quot;#/my&quot;&gt;我的音乐&lt;/a&gt; &lt;a href=&quot;#/part&quot;&gt;朋友&lt;/a&gt; --&gt; &lt;!-- 声明式导航，全剧组件， to 属性值，不加 #，否则不合符路由规则路径，有bug --&gt; &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt; &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt; &lt;!-- query 传值 --&gt; &lt;router-link to=&quot;/part?name=李七&quot;&gt;朋友---李七&lt;/router-link&gt; &lt;!-- params 传值，需要到路由规则添加/part/:name 使用 /part/值 --&gt; &lt;router-link to=&quot;/part/董五&quot;&gt;朋友-----董五&lt;/router-link&gt; &lt;!-- 编程式导航,通过增加点击事件传值，跳转路由 --&gt; &lt;!-- &lt;span @click=&quot;fn(&#x27;/find&#x27;)&quot;&gt;发现音乐&lt;/span&gt; &lt;span @click=&quot;fn(&#x27;/my&#x27;)&quot;&gt;我的音乐&lt;/span&gt; &lt;span @click=&quot;one(&#x27;/part&#x27;, &#x27;李七&#x27;)&quot;&gt;朋友---李七&lt;/span&gt; &lt;span @click=&quot;two(&#x27;/part&#x27;, &#x27;董五&#x27;)&quot;&gt;朋友---董五&lt;/span&gt; --&gt; &lt;/div&gt; &lt;div class=&quot;top&quot;&gt; &lt;!-- 挂载点 router-view 组件，vue-router内部提供--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fn(path) &#123; // this.$route 获取当前信息 this.$router.push()可以实现跳转路由 this.$router .push(&#123; // path, // name方式，需要在main.js中配置路由规则的name值 name: &#x27;My&#x27;, &#125;) //重复点击同一个路由会有报错，正常，可以catch出来 .catch((err) =&gt; console.log(err)) &#125;, one(path, val) &#123; // path + query 可以传值 this.$router.push(&#123; path, query: &#123; uname: val, &#125;, &#125;) &#125;, two(path, val) &#123; this.$router.push(&#123; // ！path和params一起使用时，params会被忽略 path, params: &#123; name: val, &#125;, &#125;) &#125;, &#125;,&#125; main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 导入路由对应组件import Find from &#x27;@/views/Find&#x27; // vue文件中，@表示 src目录的绝对路径import My from &#x27;@/views/My&#x27;import Part from &#x27;@/views/Part&#x27;import NotFind from &#x27;@/views/NotFind&#x27;import Ranking from &#x27;./views/Second/Ranking.vue&#x27;import Recommend from &#x27;./views/Second/Recommend.vue&#x27;import SongList from &#x27;./views/Second/SongList.vue&#x27;Vue.config.productionTip = false//**书写路由的步骤/*1.下包 yarn add vue-router@3 配合vue2使用的2.引入 main.js3.注册 固定写法 Vue.use()4.配置路由规则5.创建路有对象，固定写法 new Vue-router()6.路由注入到vue实例上7.挂载点，固定写法 router-view*/// 所有导入，不推荐// import Vant from &#x27;vant&#x27;;// import &#x27;vant/lib/index.css&#x27;;// Vue.use(Vant);// 按需导入注册import &#123; Button &#125; from &#x27;vant&#x27;;Vue.use(Button)// 全局注册Button按钮// 路由代码 vue-touter 引入import VueRouter from &#x27;vue-router&#x27;// 注册插件Vue.use(VueRouter)// 路由规则数组const routes = [ &#123; path: &#x27;/&#x27;, // 重定向 redirect: &#x27;/find&#x27; &#125;, &#123; path: &#x27;/find&#x27;, component: Find, // 二级路由，不用从根路径开始，直接从上面继承根目录地址 children: [ &#123; path: &#x27;recommend&#x27;, component: Recommend &#125;, &#123; path: &#x27;ranking&#x27;, component: Ranking &#125;, &#123; path: &#x27;songlist&#x27;, component: SongList &#125;, ] &#125;, &#123; path: &#x27;/my&#x27;, component: My, name: &#x27;My&#x27;, &#125;, &#123; path: &#x27;/part&#x27;, component: Part, &#125;, &#123; path: &#x27;/part/:name&#x27;, component: Part, &#125;, &#123; path: &#x27;*&#x27;, component: NotFind, &#125;,]// 创立路由实例对象,传入规则const router = new VueRouter(&#123; routes, mode: &#x27;history&#x27;,//hash 地址后面有#&#125;)// 路由守卫 .beforeEach()方法let isLogin = false //false 未登录状态router.beforeEach((to, from, next) =&gt; &#123; console.log(to) //去哪里 + 路由信息 console.log(from) //从哪来 + 路由信息 console.log(next) //决定下一步干什么的 ！函数 if (to.path === &#x27;/my&#x27; &amp;&amp; !isLogin) &#123; next(false)//未登录，拒绝执行下面操作，停留原地 // next(&#x27;login&#x27;) 跳转到登录界面 return alert(&#x27;请登录&#x27;) &#125; else &#123; next(true) &#125;&#125;)new Vue(&#123; router, render: (h) =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 添加请求拦截器instance.interceptors.request.use( function (config) &#123; // 获取token信息 const token = store.state.user.token.token if (token) &#123; // 有token就带上 没有就算了 // 在发送请求之前做些什么 统一处理token config.headers.Authorization = &#x27;Bearer &#x27; + token &#125; return config &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error) &#125;)// 添加响应拦截器instance.interceptors.response.use( function (response) &#123; // 对响应数据做点什么 处理数据 剥掉一层data return response.data &#125;, async function (error) &#123; // 对响应错误做点什么 // console.log(error) if (error.response.status === 401) &#123; try &#123; // token过期-&gt;去登陆，考虑从哪里跳过来登录的，应该原路返回，不能直接back // router.push(&#x27;/login&#x27;) // console.log(router.currentRoute) // router.push(&#123; // path: &#x27;/login&#x27;, // query: &#123; // // .vue文件中 使用 this.$route===JS文件中 router.currentRoute // back: true // &#125; // &#125;) // todo 用户token信息过期，使用 refresh_token去发送请求获取新的token，再把它放进vuex里面， const refteshToken = store.state.user.token.refresh_token // todo 如果有refteshToken，发送请求获取新的token if (refteshToken) &#123; // console.log(refteshToken) // todo 使用 refresh_token去发送请求获取新的token // todo 不能使用封装的 instance 发请求，因为它会只用旧的token发请求 const res = await axios(&#123; url: &#x27;http://toutiao.itheima.net/v1_0/authorizations&#x27;, method: &#x27;PUT&#x27;, headers: &#123; Authorization: `Bearer $&#123;refteshToken&#125;` &#125; &#125;) console.log(res) // todo 获取到了新的token值，保存在本地和VUEX中， // todo 要加上 &#x27;user/&#x27; 否则找不到路径 store.commit(&#x27;user/setToken&#x27;, &#123; token: res.data.data.token, // todo 新的token refresh_token: refteshToken // 未更新，不要变 &#125;) // todo 用它重新发送请求,这里有了新的token信息可以用拦截器中的instance来发送， // todo 注意参数不能直接写token，找到上面报错信息 error 看里面的配置项，有对应的对象参数 return instance(error.config) &#125; else &#123; // todo 有refteshToken，但是过期了也要去登陆页面 login() &#125; &#125; catch (error) &#123; // todo 没有refteshToken，则清除本地无效的token，到登录页面 login() &#125; &#125; else &#123; // todo 获取失败，除本地无效的token，到登录页面 login() // 获取信息失败的结果 return Promise.reject(error) &#125; &#125;)// 对外导出axios的实例对象使用export default instancefunction login() &#123; // todo 获取store中的方法，清除token store.commit(&#x27;user/removeToken&#x27;) // 提示过期了，需要重新登录 Toast.fail(&#x27;登陆过期，请重新登录&#x27;) // todo 跳转登录 router.push(&#123; path: &#x27;/login&#x27;, query: &#123; // .vue文件中 使用 this.$route===JS文件中 router.currentRoute back: true &#125; &#125;)&#125; 路由守卫&#x2F;&#x2F; 全局的导航守卫&#x2F;&#x2F; 需要登录的页面&#x2F;&#x2F; 只要导航发生跳转，都会先执行beforeEach的函数&#x2F;&#x2F; 守卫的思路&#x2F;&#x2F; 1. 判断是否有token 如果有 直接放行&#x2F;&#x2F; 2. 如果没有token,,判断去的页面是否需要登录&#x2F;&#x2F; 3. 如果去的页面不需要登录，放行&#x2F;&#x2F; 4. 如果去的页面需要登录，拦截到登录页面。 &#x2F;&#x2F; 需要登陆才能访问的页面 将这些页面放入数组中，遍历查询对比const privateURL &#x3D; [‘&#x2F;user’, ‘&#x2F;user&#x2F;chat’, ‘&#x2F;user&#x2F;profile’, ‘&#x2F;qa’, ‘&#x2F;user&#x2F;edit’] 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 路由守卫/* 固定方法 router.beforeEach((to, from, next) =&gt; &#123;获取仓库的token值const token=store.state.user.token 需要导入store if(登录了===有token)&#123; if(登录后还要去登录===页面===拦截下来到首页)&#123; next(&#x27;/&#x27;) 跳转到首页 &#125;else&#123; 其他非登录的页面，可以直接去 next() &#125; &#125;else&#123; 未登录状况区分 if(to.mate.unLogin)&#123; 白名单不需要登录，需要路由配置 meta属性，登录页面或者404 直接过去 &#125;else&#123; 其他需要登录才能看到的页面，强制跳转去登录 next(&#x27;/login&#x27;) &#125; &#125;&#125;) */router.beforeEach((to, from, next) =&gt; &#123; const token = store.state.user.token if (token) &#123; if (to.path === &#x27;/login&#x27;) &#123; console.log(&#x27;token&#x27;, to) next(&#x27;/&#x27;) &#125; else &#123; next() &#125; &#125; else &#123; // console.log(to) if (to.meta.unLogin) &#123; next() &#125; else &#123; next(&#x27;/login&#x27;) &#125; &#125;&#125;) VUEX vuex概念 vue全家桶：vue + vue-router + vuex + vue-cli 目标： 了解vuex的应用场景 (在哪用) 掌握vuex的基本使用 (怎么用) 常见的组件通讯方案 在现代化开发中，组件化已经成为主流开发了。 组件的数据是独立的, 每个组件有着自己的状态(数据) 在实际开发中，一个组件需要访问另一个组件中的数据是非常常见的。这时候需要进行组件通讯。 常见的组件通讯 父传子 props 子传父 $emit event bus 通用组件通讯的解决方案 为什么要有vuex vuex的作用是解决多组件状态共享的问题，在大型的项目中，组件通讯会变得很混乱，使用vuex可以统一管理组件之间的通讯 它是独立于组件而单独存在的，所有的组件都可以把它当作一座桥梁来进行通讯。 与事件总线（EventBus）相比，它具备额外的特点： 响应式 操作更简洁 项目越大，vuex越清晰 vuex缺点：vuex功能非常的强大，但是vuex的要求也特别的多。如果是小项目，使用vuex收益不高，如果是大型项目。适合使用vuex vuex基本概念vuex是vue的状态管理工具，状态即数据。 状态管理就是集中管理vue中通用的一些数据 注意： 不是所有的场景都适用于vuex，只有在必要的时候才使用vuex,如果不必要，尽量别用 使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度 vuex架构就像眼镜：您自会知道什么时候需要它。 vuex入门初始化vuex项目 初始化命令 1vue create 01-vuex-demo vue项目如何配置自动打开浏览器 多组件共享数据(1)app.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h1&gt;vuex案例&lt;/h1&gt; &lt;div&gt; 总资产：100 &lt;/div&gt; &lt;Man class=&quot;man&quot;&gt; &lt;/Man&gt; &lt;Women class=&quot;women&quot;&gt;&lt;/Women&gt; &lt;Three class=&quot;three&quot;&gt;&lt;/Three&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Man from &#x27;./components/Man&#x27;import Women from &#x27;./components/Women&#x27;import Three from &#x27;./components/Three&#x27;export default &#123; components: &#123; Man, Women, Three &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;* &#123; margin: 0; padding: 0; list-style: none; box-sizing: border-box;&#125;.app &#123; text-align: center; width: 600px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; .man, .women, .three &#123; height: 200px; border-bottom: 3px solid #ccc; background-color: #ddd; &#125; div &#123; min-height: 30px; &#125;&#125;&lt;/style&gt; (2)Man.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;boy&quot;&gt; &lt;h3&gt;男人组件&lt;/h3&gt; &lt;div&gt;金钱：100&lt;/div&gt; &lt;button&gt;搬砖+1&lt;/button&gt; &lt;button&gt;卖肾+100&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;button &#123; padding: 5px; line-height: 30px; margin-left: 10px;&#125;&lt;/style&gt; (3)Women.vue 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h3&gt;女人组件&lt;/h3&gt; &lt;div&gt;金钱：100&lt;/div&gt; &lt;button&gt;买口红-10&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; (4)Three.vue 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h3&gt;小三组件&lt;/h3&gt; &lt;div&gt;金钱：100&lt;/div&gt; &lt;button&gt;买包-50&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; vuex 的使用 - 创建仓库1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。 1yarn add vuex 2 新建 store/index.js 专门存放 vuex ​ 为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 router/index.js 类似) 3 创建仓库 store/index.js 123456789101112// 导入 vueimport Vue from &#x27;vue&#x27;// 导入 vueximport Vuex from &#x27;vuex&#x27;// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store 4 在 main.js 中导入挂载到 Vue 实例上 12345678910import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App), store&#125;).$mount(&#x27;#app&#x27;) 此刻起, 就成功创建了一个空仓库!! 核心概念 - state 状态State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。 state提供数据打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。 12345678// 创建store对象const store = new Vuex.Store(&#123; // vuex的配置 // state: 状态 即数据 state指的是vuex中的数据 state: &#123; money: 1000 &#125;&#125;) 问题: 如何在组件中获取money? 组件直接获取数据所有的组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取money， 如下 1&lt;h1&gt;state的数据 - &#123;&#123; $store.state.money &#125;&#125;&lt;/h1&gt; &#x3D;&#x3D;缺点：如果vuex中的某个数据在组件中需要多次使用，会很麻烦&#x3D;&#x3D; 计算属性计算属性 - 将state属性定义在计算属性中 https://vuex.vuejs.org/zh/guide/state.html 123456// 提供计算属性computed: &#123; money () &#123; return this.$store.state.money &#125;&#125; 1&lt;h1&gt;state的数据 - &#123;&#123; money &#125;&#125;&lt;/h1&gt; &#x3D;&#x3D;如果某个组件需要用到vuex中多个状态，需要创建多个计算属性&#x3D;&#x3D; 但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法 辅助函数-mapState mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法 用法 ： 第一步：导入mapState (mapState是vuex中的一个函数) 1import &#123; mapState &#125; from &#x27;vuex&#x27; 第二步：采用数组形式引入state属性 123export default &#123; computed: mapState([&#x27;money&#x27;, &#x27;car&#x27;])&#125; 上面代码的最终得到的是 类似于 123456789// 提供计算属性computed: &#123; money () &#123; return this.$store.state.money &#125;, car () &#123; return this.$store.state.car &#125;&#125; mapState配合展开运算符如果直接使用mapState,会导致组件无法提供自己的计算属性，需要配合展开运算符使用 123456computed: &#123; ...mapState([&#x27;money&#x27;, &#x27;car&#x27;]), sum () &#123; return this.num1 + this.num2 &#125;&#125; mapState可以是对象如果需要对vuex中的数据进行重命名的时候，会使用对象的形式 123456789computed: &#123; ...mapState([&#x27;car&#x27;]), ...mapState(&#123; money1: &#x27;money&#x27;, &#125;), sum () &#123; return this.num1 + this.num2 &#125;&#125; 核心概念 - mutations state数据的修改只能通过mutations，并且mutations必须是同步的 严格模式 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV === &#x27;development&#x27;&#125;) 基本使用&#x3D;&#x3D;state是vuex提供数据的，mutations是vuex提供修改数据的方法的。。修改数据只能通过mutations&#x3D;&#x3D; 定义mutations 123456789const store = new Vuex.Store(&#123; state: &#123; money: 0 &#125;, // 定义mutations mutations: &#123; &#125;&#125;) 格式说明 mutations是一个对象，对象中存放修改state的方法 123456mutations: &#123; // mutations中所有的方法的参数1都是state addMoney (state) &#123; state.money++ &#125;&#125; 组件中提交 mutations 1this.$store.commit(&#x27;addMoney&#x27;) 带参数的 mutation1 提供mutation函数 12345mutations: &#123; addMoreMoney (state, money) &#123; state.money += money &#125;&#125;, 2 提交mutation,需要传递额外的参数 123addMore () &#123; this.$store.commit(&#x27;addMoreMoney&#x27;, 100)&#125; 小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象 payload 载荷 指的就是mutations的额外参数，payload是一个对象，因为可以传递多个参数，而且更好阅读 12345678addMoreMoney (state, payload) &#123; state.money += payload.money&#125;this.$store.commit(&#x27;addMoreMoney&#x27;, &#123; money: 100, name: &#x27;张三&#x27;&#125;) 辅助函数 - mapMutations mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入 1234import &#123; mapMutations &#125; from &#x27;vuex&#x27;methods: &#123; ...mapMutations([&#x27;addCount&#x27;])&#125; 上面代码的含义是将mutations的方法导入了methods中，等价于 123456methods: &#123; // commit(方法名, 载荷参数) addCount () &#123; this.$store.commit(&#x27;addCount&#x27;) &#125; &#125; 此时，就可以直接通过this.addCount调用了 1&lt;button @click=&quot;addCount()&quot;&gt;值+1&lt;/button&gt; 但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中 核心概念-actions state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)， actions则负责进行异步操作 需求: 一秒钟之后, 要给一个数 去修改state 定义actions 12345678actions: &#123; setAsyncCount (context, num) &#123; // 一秒后, 给一个数, 去修改 num setTimeout(() =&gt; &#123; context.commit(&#x27;inputCount&#x27;, num) &#125;, 1000) &#125;&#125;, 原始调用 - $store (支持传参) 123setAsyncCount () &#123; this.$store.dispatch(&#x27;setAsyncCount&#x27;, 200)&#125; 辅助函数 -mapActions actions也有辅助函数，可以将action导入到组件中 1234import &#123; mapActions &#125; from &#x27;vuex&#x27;methods: &#123; ...mapActions([&#x27;setAsyncCount&#x27;])&#125; 直接通过 this.方法 就可以调用 1&lt;button @click=&quot;setAsyncCount(200)&quot;&gt;+异步&lt;/button&gt; 核心概念-getters 除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters 给vuex也提供计算属性 提供一个昵称 123456789101112// getters: 是vuex的计算属性getters: &#123; nickname (state) &#123; if (state.money &gt;= 100000) &#123; return &#x27;土豪&#x27; &#125; else if (state.money &gt;= 10000) &#123; return &#x27;贫民&#x27; &#125; else &#123; return &#x27;屌丝&#x27; &#125; &#125;&#125; 使用getters 原始方式 -$store 1&lt;div&gt;&#123;&#123; $store.getters.nickname &#125;&#125;&lt;/div&gt; 辅助函数 - mapGetters mapGetters和mapState的功能差不都，，mapGetters把vuex的getters映射为组件的计算属性 123computed: &#123; ...mapGetters([&#x27;nickname&#x27;])&#125; 1&lt;div&gt;&#123;&#123; nickname &#125;&#125;&lt;/div&gt; todos案例vuex-模块化Vuex中的模块化-Module为什么会有模块化？ 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护 由此，又有了Vuex的模块化 模块化的简单应用应用 定义两个模块 user 和 setting user中管理用户的状态 token setting中管理 网站的名称 name 12345678910111213const store = new Vuex.Store(&#123; modules: &#123; user: &#123; state: &#123; token: &#x27;12345&#x27; &#125; &#125;, setting: &#123; state: &#123; name: &#x27;Vuex实例&#x27; &#125; &#125; &#125;) 定义App.vue组件，分别显示用户的token和应用名称name 123456&lt;template&gt; &lt;div&gt; &lt;div&gt;用户token &#123;&#123; $store.state.user.token &#125;&#125;&lt;/div&gt; &lt;div&gt;网站名称 &#123;&#123; $store.state.setting.name &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 请注意： 此时要获取子模块的状态 需要通过 $store.state.模块名称.属性名 来获取 看着获取有点麻烦，我们可以通过之前学过的getters来改变一下 1234getters: &#123; token: state =&gt; state.user.token, name: state =&gt; state.setting.name&#125; 请注意：这个getters是根级别的getters哦 通过mapGetters引用 123computed: &#123; ...mapGetters([&#x27;token&#x27;, &#x27;name&#x27;])&#125; 模块化中的命名空间默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 这句话的意思是 刚才的user模块还是setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用 如 命名空间 namespaced 如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置 高封闭性？可以理解成 一家人如果分家了，此时，你的爸妈可以随意的进出分给你的小家，你觉得自己没什么隐私了，我们可以给自己的房门加一道锁（命名空间 namespaced）,你的父母再也不能进出你的小家了 如 12345678910111213141516171819202122const user = &#123; // 开启了模块的命名空间 // mutatioins actions getters不会挂到全局的命名空间里 namespaced: true, state: &#123; token: &#x27;123&#x27; &#125;, mutations: &#123; setToken (state, token) &#123; state.token = token &#125; &#125;, getters: &#123; &#125;, actions: &#123; setToken (context) &#123; console.log(&#x27;user的setToken actions&#x27;) &#125; &#125;&#125;export default user 使用带命名空间的模块 action/mutations 方案1：直接调用-带上模块的属性名路径 123test () &#123; this.$store.dispatch(&#x27;user/updateToken&#x27;) // 直接调用方法&#125; 方案2：辅助函数-带上模块的属性名路径 12345678910computed: &#123; // 映射全局的name状态 ...mapState([&#x27;name&#x27;]), // 映射setting模块的name状态 ...mapState(&#x27;setting&#x27;, [&#x27;name&#x27;])&#125;,methods: &#123; ...mapMutations([&#x27;setToken&#x27;]), ...mapMutations(&#x27;user&#x27;, [&#x27;setToken&#x27;])&#125; vue-组件 vue-路由","path":"2021/10/18/study/","date":"10-18","excerpt":"H5+C3 html超文本标记语言day0101. 网页组成​ 文字 图片 视频 音频 链接 02. web标准​ 结构html、表现css、行为JavaScript 03. 注释​ ctrl+&#x2F; 解释说明代码 04. html骨架123456&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/html&gt;","tags":[]}],"categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://libieke.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"}]}