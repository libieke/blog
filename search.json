[{"title":"JS扩展知识","date":"2024-08-22T08:41:48.011Z","url":"/blog/2024/08/22/JS%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/","tags":[["前端","/blog/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["undefined",""]],"content":" 动态class绑定 异步同步 vue属性 节流防抖 JS深浅拷贝 对象相关方法 数组相关方法 闭包相关 Vue组件传值6种方法 Props（父向子） 自定义事件（子向父） $refs 和直接调用方法 Vuex(跨多个层级组件间的通信):直接从 store 中获取 …mapGetters([‘getSharedData’]) Event Bus（允许任意组件之间进行通信）： provide&#x2F;inject:Vue 提供了 provide 和 inject API 来实现祖先组件向后代组件提供依赖的方式（无需中间传递） "},{"title":"什么是 RESTful 接口规范","date":"2024-05-14T13:57:42.930Z","url":"/blog/2024/05/14/%E8%A1%A5%E5%85%85/","categories":[["undefined",""]],"content":"&#x2F;&#x2F; 5个标准格式组成:&#x2F;&#x2F; 新增 post body[data] &#x2F;api&#x2F;news&#x2F;book&#x2F;&#x2F; 修改 put body[data ] &#x2F;api&#x2F;news&#x2F;book&#x2F;修改的ID&#x2F;&#x2F; 删除 delete body[data] &#x2F;api&#x2F;news&#x2F;book&#x2F;删除的ID&#x2F;&#x2F; 查询 get&#x2F;&#x2F; 查询列表 query[params] &#x2F;api&#x2F;news&#x2F;book&#x2F;&#x2F;&#x2F; 查询单个 &#x2F;api&#x2F;news&#x2F;book&#x2F;查询ID &#x2F;&#x2F;查询列表 export const getDepertListApi &#x3D; (params) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department’, method: ‘get’, params })}&#x2F;&#x2F;查询单个 export const getDepertInfoApi &#x3D; (id) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘ + id, method: ‘get’ })}&#x2F;&#x2F;增加 export const addDepertListApi &#x3D; (data) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘, method: ‘post’, data })}&#x2F;&#x2F;修改 export const editDepartmentListApi &#x3D; (data) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘ + data.id, method: ‘put’, data })}&#x2F;&#x2F;删除export const delDepartmentListApi &#x3D; (id) &#x3D;&gt; { return request({ url: ‘&#x2F;company&#x2F;department&#x2F;‘ + id, method: ‘delete’ })}"},{"title":"webapis小细节","date":"2024-05-14T13:57:42.930Z","url":"/blog/2024/05/14/%E6%98%93%E9%94%99%E7%82%B9%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","tags":[["前端","/blog/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["undefined",""]],"content":" 易错点和注意事项 到底使用的是querySelector 还是 querySelectorAll ，关键看获取的是一个还是多个 到底要不要写for循环，看操作的是不是元素集合伪数组，如果是元素集合伪数组，就需要for循环遍历操作处理。 伪数组，也有数字下标，也是从0开始的。 要不要使用${} ${} 的使用是在 反引号里面来使用的，反引号表示是个字符串 所以不涉及到反引号，不涉及字符串的化，就不要书写 ${} 了 是属性还是方法 属性不需要括号 方法是需要的 到底要不要加引号 我们操作的值如果是字符串，就需要带引号 如果非字符串，就可以不用引号 给元素注册事件的时候，到底要不要使用事件委托呢 当给多个元素注册事件的时候，可以使用事件委托来优化 并且当给动态生成的元素来注册事件的时候，使用事件委托来实现。 操作内容，到底是通过 innerHTML 还是 value 属性 对于像 div span ul li p 等标签，操作内容使用 innerHTML 或 innerText 来实现 但是对于像表单元素 input、单选、多选、文本域等，操作内容就需要通过 value 属性来操作了 特殊的：button按钮的内容是需要通过 innerText 或 innerHTML 来设置了 设置样式的时候，是否需要单位px 对于style设置样式，大部分需要带单位px 比如fontSize、width 、height 但对于层级z-index ，背景系列background不需要 另外三大家族的scrollTop的值是不需要单位px的 "},{"title":"制作小程序简历","date":"2024-05-14T13:57:42.923Z","url":"/blog/2024/05/14/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E5%8E%86/","categories":[["undefined",""]],"content":" 制作小程序简历 使用微信小程序云开发制作自己的个人简历，简单高效。首先需要了解小程序的基本结构以及云开发模式，及一些css样式基础。使用小程序云数据库、vant组件库实现简历内容。 代码如下：index.json index.wxml index.wxss index.js 注意注意需在小程序云数据库中，添加”userInfo”集合，用于储存点赞用户信息，页面加载前会获取用户信息 以上就是小程序版个人简历的全部代码，具体审核流程，参照微信小程序审核文档。 "},{"title":"vue开发","date":"2024-05-14T13:57:42.923Z","url":"/blog/2024/05/14/vue%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/","tags":[["前端","/blog/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["undefined",""]],"content":"安装好脚手架 创建项目命令 安装组件 配置环境 .prettierrc 格式化 .eslintrc.js 格式化 babel.config.js rem适配 提供 postcss 的配置文件postcss.config.js 文件目录配置 src 下面 "},{"date":"2024-05-14T13:57:42.915Z","url":"/blog/2024/05/14/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","categories":[["undefined",""]],"content":" 生命周期 概念：一组件从 创建 到 销毁 的整个过程就是生命周期 1.1_钩子函数 目标: Vue 框架内置函数，随着组件的生命周期阶段，自动执行 作用: 特定的时间点，执行特定的操作 场景: 组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据 分类: 4大阶段8个方法 阶段 方法名 方法名 初始化 beforeCreate created 挂载 beforeMount mounted 更新 beforeUpdate updated 销毁 beforeDestroy destroyed 1.2_初始化阶段 目标: 掌握初始化阶段2个钩子函数作用和执行时机 含义讲解: 1.new Vue() – Vue实例化(组件也是一个小的Vue实例) 2.Init Events &amp; Lifecycle – 初始化事件和生命周期函数 3.beforeCreate – 生命周期钩子函数被执行 4.Init injections&amp;reactivity – Vue内部添加data和methods等 5.created – 生命周期钩子函数被执行, 实例创建 6.接下来是编译模板阶段 –开始分析 7.Has el option? – 是否有el选项 – 检查要挂到哪里 ​ 没有. 调用$mount()方法 ​ 有, 继续检查template选项 App.vue - 引入使用 1.3_挂载阶段 目标: 掌握挂载阶段2个钩子函数作用和执行时机 含义讲解: 1.template选项检查 ​ 有 - 编译template返回render渲染函数 ​ 无 – 编译el选项对应标签作为template(要渲染的模板) 2.虚拟DOM挂载成真实DOM之前 3.beforeMount – 生命周期钩子函数被执行 4.Create … – 把虚拟DOM和渲染的数据一并挂到真实DOM上 5.真实DOM挂载完毕 6.mounted – 生命周期钩子函数被执行 components&#x2F;Life.vue - 创建一个文件 1.4_更新阶段 目标: 掌握更新阶段2个钩子函数作用和执行时机 含义讲解: 1.当data里数据改变, 更新DOM之前 2.beforeUpdate – 生命周期钩子函数被执行 3.Virtual DOM…… – 虚拟DOM重新渲染, 打补丁到真实DOM 4.updated – 生命周期钩子函数被执行 5.当有data数据改变 – 重复这个循环 components&#x2F;Life.vue - 创建一个文件 准备ul+li循环, 按钮添加元素, 触发data改变-&gt;导致更新周期开始 1.5_销毁阶段 目标: 掌握销毁阶段2个钩子函数作用和执行时机 含义讲解: 1.当$destroy()被调用 – 比如组件DOM被移除(例v-if) 2.beforeDestroy – 生命周期钩子函数被执行 3.拆卸数据监视器、子组件和事件侦听器 4.实例销毁后, 最后触发一个钩子函数 5.destroyed – 生命周期钩子函数被执行 components&#x2F;Life.vue - 准备生命周期方法(Life组件即将要被删除) 主要: App.vue - 点击按钮让Life组件从DOM上移除 -&gt; 导致Life组件进入销毁阶段 2.0_axios基本使用特点 支持客户端发送Ajax请求 支持服务端Node.js发送请求 支持Promise相关用法 支持请求和响应的拦截器功能 自动转换JSON数据 axios 底层还是原生js实现, 内部通过Promise封装的 axios的基本使用 2.1_axios基本使用-获取数据 目标: 调用文档最后_获取所有图书信息接口 功能: 点击调用后台接口, 拿到所有数据 – 打印到控制台 接口: 参考预习资料.md – 接口文档 引入: 下载axios, 引入后才能使用 components&#x2F;UseAxios.vue 2.2_axios基本使用-传参 目标: 调用接口-获取某本书籍信息 功能: 点击调用后台接口, 查询用户想要的书籍信息 – 打印到控制台 接口: 参考预习资料.md – 接口文档 例子如下: components&#x2F;UseAxios.vue 2.3_axios基本使用-发布书籍 目标: 完成发布书籍功能 功能: 点击新增按钮, 把用户输入的书籍信息, 传递给后台 – 把结果打印在控制台 接口: 参考预习资料.md – 接口文档 例子如下: components&#x2F;UseAxios.vue 2.4_axios基本使用-全局配置 目标: 避免前缀基地址, 暴露在逻辑页面里, 统一设置 3.0 $refs-获取DOM 目标: 利用 ref 和 $refs 可以用于获取 dom 元素 components&#x2F;More.vue 总结: 通过id &#x2F; ref, 都可以获取原生DOM标签 3.1 $refs-获取组件对象 目标: 获取组件对象, 调用组件里方法 components&#x2F;Child&#x2F;Demo.vue More.vue - 获取组件对象 - 调用组件方法 总结: ref定义值, 通过$refs.值 来获取组件对象, 就能继续调用组件内的变量 3.2 $nextTick使用 Vue更新DOM-异步的 目标: 点击count++, 马上通过”原生DOM”拿标签内容, 无法拿到新值 components&#x2F;Move.vue - 继续新增第三套代码 总结: 因为DOM更新是异步的 3.3 $nextTick使用场景 目标: 点击搜索按钮, 弹出聚焦的输入框, 按钮消失 components&#x2F;Tick.vue 3.4 组件name属性使用 目标: 可以用组件的name属性值, 来注册组件名字 问题: 组件名不是可以随便写的? 答案: 我们封装的组件-可以自己定义name属性组件名-让使用者有个统一的前缀风格 components&#x2F;Com.vue App.vue - 注册和使用 "},{"title":"JS原生轮播图例子","date":"2024-05-14T13:57:42.913Z","url":"/blog/2024/05/14/JS%E5%8E%9F%E7%94%9F%E8%BD%AE%E6%92%AD%E5%9B%BE/","categories":[["undefined",""]],"content":" JS原生轮播图 "},{"title":"GitHub找项目","date":"2024-05-14T13:57:42.913Z","url":"/blog/2024/05/14/github%E6%89%BE%E9%A1%B9%E7%9B%AE/","categories":[["undefined",""]],"content":"EXP :我想要找到一个自动化部署的项目，关键字为devops，语言是java，star为100以上的项目搜索条件就是：devops language:java stars:&gt;100 awesome xxx &#x2F;&#x2F;令人惊叹的xxx项目stars:&gt;xxx &#x2F;&#x2F; stars数大于xxxstars:xxx..yyy &#x2F;&#x2F; stars数在xxx和yyy之间的forks:&gt;xxx &#x2F;&#x2F; forks数大于xxxlanguage:xxx &#x2F;&#x2F; 编程语言是xxxin:name xxx 或xxx in:name &#x2F;&#x2F; 按照项目名搜索in:readme xxx 或xxx in:readme &#x2F;&#x2F; 按照README搜索in:description xxx 或xxx in:description &#x2F;&#x2F; 按照description搜索pushed:&gt;YYYY-MM-DD &#x2F;&#x2F; 最后更新时间大于YYYY-MM-DDlocation:xxx &#x2F;&#x2F;开发者位置在xxx，比如china，beijing，chengduuser:xxx &#x2F;&#x2F;查找某开发者下的所有仓库followers:&gt;&#x3D;xxx &#x2F;&#x2F;粉丝数大于xxx的开发者 说明： 冒号两侧不能有空格； 不区分大小写； 不能将以下通配符用作搜索查询的一部分，搜索将忽略这些符号：. , : ; &#x2F; \\ &#96; ’ “ &#x3D; * ! ? # $ &amp; + ^ | ~ &lt; &gt; ( ) { } [ ]； 搜索默认为master分支"},{"title":"Windowns终端","date":"2022-11-18T07:31:36.000Z","url":"/blog/2022/11/18/Windowns%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/","categories":[["终端","/blog/categories/%E7%BB%88%E7%AB%AF/"]],"content":" Windowns终端外观配置 Windowns终端配置win11自带 WindowsTerminal，win10可以到自己电脑的微软商店搜索下载 配置个性化主题简单的一些设置通过 Oh My Posh，可以使用完整的颜色集来定义和呈现终端提示，包括能够使用内置主题或创建自己的自定义主题。 WindowsTerminal管理员权限在执行此命令，安装 Oh My Posh 选择主题，输入此命令可以查看各种样式的主题， 并使用此命令打开 PowerShell 配置文件.（可以将 notepad 替换为你选择的文本编辑器。） 将以下项添加到 PowerShell 配置文件的末尾，以设置 paradox 主题。 （将 paradox 替换为你选择的主题。）  主题地址 主题需要配合字体使用，会更加美观，下载安装Nerd的字体  ctrl+f 复制 JetBrainsMono 下载后将字体保存在自己选择的文件夹，然后解压。Ctrl+A 全选，单击鼠标右键选择安装即可。 最后，打开 WindowsTerminal，win+r 输入wt 即可打开，点击右上方的下拉箭头，点设置 选择左边的 WindowsPowerShell ，右边拉到最下面，选择外观，可以看到字体选择，建议选择 JetBrainsMonoNL Nerd Font Mono 字体 下面还有背景图片等设置 配置git代码补全功能1.下载post-git离线安装包，自选下载路径，解压 ​ 地址： 2.打开WindowsPowerShell，cd+你的下载路径解压路径，然后执行执行install.ps1 3.若不能修改则用管理员权限打开powershell，修改策略，再执行即可 "},{"title":"前端资料","date":"2021-10-18T07:31:36.000Z","url":"/blog/2021/10/18/study/","categories":[["前端基础知识","/blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"content":" H5+C3 html超文本标记语言day0101. 网页组成​ 文字 图片 视频 音频 链接 02. web标准​ 结构html、表现css、行为JavaScript 03. 注释​ ctrl+&#x2F; 解释说明代码 04. html骨架 05. h1-h6 标题标签双标签 独占一行 文字加粗 文字变大h1-h6逐渐变小 自带上下边距 06. 快捷键​ Alt+B 运行 ​ ctrl+D 出现多个光标 ​ shift+alt+下箭头 批量复制 07. 段落标签： 段落之间存在间隙 独占一行 08. 换行标签: 09. 水平线标签 : 10. 文本格式化标签: 语义 标签 说明 加粗 strong &#x2F; b strong 语义更强烈 倾斜 em &#x2F; i em 语义更强烈 删除线 del &#x2F; s del 语义更强烈 下划线 ins &#x2F; u ins 语义更强烈 11. 图片标签: 单标签 需借助属性 属性必须写在开始标签里面 属性和属性 属性和标签之间要有空格 属性 属性值 说明 src 图片路径 必填属性 alt 文本 替换文本，当图像不能显示时候，显示文本 title 文本 提示文本，当鼠标悬停在图像的时候显示文本 boder 像素 边框 width 像素 宽度（宽度和高度设置其中一个即可，因图片是等比例缩放） height 像素 高度（宽度和高度设置其中一个即可，因图片是等比例缩放） 12. 路径 绝对路径: 盘符开头&#x2F;完整地网络地址 相对路径: 同级目录(直接写目标文件名或.&#x2F;) 下级目录 (文件夹名&#x2F;目标文件) 上级目录(..&#x2F;目标文件) 13. 媒体标签音频标签: src路径 controls控件 autoplay自动播放 loop循环 视频标签: src路径 controls控件 autoplay自动播放需要配合muted静音播放 loop循环 14. 链接标签超链接: 外部链接 内部链接 空链接 下载链接 图片链接 锚点链接 target属性:_self默认值 当前窗口跳转 _blank新窗口中跳转 锚点链接: 15. 查文档 day0201. 列表标签无序列表 有序列表 自定义列表 无序列表: ul只能含li li可以含任意内容 li独占一行 前面有个小圆点有序列表: ol只能含li li可以含任意内容自定义列表: 一个dt对应多个dd 02. table表格标签书写方式 03. 表格标签table(表格整体)&gt;tr(表格每行)&gt;td(单元格) 标签 属性 tr 行 th 表头单元格（加粗、居中效果）包含tr内(替换td) td 表格单元格 caption 表格标题 居中显示 04. 表格属性：以下表格属性写在标签里面 属性 属性值 说明 border 数值（无单位） 边框 width 数值（无单位） 宽度 height 数值（无单位） 高度 align 左：left &#x2F; 居中：center &#x2F; 右：right 水平对齐方式 cellspacing 数值（无单位） 单元格和单元格之间的距离，默认2像素 cellpadding 数值（无单位） 单元格和内容之间的距离，默认1像素 05. table表格构成：注意：table表格构成不支持合并； 标签名 名称 thead 表格头部 tbody 表格主体 tfoot 表格底部 06. 合并表格 写在tr&#x2F;th单元格里面 步骤: 1.明确合并方式 2.通过左上原则确定保留谁删除谁 3.给保留的单元格设置rowspan或colspan 多行多列合并 先合并列 再合并行 再删除多余的 不能跨结构合并单元格 属性 属性值 应用 rowspan 跨行合并（垂直方向） 保留最上的，删除其他的 colspan 跨列合并（水平方向） 保留最下的，删除其他的 07. 快捷键alt+shift点点&#x2F;按住鼠标滚轮向下拖 可同时选中竖列 shift+alt+F自动格式化 ctrl+shift +左右箭头可以在选中多行的时候移动光标 tab缩进 shift+tab向前缩进 快捷方式 table&gt;tr*&gt;td*2 08. input书写方式 09. 表单域：form会把它范围内的表单元素信息提交给服务器. 属性 属性值 作用 action url地址 链接处理表单服务器的url地址 method get 显示信息 &#x2F; post 不显示信息 设置表单提交方式 name 表单名 区分同个页面的多个表单域 10. input 属性 号 属性 描述 1 type 元素的类型 2 name 名称 3 value 显示的文本值 5 checked 默认选中项 6 maxlength 设置字符个数 7 placeholder 占位符-提示语（当编辑的时候文字消失，不编辑的时候文字还原） 9 multiple 多个文件上传，需要：type&#x3D;”file” 搭配使用 10 required 必须填写内容不能为空 11 autofocus 自动获取焦点 12 autocomplete 用户输入信息并提交成功之后，会留下记录； 默认是on 开启的 off 关闭，注意急需要在表单内添加name属性名 11. type 属性 号 类型 含义 1 text 文本框 2 password 密码框 3 radio 单选按钮 4 checkbox 复选框 5 button 普通按钮（默认无功能，配合js添加功能使用） 6 submit 提交按钮（提交数据给后端服务器） 7 reset 重置按钮（点击之后恢复表单默认值） 8 image 图片按钮， 需要和src搭配使用 9 file 上传单个文件按钮 10 email 邮箱（邮箱格式） 11 url 网址 12 date 日期 13 time 时分秒 14 number 数字 15 tel 手机号（纯数字） 16 search 搜索 17 color 颜色按钮 12. 下拉菜单：select&gt;optionselected默认选中 13. 文本域：textarea 14. 增加点击范围：label注意：需要和input标签搭配使用 15. 按钮标签：button 16. 单选框实现单选一的效果设置相同的name属性值 checked默认选中 17. 无语义化标签（盒子布局标签） 标签 说明 div 独占一行，属于块级元素，可以设置宽高 span 一行可占多个，属于行内元素，不可以设置宽高 18. 有语义化标签注意：有语义化标签是针对于搜索引擎使用，可以多次使用，一般用在移动端口； ​ 其中在IE9中不兼容问题导致是行内元素，需要把这些元素转换为块级元素即可； 标签名 语义 header 头部 nav 导航 footer 底部 aside 侧边栏 section 定义某个文档区域–块级元素 article 内容 19. 特殊字符标签： 标签 说明 &amp;nbsp； 空格 &amp;lt； 小于号 &amp;gt； 大于号 CSS层叠样式表day0101. css层叠样式表给页面中的HTML标签设置样式使用 {}包含一个或多个样式声明；每条样式声明以键值对形式出现：属性: 值；属性和值之间使用 : 分隔 每个样式写完之后使用;结束 标点符号都是英文状态下的 02. css引入方式内嵌式(style标签里) 外联式(link标签引入) 行内式(标签的style属性中) 行内式 说明：写在html标签中，针对当前标签，一般配合js搭配使用 内嵌式 说明：写在head里面和title标题下面，针对于当前页面 外链接式 说明：先新建一个css文件，然后到html文件–head标签里面写上link链接；针对于多个页面使用 03. 标签选择器 标签{属性:属性值;} 04. 类选择器 .类名{属性:属性值;} 如: 每个标签都可以设置class属性, class&#x3D;”类名” 以点+类名的形式显示类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头 05. id选择器id名{属性:属性值;} 如 在一个页面中是唯一的，不可重复的 以#开头 06. 通配符选择器: 基础选择器 优点 缺点 使用情况 用法 标签选择器 快速选出所有相同的标签 不能选择其中一个 较多 标签名{ } 类&#x2F;多类选择器 可以选出1个或多个标签 根据需求选择 非常多 . class名{ } id选择器 一次只能选择1个标签 只能在html设置一次 和js搭配使用 #id名{ } 通配符选择器 选择所有的标签 选择的太多，有部分不需要 特殊情况使用 * { } 07. 字体样式 font-size(px) font-weight(400&#x2F;700) font-style(normal italic) font-family(Microsoft YaHei sans-serif) 属性 作用 说明 font-size 字体大小 px 像素 font-family 字体样式 各种字体，可以写多个，字体之间用空格隔开 font-style 字体倾斜 italic 倾斜 、normal 不倾斜 font-weight 字体粗细 bold &#x3D; 700 加粗 、 normal &#x3D; 400 不加粗，取值100–900，数字后面没有单位； font： 字体连写 font: style weight size &#x2F;line-height family;注意：必须遵守前后顺序，其他的可以忽略掉,但是必须写字体大小和样式 08. 文本样式:文本 span标签、a标签、input标签、img标签等行内和行内块元素要水平居中 text-align : center 需要给以上元素的 父元素设置 属性 作用 说明 color 字体颜色 px text-indent 首行缩进 em&#x2F; 数值 1em &#x3D; 1个字符 ( text-indent: 2em; ) text-align 水平对齐方式 left 左对齐 &#x2F; center 居中对齐 &#x2F; right 右对齐 text-decroation 文本装饰 overline 添加上划线 &#x2F; underline 添加下划线 none 删除下划线 &#x2F; line-through 添加删除线 line-height 行高 px&#x2F;数值倍数 (上间距+文本高度+下间距) line-height&#x3D;height 单行文字垂直居中 09. margin : 0 auto可以通过margin : 0 auto ; 给 div、p、h(大盒子) 块级元素水平居中 独自占一行的标签 要先给宽度 如果大盒子没有设置宽度，此时会默认占满父元素的宽度 10. Chrome调试工具叹号报错 删除线层叠或注释 注释前面没有对钩 11. 常见颜色取值 rgba(a 0-1取值) 关键词 十六进制 day0201. 后代选择器说明：选择子孙后代，中间用空格隔开 02. 子代选择器说明：选亲儿子元素.用**&gt;（大于号）** 03. 并集选择器说明：通常用于集体声明，和的意思，元素之间用逗号隔开； 注意：并集选择器需要竖排编写，最后一个元素不需要添加逗号； 04. 交集选择器说明：a) 由两个选择器构成， 第一个必须为标签选择器，第二个为class&#x2F;id选择器，针对某个标签设置； ​ b) 没有任何符号，连在一起的；即…又…的意思 05. 链接伪类选择器符号： :(英文冒号) 注意：为确保样式生效，必须按照:link &#x2F; :visited &#x2F; :hover &#x2F; :active顺序编写；一般情况下使用:hover即可；任何元素都可以设置； 06. 结构伪类选择器符号： :(英文冒号) 权重是：0,0,1,0 n 如果是数字 就是选择第 n 个子元素 里面数字从1开始 如果n是公式从0开始计算 元素名 作用 :first-child 匹配父元素的第一个元素（同一种类型的子级） :last-child 匹配父元素的最后一个元素（同一种类型的子级） :nth-child(n) 匹配父元素的第n个元素，从头开始（同一种类型的子级） :nth-last-child(n) 匹配父元素倒数第n个元素，末尾开始（同一种类型的子级） 注意：(n) 分为数字、关键词（even偶数&#x2F;odd 奇数)、公式（注意n是从0开始）、单独写n代表全部 :nth-of-type(n) 指定同类型第n个 :nth-last-of-type(n) 指定同类型倒数第n个 :first-of-type 指定同类型的第一个 :last-of-type 指定同类型的最后一个 区别： nth-child ： 对父元素里面所有的孩子进行排序，nth-of-type: 对父元素里面指定同类型元素进行排序选择，先匹配元素，再找第n个孩子 首先看 E 指定的元素，之后再去看 :nth-of-type的第几个孩子 07. :focus 获取焦点的表单元素伪类选择器符号： :(英文冒号) 注意：需要和input表单属性搭配使用； 08. :: placeholder 占位符伪元素选择器符号： ::(两个冒号) 注意：需要和input表单属性一起搭配使用； 09. 属性选择器注意：[] 中括号里面的值可以是双引号&#x2F;单引号；属性选择器的权重是0,0,1,0 选择器 含义 选择器[属性] 存在属性即可 选择器[属性&#x3D; “值”] 属性值完全等于值 选择器[属性 *&#x3D; “值”] 任意元素值 选择器[属性 ^&#x3D; “值”] 开始元素值 选择器[属性 $&#x3D; “值”] 结束元素值 10. 伪元素选择器::before &#x2F; ::after 权重是0,0,0,1 a ）选择器**::before** 在选择器内部的开始位置创建一个元素，为行内元素，必须要和 content属性使用。 b ) 选择器**::after** 在选择器内部的结束位置创建一个元素，为行内元素，必须要和 content属性使用。 c ) ::before 、 ::after 伪元素 注意事项： ​ 伪元素:before和:after添加的内容默认是行内元素； ​ 两个伪元素的content属性，表示伪元素的内容,设置:before和:after时必须设置其**content属性**，否则伪元素就不起作用。 ​ input img不支持伪元素 11. 选择器总结 选择器 作用 符号 后代选择器 子孙后代 空格隔开 子代选择器 选亲儿子 **&gt;(**大于号) 并集选择器 和的意思 **,**（英文逗号） 交集选择器 即….又…的意思 没有任何符号，连在一起写 伪类选择器 分为：链接&#x2F;结构&#x2F;获取表单元素焦点 :（英文冒号） 属性选择器 选取html属性值 [ ] (英文中括号) 伪元素选择器 必须和content搭配使用，否则无效 ::(两个冒号) 12. emmet语法 13. 背景颜色：background-color 14. 背景图片：background-image 15. 背景平铺：background-repeat 16. 背景位置：background-position 说明 说明 单位： px % 方向词 左：left 右：right 上：top 下：bottom 居中：center 1个值：其中固定的是居中 2个值：先左右水平位置 后上下垂直位置 方向名词没有前后顺序 单位有前后顺序，先是x 左右水平 后是y上下垂直 单位词和方向词可以混合编辑，分为先x 后y 混合单位(第一个取值水平，第二个取值垂直)方位名词可换顺序 精确单位(数字+px)和混合单位不可以 方位名词省略第二个默认居中 只指定一个数值 是X 另一个默认居中 17. 背景滚动&#x2F;固定：background-attachment 18. 背景综合写法注意：属性是没有前后顺序区分的，推荐使用下方编写； 19. 背景透明度：rgba透明取值：0~1之间，取值越小越透明； 写法：0.3 或者是 .3 20. 背景总结 背景图和背景色在盒子里不会溢出 属性 说明 背景颜色：background-color 颜色值&#x2F;十六进制&#x2F;rgb 背景图片：background-image url(图片路径) 背景平铺：background-repeat 平铺：repeat 不平铺：no-repeat x轴：repeat-x y轴：repeat-y 背景位置：background-position 分别是x和y坐标， 单位是px 和 方向名词 背景滚动：bakcground-attachment 背景滚动：scroll（默认） 背景固定：fixed 背景简写：bakcground: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 color image repeat attchment position 背景色半透明：background:rgba(red,green,blue,0~1)， 0~1透明色取值范围，取值越小越透明 21. img和背景图片区别 img标签可以撑开盒子,背景图片不可以撑开盒子(需要设置盒子的宽高) 22. 元素分类块级元素: 独占一行（一行只能显示一个） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高 可以存放其他行内元素和块级元素和文本 行内元素: 一行可以显示多个 宽度和高度默认由内容撑开 不可以设置宽高 只能容纳文本或其他行内元素 行内块元素: 一行可以显示多个 可以设置宽高 如input button textarea img 23. 元素显示模式：display注意：三个元素可以相互转换： 行内转块级&#x2F;行内转行内块&#x2F;块级转行内块 元素名 属性 说明 display : block; 块级元素 独占一行，可以设置宽、高、内外边距，默认宽度是100% display : inline; 行内元素 一行占多个，不可以设置宽高，默认宽度就是内容的宽度 display : inline-block; 行内块元素 一行占多个，可以设置宽、高、内外边距默认宽度就是内容的宽度，盒子中间有间距 行内元素或块级元素转换成行内块元素若没有设置宽度和高度默认由内容撑开 24. css三大特性 CSS层叠性（就近原则） ​ a) 设置样式冲突时，遵循的是就近原则。（哪个样式离html近，就执行哪个样式） ​ b) 样式不冲突时，不会层叠，共同作用在标签上(前提选择器优先级相同) 。 CSS继承性（子承父业） ​ a) 指在父级书写CSS样式表时，子标签会继承父标签的某些样式（子承父业） ​ b) 可以继承元素：text-，font-，line-开头元素，color属性。 ​ c) 继承失效元素：a标签的颜色，h标题系列的大小、div盒子的高度但是宽度有类似于继承的效果； css优先级（等级） 权重叠加 不会有进位问题 贡献值（由小到大排序） 权重值 注意 继承元素 、*通配符选择器 0,0,0,0 1.权重可以叠加 标签选择器、伪元素选择器 0,0,0,1 2.数位之间没有进制 .类、：伪类选择器、[xx]属性选择器 0,0,1,0 3.值从左到右，从大到小依次排序 #ID选择器 0,1,0,0 4.!important 无穷大给父级元素添加无效 行内样式 1,0,0,0 5.∞给继承的选择器添加等级是无效的 !important（需要在样式属性值后面写）如：color : red!important; ∞ 无穷大 6. !important不能加在继承 写在;前 25. 去除列表默认样式给ul设置 list-style:none 属性， 26. 解决行内块元素之间默认间隙给父元素加font-size: 0; html行内或行内块元素不让换行 day0301. 盒子的组成content padding border margin 02. 边框复合写法 03. 内边距边框与内容区域 之间的距离 边框和内边距会撑大盒子 box-sizing: border-box; 解决边框和padding会撑开盒子的问题 一般导航栏 给a转成块级元素或者行内块设置高&#x2F;行高 不给宽用padding撑开盒子宽度 04. 外边距盒子与盒子之间的距离 05. 外边距折叠现象–合并现象垂直布局的块级元素上下的margin会合并 解决方法只给其中一个盒子设置margin 06. 外边距折叠现象–塌陷现象互相嵌套的块级元素，子元素的margin-top 会作用在父元素上解决方法: 07. 不会撑大盒子的特殊情况(块级元素) 子盒子没有指定宽度和高度 子盒子宽度默认就是父盒子的宽度 此时padding或者border不会撑大盒子 08. 行内元素的margin和padding无效情况 水平方向有效：设置左右的外边距和内边距是有效的 垂直方向无效：设置上下的外边距和内边距是无效的（想要垂直方向有效，必须转换为块级和行内块元素） magin padding 无法改变行内标签的垂直位置 可以通过行高改变 检查的时候 magin padding 会存在 但不改变位置 day0401. 浮动：早期作用：文字环绕 现在主要用于让垂直布局的盒子变成水平布局 02. 浮动特点浮动元素会脱离标准流(脱标) 浮动元素比标准流高半个级别，可以覆盖标准流中的元素 浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动 浮动元素会受到上面元素边界的影响 浮动元素会一行显示并且元素顶部对齐,可以设置宽高(行内块相似) 如果父级盒子宽度不够，子级的盒子浮动会自动换行 说明： 行内、块级元素只要加了浮动都会具有行内块元素特点，可以设置宽高，若是没有给盒子设置宽高，则以内容大小为准： 03. 清除浮动方式 清除浮动方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差 父级overflow:hidden; 书写简单 溢出隐藏 父级 :after伪元素 结构语义化正确 由于IE6-7版本不支持:after，兼容性问题 父级双元素 (:before :after ) 结构语义化正确 由于IE6-7版本不支持:after，兼容性问题 04. css书写顺序先放浮动定位 再放盒子模型 再放文字样式 建议遵循以下顺序： 布局定义属性：display&#x2F;position&#x2F;float&#x2F;clear&#x2F;visibility&#x2F;overflow(建议第一个写display) 自身属性：width&#x2F;height&#x2F;margin&#x2F;padding&#x2F;border&#x2F;background…. 文本属性：color&#x2F;font&#x2F;text-decoration&#x2F;text-align&#x2F;vertical-align&#x2F;white-space&#x2F;break-word…. 其他属性(CSS3) :content&#x2F;cursor&#x2F;border-radius&#x2F;box-shadow&#x2F;text-shadow&#x2F;background:linear-gradient… day0501. 项目规范写项目要建根目录 里面放该项目图片文件夹 css文件夹等 index是首页 写网页遵循从上到下，从里到外的原则 若一个区域是纯文字区域可以不给宽 用padding撑开 一般导航栏 给a转成块级元素或者行内块设置高&#x2F;行高 不给宽用padding撑开盒子宽度 02. 图片垂直居中 day0601. 网页布局组成 标准流 浮动 定位 02. 定位组成定位 &#x3D; 定位模式 + 边偏移 边偏移 left 和 right同时有会执行left top和bottom同时有执行top 属性1 属性2 属性3 属性4 顶端偏移：top 底部偏移：bottom 左侧偏移：left 右侧偏移：right 03. 定位模式 相对 绝对 固定定位; ① 静态定位：static(标准流) 特点： 相对于标准流摆放位置，没有边偏移； ② 相对定位：relative（自恋型-不脱标） 特点： 不脱标，保留原位置； 相对于自己原来的位置移动（以左上角移动）； 通常是给绝对定位当爹来使用； ③ 绝对定位：absolute（拼爹性-完全脱标） 特点： 完全脱标，不占用原先位置； 具备行内块特点 需要配合方位属性实现移动 若是没有给父元素添加定位，则以浏览器为准； 若是父元素有定位（相对、绝对、固定定位），则以最近的父元素并且带有定位属性为准； 子绝父相：因父亲要占有位置，所以是相对定位，子盒子不需要占有位置，则是绝对定位； 绝对定位盒子居中：（因绝对定位的盒子不能通过margin实现水平居中） ​ a）left&#x2F;top：50%；先让父盒子50%移动到中心位置； ​ b）margin-left&#x2F;top：-盒子一半值，然后盒子走自身大小的一半负值； ​ 或者直接设置位移属性，transform:translate(-50%,-50%); ④ 固定定位：fixed（认死理型） 特点： 完全脱标，不占有原先位置； 以浏览器的可视窗口为准（浏览器显示的大小） 和父元素没有任何关系，不能跟随滚动条滚动 具备行内块特点 尽量设置宽度高度或者内容 小技巧：固定在版心右侧位置： ​ a ）让固定定位的盒子left：50%，走到浏览器可视区的一半位置； ​ b ）再让固定定位盒子margin-left：版心宽度的一般距离即可； ⑤ 粘性定位：sitcky 特点： ​ 以浏览器的可视窗口为移动元素（固定定位特点） ​ 不脱标，占有原先位置（相对定位特点) ​ 必须添加其中一个边偏移属性才有效（top、bottom、right、left） ​ 跟页面滚动搭配使用，兼容性较差，IE目前不支持此功能； 04. z-index :叠放次序层级关系：标准流 &lt; 浮动 &lt; 定位 相对、绝对、固定默认层级相同 html中后面的会覆盖前面的 说明： ① 默认是auto&#x2F;0，取值：正整数、负整数、0，后面不能添加单位； ​ ② 取值越大，定位元素在层叠元素中越居上（里外）； ​ ③ 如果属性值相同，则按照书写顺序，后来者居上制定； ​ ④ 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性; 05. 定位特殊性绝对定位absolute 、 固定定位fixed 、浮动float 类似 ① 行内元素添加绝对定位&#x2F;固定定位，是可以直接设置高度和宽度； ② 块级元素添加绝对定位&#x2F;固定定位，若不给宽度和高度，默认大小是内容的大小； 06. 脱标的盒子不会出发外边距塌陷说明：浮动元素、绝对定位、固定定位元素都不会出发外边距合并的问题。 07. 绝对定位&#x2F;固定定位会完全压住盒子① 浮动元素： 只会压住它下面的标准流盒子，不会压住下面标准流盒子里面的文字&#x2F;图片；（因浮动最初是为了做文字环绕效果） ② 定位元素：绝对定位&#x2F;相对定位会完全压住下面标准流所有的内容； 08. 总结 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 不脱标，占有位置 可以 相对自身位置移动 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置 固定定位fixed 完全脱标，不占有位置 可以 浏览器可视区 粘性定位sticky 占有位置 可以 浏览器可视区 09. 行内&#x2F;行内块元素垂直对齐方式 可以解决: 10. 圆角边框 方向名词：标签 属性个数：border-radius:xxx; 左上角：border-top-left-radius 1个值：四角 右上角：border-top-right-radius 2个值：左上角&#x2F; 右下角 右上角&#x2F;左下角（x号） 左下角：border-bottom-left-radius 3个值：左上角 右上角&#x2F;左下角 右下角 右下角：border-bottom-right-radius 4个值：左上角 &#x2F; 右上角 &#x2F; 右下角 &#x2F; 左下角 11. 显示隐藏：display特点： 隐藏之后不占有原来位置，和js搭配使用网页特效； 12. 显示隐藏-可见性：visibility特点：隐藏之后继续占有原先位置 13. 溢出显示隐藏：overflow本质：让一个元素在页面中隐藏或者显示出来 13.1多行文本溢出省略 注意： 一般情况下，我们不像让溢出的内容显示出来，因为溢出的部分会影响布局； ​ 但是若有定位的盒子，请慎用overflow：hidden； 因为它会隐藏多余的部分； 属性 说明 visible 溢出显示（默认） hidden 超出部分溢出隐藏，不显示滚动条 scroll 超出&#x2F;不超出都显示滚动条 auto 超出显示滚动条，不超出不显示 14. 总结 属性 区别 display 显示隐藏元素，不保留位置 visibility 显示隐藏元素，占有原先位置 overflow 溢出显示隐藏，只是对于溢出来的部分进行处理 15. 元素整体透明度 16. 表格边框合并 17. 小三角设置一个盒子四周不同颜色的边框 将盒子宽高设置为0仅保留边框 得到四个三角形 选择其中一个后 其他边框设置颜色为透明transparent 18. css用户界面样式 鼠标样式：cursor 特点：设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 轮廓线：outline 特点：针对于表单控件的边框使用,去掉默认的蓝色边框。 防止拖拽文本域：resize 特点：针对于html里面的textarea文本域使用 day0701. 精灵图步骤:设置盒子大小为图片大小 设置精灵图为盒子的背景图片 给背景图background-position：x y;(一般xy是负值) 一般精灵图标签用行内标签 加宽高要转模式 02. 背景图片大小：background-size 取值 场景 数字+px 简单方便，常用 % 百分比 相对于当前盒子自身的宽高百分比 contain 包含：将图片等比例缩放，直到不会超出盒子的最大 可能有部分空白区域（一旦宽度或高度满足其中一项就停止拉伸） cover 覆盖：将图片等比例索芳芳，直到刚好填满整个盒子没有空白 可能有部分背景图片显示不全 03. 盒子阴影：box-shadow注意：盒子阴影不占用空间，默认是外边距（outset）不能写，否则无效； ​ h-shadow：水平阴影 、v-shadow ： 垂直阴影必写，其他属性值可以忽略； 属性值 描述 h-shadow 水平阴影（x轴） 允许负值 v-shadow 垂直阴影（y轴） 允许负值 blur 模糊距离（里外） spread 阴影尺寸（大小） color 阴影颜色 inset 内部阴影 04. 文字阴影注意：h-shadow：水平阴影 、v-shadow ： 垂直阴影必写，其他属性值可以忽略； 属性值 描述 h-shadow 水平阴影（x轴） 允许负值 v-shadow 垂直阴影（y轴） 允许负值 blur 模糊距离(里外) color 阴影颜色 05. 过渡:transition口诀：谁做过渡给谁加； 说明：可以写多个属性，利用逗号进行分割即可； 注意：一般情况下是直接给过度属性的名称+all即可；记得在花费时间添加单位s，否则无法生效； 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 过渡 属性的名称。（必写） transition-duration 花费的时间。（必写）默认是 0 transition-timing-function 运动曲线样式。 ease –低速开始-加快-变速(默认) linear -匀速 ease-in-加速（高速结束） ease-out-减速 （低俗结束） ease-in-out-先加速后减速 transition-delay 何时开始。默认是 0。（忽略） 06. SEO 三大标签-搜索引擎优化SEO：搜索引擎优化 作用：让网站在搜索引擎上的排名靠前： 提示SEO常见方法： 1.竞价排名 2. 将网页制作html后缀， 3. 标签语义化（在核实的地方使用合适的标签） seo三大标签： 注意：需要写在head头部标签里面 ① title:网页标题标签 ② description ： 网页描述 ③ keywords ： 网页关键词 07. ico图标 在线生成ico图标： day0801. 常用类名shortcut 快捷菜单 wrapper版心 prev上一个 next下一个 current&#x2F;active 当前的 02. logo做法h1&gt;a a里面放文字 h1设置fontsize:0 a转换成块元素背景图放logo 若行内或行内块和文字无法通过行高和**vertical-align:middle;**对齐 就用定位 03. banner图做法banner用ul&gt;li&gt;a&gt;img的形式放banner图 ol&gt;li 做下面的小圆点 04. 水平 垂直居中总结text-align 可控制文本在元素内部的位置; 可以让行内元素、行内块元素在父亲盒子中居中，text-align对块元素是无效；浮动的盒子具备行内块的特点但不能用 text-align使盒子居中,也不能用margin:0 auto居中margin:0 auto设置有宽的块级元素的居中 line-hight&#x3D;height 可以让单行文本垂直居中, 可结合vertical-align:middle让图片垂直居中,盒子垂直居中用margin或定位 05. min-height用于设置盒子的最小高度 超过会撑开盒子 06. 字体图标：iconfont网址： a ）icomoon 字库 （外国网站） b ) 阿里 iconfont 字库（免费）  存放位置：下载好的字体库，单独把fonts文件夹拎出来放在网页的同一个文件夹，注意下载的字体包不要删 阿里 iconfont： iconfont网站上传矢量图: SVG矢量图(放大缩小不会失真)—-上传—-去除颜色并提交 07. 单行文本溢出显示省略号：text-overflow 08. 常见布局技巧margin负值运用：针对于盒子边框合并问题 说明： ① 让盒子设置margin负值移动正好压住相邻的盒子边框； ​ ② 鼠标经过盒子的时候，若是有定位，择使用z-index：数值;层叠性来设置 ​ ③ 鼠标经过盒子的时候，若是没有定位，择使用relative相对定位压住盒子即可； 文字环绕浮动元素： 说明 ：因浮动最初是为了做文字环绕效果，盒子浮动之后只会压住盒子，不会压住文字。 行内块运用： 说明：直接是可以给父元素添加text-align：center;文本直接居中对齐即可，不需要添加margin，因无效。 day0901. 滤镜（模糊）：filter 02. calc 函数calc() 声明css属性值时执行一些计算，注意括号里面可以写 + - * &#x2F;来进行计算； 03. 移动：translate改变盒子位置: 定位 外边距 位移 注意： 沿着x 和y轴移动元素，对行内标签没有效果。 ​ translate中的百分比是相对于自身元素移动位置，而不是浏览器的百分比； 优点：不会影响到其他的盒子（占原位置，不脱标） 04. 旋转：rotate说明：单位是deg，正数–顺时针， 负数–逆时针，默认以旋转的中心点旋转； 05. 旋转位置: transfrom-origin注意： 注意x 和 y 之间用空格隔开，默认是以50%中心点位置；则谁设置移动位置则给谁加；常用方位名词 单位： px –像素 % 百分比 方向名词（left 左 、 right 右 、 center 中心、top 上 、 bottom 下） 06. 倾斜 skew 单位: deg 07. 缩放：scale注意：x y 之间用逗号隔开 ，默认是1倍；写一个数值则是等比例缩放 单位：**数字 &#x3D; 倍数(没有单位)**， 0-1&#x3D;缩小 &gt;1 &#x3D; 放大 ，0缩小到没 负数先缩小再颠倒后放大 默认放大是1倍； 优势：默认以中心店缩放或者是放大盒子，是不会影响其他盒子的； 07. 2D综合写法注意：有顺序的，需要按照下方来编写；记得位移必须写在最前面。 08. 线性渐变方向： left 左 right 右 top 上 bottom 下度数： 0—360° 顺序是： 下 左 上 右（顺时针） 注意：可以写多个方向数值，以及多个颜色，以及to引用, 用逗号隔开 说明： to right 意思是，结束到右边 多种颜色渐变： 09. 径向渐变说明：颜色从内到外进行圆形渐变 注意：要加-webkit-;否则chrome不生效； 移动web 移动webfont字体图标 特征：可以设置大小以及颜色，不会失帧；网页中的一些小图标可以使用 国内网站 阿里巴巴 iconfont （常用）需要注册才能下载上传素材，加入购物车后添加项目再下载 使用：下载后的文件中包含 iconfont.css文件，将其引入之css中，然后给元素类名格式为 iconfont icon-…… 国外网站  （作为了解） 使用：下载后在css文件中加入引用的字体声明属性，每个元素也要加字体声明属性，粘贴复制在html中显示未带问号的方框 平面转换transform 的各种用法 transform 要配合transition 使用，来达到缓慢过度的效果 例： transition: all 2s; 位移：需要添加定位属性，transform: translate(x,y) 可以是像素，也可以是%（%是取决于自身的宽高） 利用绝对定位达到居中 &#x2F; 若有放大或者其他 transform效果需要复写（hover中一样），否则属性不体现 &#96;&#96;&#96;htmlposition: absolute;top: 50%;right: 50%;transform: translate(-50%, -50%) 透明度属性 opacity 0，为透明，常用于隐藏当前盒子或者遮罩（类名mask）使用，在hover 中为 opacity 1， 再体现出来 ； 也可以配合overflow: hidden;和transform: translate(x,y)来达到沿着某一方向出现的效果 渐变色 3D转换位移&#x2F;&#x2F;&#x2F;旋转 穿透效果，近大远小 空间旋转掌握握拳方法判定旋转方向，顺正逆负 动画复合写法：animation:动画名称 动画时长 速度曲线 延迟执行时间 重复次数 动画方向 执行完毕时状态;animation: name1 duration 逐帧动画（steps (number) ） timing-function delay iteration-count direction fill-mode, name2 3s linear forwards; 调用上面name，一个盒子可以调用多个动画name实现同一个目标进行不同的动画效果！！！ 调用属性@keyframes name { 动画效果进度可以 from…to…&#x2F;&#x2F;&#x2F; 0%~100%,{里面可以设置需要的移动方式，例：（背景图&#x2F;精灵图做加载条&#x2F;轮播效果）background-position: -1680px 0; transform: translate(px&#x2F;%);left:px……} 无缝动画在动画完成一次循环之后，有空白区域，在最后加几张开头相同的目标（尺寸刚好填满空白区域即可），使其填充代替空白区域。 百分比布局宽百分比，高固定,也称流式布局&#x2F;弹性布局（老式布局方式） 特点：避免出现浮动脱标问题，适合结构化布局 Flex布局移动端组成：弹性容器 &#x2F; 弹性盒子 &#x2F; 主轴 &#x2F; 侧轴使用方式 给父元素设置 display:flex，子集会水平排列 主轴对齐方式：要和display:flex写在一起，在父容器中 属性 值 描述 justify-content: flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 只在子集之间！子集之间的间距是均分父集剩余的空间 space-around 子集的间距是父集到子集间距的2倍 space-evenly 子集到父集&#x2F;子集之间的间距一致 侧轴对齐方式：要和display:flex写在一起，在父容器中 属性 值 描述 align-items stretch 子集没有设置具体高度时，项目被拉伸以适应容器。 center 中心元素在容器内。 flex-start 位置元素在容器的开头。 flex-end 位置元素在容器的末端。 baseline 位置元素在容器的基线。 子元素设置，直接写在子元素内， flex: 1; 子元素需要多少大小占比就写多少，不加单位 ，子集不设置高度则一般和内容大小一致 修改主轴方向： flex-direction: ; row 水平向左 row-reverse 水平向右 column 竖直向下 column-reverse 竖直向上 弹性盒子换行： 调整对齐方式：适用于多个盒子使用 属性 值 描述 align-content stretch 子集没有设置具体高度时，项目被拉伸以适应容器。 center 中心元素在容器内。 space-between 只在子集之间！子集之间的间距是均分父集剩余的空间 space-around 子集的间距是父集到子集间距的2倍 flex-start 位置元素在容器的开头。 flex-end 位置元素在容器的末端。 baseline 位置元素在容器的基线。 space-evenly 子集到父集&#x2F;子集之间的间距一致space-evenly rem的使用步骤：​ 1、网页跟标签 html 设置字号大小 ​ 2、使用rem单位 ​ 一个rem(37.5)&#x3D;一个根标签html字体大小&#x3D;1&#x2F;10可视窗口大小（当前标准375来计算），盒子的尺寸由 rem * 字号大小 来决定 ( body中设置字号无效) ​ 3、使用 vw 或 vh 单位 ​ vw(3.75)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;vh(6.67) 用法与rem相似，取值于标准宽高(375,667) ​ ！！！记得要引入 js 文件 媒体查询特点：根据可视窗口的宽来调整根标签的样式；适应不同尺寸屏幕显示不同布局 less文件脚本css的预处理器；自建.less文件 会自动生成对应的.css文件 less计算，除法需要放在括号内&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;多个单位参与计算，只取第一个 变量特点：存储数据，方便使用、修改&#x2F; 一个less文件可以用多个变量 导入less 导出less 禁止导出less第一行写 out:false bootstrap使用可用插入font、引入写好的代码块 例：栅格系统，响应式布局随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 屏幕的类取值 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C .container 最大宽度 None （自动） 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列（column）数 12 12 12 12 最大列（column）宽 自动 ~62px ~81px ~97px 槽（gutter）宽 30px （每列左右均有 15px） 30px （每列左右均有 15px） 30px （每列左右均有 15px） 30px （每列左右均有 15px） 可嵌套&#x2F;偏移（Offsets）&#x2F;列排序 是 是 是 是 例：font引入，类似于iconfont的使用 例：轮播图JS插件步骤 JQ与DOM类名操作对比 web jQuery Dom对象.classlist.add() 添加 JQ对象.addClass() Dom对象.classlist.remove() 删除 JQ对象.removeClass() Dom对象.classlist.toggle() 切换 JQ对象.toggleClass() Dom对象.classlist.contains() 验证有无 JQ对象.hasClass() 修改透明度 JQ动画效果 JQ的排他思想 链式编程 JQ操作样式之css方法 JQ默认遍历，可以直接根据下标来选择 JS进阶 作用域l链：作用域链实质：变量查找机制 从当前触发向上逐级寻找 子可找父，父不能找子 垃圾回收(GC)：垃圾回收器自动回收 不使用的内存 内存三阶段：分配 使用 回收 全局变量关闭页面回收 局部变量用完立刻就回收 引用计数：有缺点，弃用 引用次数为0时，回收； 嵌套引用，相互引用不会为0，无法被回收，会引起内存泄漏问题 标记清除法 从根部出发，找不到&#x2F;无法达到的 都清除 不再使用的对象定义为无法达到的对象 闭包闭包&#x3D;内层函数+外层函数的变量（要有两个函数且是嵌套关系） # 里面的函数访问到外部作用域的变量 作用：封闭数据，供引用，外部可以访问使用函数内部变量；数据私有化，保护数据安全（防止污染） 风险：内存泄漏 解决方案： 定义接收的函数赋值&#x3D;null（其他值） 变量提升 动态参数 展开运算符 箭头函数 数组解构需要加分号情况：立即执行函数、数组结构[ ]开头的 对象结构 数组&#x2F;对象遍历方法 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 构造函数构造函数是专门用于创建 对象的函数，如果一个函数被使用 new + 首字母大写 关键字 调用，那么这个函数就是构造函数。 总结： 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 () 构造函数的返回值即为新创建的对象 构造函数内部的 return+简单数据类型 返回的值无效！return+复杂类型数据可以反出！ 注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。 1.2 实例成员通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 总结： 构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象、 实例成员增加的实例成员自己用，静态成员不能使用，反之同理。 1.3 静态成员在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数1.Object 原型对象 构造函数-原型对象-对象原型 关系 字符串处理方法 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 数组求值方法 伪数组转真 购物车案例 面向对象面向对象编程是一种程序设计思想，它具有 3 个显著的特征：封装、继承、多态。 1 封装封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。 总结： 构造函数体现了面向对象的封装特性 构造函数实例创建的对象彼此独立、互不影响 命名空间式的封装无法保证数据的独立性 1.2 继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 更改this指向call 直接更改 this 指向， 传入的是普通参数，调用函数apply 直接更改 this 指向， 传入的是数组，调用函数bild，方法并不会调用函数，而是创建一个指定了 this 值的新函数 报错预处理 递归函数 &#x2F;&#x2F;递归函数：函数在自己内部调用自己 浅拷贝 只拷贝地址，和第一层的方法和属性，如果里层还有对象则不会拷贝到 拷贝出来的对象和原数据还会有影响的(内层的数据) 深拷贝 &#x2F;&#x2F; 深拷贝怎么实现？ 优点：通过深拷贝出来的新对象不会影响旧对象 1.深拷贝用到函数递归 2、通过引入 ladash.js 文件中的_.cloneDeep() 3、JOSN（先转为字符串再转回对象）也可以实现 节流、防抖节流：控制频繁触发事件的频率，一个时间内只发生一次 防抖：平凡触发的事件，只会执行最后一次 综合：本地存储播放记录 JS基础 书写位置​ 外部，在结束的 body 标签上方直接引入 ​ 内部，写在body标签中。 ​ 行内配合btn使用。 输出方式 输入填表案例，配合变量使用 变量 数组 模板字符串 常量 字面量转化 赋值计算 逻辑运算符 自增运算 比较运算 三元运算 switch while for循环 遍历数组看到数组就要想到把它用 for 遍历 删加 取极值 筛选数据 函数命名规则与变量相同， 函数表达式 立即执行函数 对象 便利对象 便利数组对象 作用域 逻辑中断 Webapi将整个网页作为对象，Document是最大的对象，使用Document对网页内容操作实质上跟操作对象是一样的 实现过程选取对象，实行操作！！！！ 基础操作 伪数组 class修改 回调函数把一个函数作为参数传给另一个函数，该函数为回调函数 Ajax01. URL地址的组成部分 客户端与服务器之间的通信协议 存有该资源的服务器名称 资源在服务器上具体的存放位置 02. 客户端与服务器的通信过程 客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤 03. 网页中如何请求数据 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象 最简单的用法 const xhr &#x3D; new XMLHttpRequest() 04. 资源的请求方式 get 请求通常用于获取服务端资源（向服务器要资源） post 请求通常用于向服务器提交数据（往服务器发送资源） 05. Ajax概念 Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML） 在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax Ajax能让我们轻松实现网页与服务器之间的数据交互 06. jQuery中的Ajax 浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数 jQuery 中发起 Ajax 请求最常用的三个方法如下： $.get() $.post() $.ajax() 07. $.get()函数的语法 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 08. $.post()函数的语法 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 09. $.ajax()函数的语法 10. 接口 概念: 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）, 同时，每个接口必须有请求方式 通过GET方式请求接口的过程 (post类似) 11. 接口测试工具PostMan 使用PostMan测试GET接口 选择请求的方式 填写请求的URL地址 填写请求的参数 点击Send 按钮发起GET 请求 查看服务器响应的结果 使用PostMan测试POST接口 选择请求的方式 填写请求的URL地址 选择Body 面板并勾选数据格式 填写要发送到服务器的数据 点击Send 按钮发起POST请求 查看服务器响应的结果 12. 接口文档 是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明 接口文档的组成部分: 接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等 接口URL：接口的调用地址 调用方式：接口的调用方式，如 GET 或 POST 参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容 响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容 返回示例（可选）：通过对象的形式，例举服务器返回数据的结构 01. form表单 表单作用：收集表单数据，从而提交给服务器 组成：表单标签form、表单域、提交按钮 其中表单域包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等 02. form表单属性表单属性: 用来规定如何把采集到的数据发送到服务器 属性 值 描述 action URL地址 规定当提交表单时，向何处发送表单数据 method get或post 规定以何种方式把表单数据提交到action URL enctype application&#x2F;x-www-form-urlencoded multipart&#x2F;form-datatext&#x2F;plain 规定在发送表单数据之前如何对其进行编码 target _ blank _ self _ parent _top framename 规定在何处打开 action URL action action 属性用来规定当提交表单时，向何处发送表单数据 action 属性的值是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。当表单在未指定 action 属性值，action 的默认值为当前页面的 URL 地址 注意：当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址 target target 属性用来规定在何处打开 action URL _blank 在新窗口中打开 _self 默认 在相同的框架中打开 _parent 在父框架集中打开（很少用） _top 在整个窗口中打开（很少用） framename 在指定的框架中打开（很少用） method method 属性用来规定以何种方式把表单数据提交到 action URL 它的可选值有两个，分别是 get 和 post 默认为 get，表示通过URL地址的形式，把表单数据提交到 action URL 提交的数据的格式：url地址?键&#x3D;值&amp;键&#x3D;值?键&#x3D;值&amp;键&#x3D;值 是查询字符串 指要提交的数据 在实际开发中， 表单的 post 提交方式用的最多 get post 区别 get 方式适合用来提交少量的、简单的数据 post 方式适合用来提交大量的、复杂的、或包含文件上传的数据, 数据大小不受限制 get 提交数据的时候，把数据放到url地址后面 post 提交数据的时候，没有数据放到url地址后面，放到请求体里面了 enctype enctype 属性用来规定在发送表单数据之前如何对数据进行编码 application&#x2F;x-www-form-urlencoded 在发送前编码所有字符（默认） multipart&#x2F;form-data 不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值 text&#x2F;plain 空格转换为 “+” 加号，但不对特殊字符编码。（很少用 03. 表单的同步提交 概念: 通过点击 submit 按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交 缺点: 网页发生了跳转,用户体验差 状态 + 数据丢失了 解决：表单只收集数据，ajax将数据提交给服务器 04. 通过Ajax提交表单数据 步骤: 给表单form 注册submit事件 阻止其默认行为 e.preventDefault() 收集表单数据， jQ提供了 serialize(), 必须要有name属性 ajax去发送请求 05. serialize()函数快速获取表单中的数据 01. 使用xhr发起GET请求XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源 XMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态 值 状态 描述 0 UNSENT XMLHttpRequest 对象已被创建，但尚未调用 open方法 1 OPENED open() 方法已经被调用 2 HEADERS_RECEIVED send() 方法已经被调用，响应头也已经被接收 3 LOADING 数据接收中，此时 response 属性中已经包含部分数据 4 DONE Ajax 请求完成，这意味着数据传输已经彻底完成或失败 02. 使用xhr发起POST请求 03. 查询字符串 定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量） 格式：将英文的 ? 放在URL 的末尾，然后再加上 参数＝值 ，想加上多个参数的话，使用 &amp; 符号进行分隔 GET请求携带参数的本质: 将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的 04. URL编码与解码URL编码原则：使用英文字符去表示非英文字符 encodeURI() 编码的函数 decodeURI() 解码的函数 05. 数据交换格式数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式 (XML 和 JSON) JSON: 本质：字符串 字符串表示JS数组和对象 数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型 规律： JSON 数据中不能出现 undefined 和 函数 键必须是双引号（不能没有双引号，不能使用单引号） 值如果是字符串的话，也必须使用双引号 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 2个方法 JSON.parse() 把JSON字符串转成 js对象 反序列化 JSON.stringify() 把 js对象转成 JSON字符串 序列化 06. XMLHttpRequest Level2的新特性 旧版XMLHttpRequest的缺点 只支持文本数据的传输，无法用来读取和上传文件 传送和接收数据时，没有进度信息，只能提示有没有完成 XMLHttpRequest Level2的新功能 可以设置 HTTP 请求的时限 可以使用 FormData 对象管理表单数据 可以上传文件 可以获得数据传输的进度信息 07. 设置HTTP请求时限 08. FormData对象管理表单数据 模拟表单操作 获取网页表单的值 09. 上传文件 步骤: 定义 UI 结构 验证是否选择了文件 向 FormData 中追加文件 使用 xhr 发起上传文件的请求 监听 onreadystatechange 事件 10. 显示文件上传进度 xhr.upload.onprogress 事件，可以获取到文件的上传进度 : xhr.upload.onload , 监听上传完成的事件 11. jQuery发起上传文件的请求 12. ajaxStart(callback) Ajax 请求开始时，执行 ajaxStart 函数 $(document).ajaxStart() 函数会监听当前文档内所有的 Ajax 请求 13. ajaxStop(callback) Ajax 请求结束时，执行 ajaxStop 函数 14. axios Axios 是专注于网络数据请求的库 相比于原生的 XMLHttpRequest 对象，axios 简单易用 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。 15. axios发起GET请求 16. axios发起POST请求 17. 直接使用axios发起请求 数据可视化 DAY01-可视化项目01-项目介绍​ 应对现在数据可视化的趋势，越来越多企业需要在很多场景(营销数据，生产数据，用户数据)下使用，可视化图表来展示体现数据，让数据更加直观，数据特点更加突出。我们引入 ‘立可得’ 数据可视化项目。 ​ 该项目除了使用了基础的DIV+CSS布局，还引入了一些C3技术，还引入了各类图表的绘制，以及高级的地图数据可视化案例。主要功能有：饼状图、柱状图、线形图、地图 … 02-使用技术完成该项目需要具备以下知识： div + css 布局 flex 布局 css3动画 css3渐变 css3边框图片 原生js + jquery 使用 rem适配 echarts基础 粗略代码统计： css 580行 html 450行 js 400行 (有效) 03-Echarts-介绍 ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8&#x2F;9&#x2F;10&#x2F;11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 大白话： 是一个JS插件 性能好可流畅运行PC与移动设备 兼容主流浏览器 提供很多常用图表，且可定制。 折线图、柱状图、散点图、饼图、K线图 04-Echarts-体验官方教程：[五分钟上手ECharts]( 分钟上手 ECharts) 自己步骤： 下载echarts  引入echarts dist/echarts.min.js 准备一个具备大小的DOM容器 初始化echarts实例对象 指定配置项和数据(option) 将配置项设置给echarts实例对象 05-Echarts-基础配置 需要了解的主要配置：series xAxis yAxis grid tooltip title legend color series 系列列表。每个系列通过 type 决定自己的图表类型 大白话：图标数据，指定什么类型的图标，可以多个图表重叠。 xAxis：直角坐标系 grid 中的 x 轴 boundaryGap: 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。 yAxis：直角坐标系 grid 中的 y 轴 grid：直角坐标系内绘图网格。 title：标题组件 tooltip：提示框组件 legend：图例组件 color：调色盘颜色列表 数据堆叠，同个类目轴上系列配置相同的stack值后 后一个系列的值会在前一个系列的值上相加。 演示代码： 06-REM适配 设计稿是1920px PC端适配： 宽度在 1024~1920之间页面元素宽高自适应 flexible.js 把屏幕分为 24 等份 cssrem 插件的基准值是 80px 插件-配置按钮—配置扩展设置–Root Font Size 里面 设置。 但是别忘记重启vscode软件保证生效 要把屏幕宽度约束在1024~1920之间有适配，实现代码： 07-基础布局html结构： 效果图： 1920px * 1078px body 设置背景图 ，行高1.15 viewport 主体容器，限制最小宽度1024px，与最大宽度1920px，最小高度780px。 需要居中显示 使用logo.png做为背景图，在容器内显示 内间距 88px 20px 0 column 列容器，分三列，占比 3：4：3 中间容器外间距 32px 20px 0 css样式： 08-边框图片 css3中自适应边框图片运用： 组合写法： 拆分写法： 解释： 边框图片资源地址 裁剪尺寸（上 右 下 左）单位默认px，可使用百分百。 边框图片的宽度，默认边框的宽度。 平铺方式： stretch 拉伸（默认） repeat 平铺，从边框的中心向两侧开始平铺，会出现不完整的图片。 round 环绕，是完整的使用切割后的图片进行平铺。 DEMO代码： 09-公用面板样式 所有的面板的基础样式是一致的，提前布局好。 切割示例图： 面板 .panel 容器 .inner 内边距是 上下24px 左右 36px 10-概览区域(overview)-布局html结构： 样式描述： 容器高度 110px h4字体 28px #fff 左边距 4.8px 下间隙 8px span字体 16px #4c9bfd 11-监控区域(monitor)-布局html结构： 监控区域 monitor 大盒子的高度是 480px 结构解释： .tabs 标签选项 加上active激活选项 默认激活第一个选项 .content 切换内容 加上style=&quot;display: block;&quot;显示内容 默认激活第一个内容 样式描述： .inner 容器内间距 24px 0 .tabs 容器内间距 0 36px a 容器 颜色： #1950c4 内间距：0 27px 字体：18px 第一个a容器 去除左侧内间距 加上右侧2px宽度边框#00f2f1 激活的时候 颜色白色 .content容器 占满剩余高度 flex:1 默认隐藏 .head 容器 行高 1.05 背景 rgba(255, 255, 255, 0.1) 内间距 12px 36px 颜色 #68d8fe 字体大小 14px row 容器 行高 1.05 内间距 12px 36px 颜色 #68d8ff 字体大小 12px .icon-dot 字体图标 绝对定位 左边0.2rem 透明度0 鼠标经过后：背景 rgba(255, 255, 255, 0.1) 透明度1 col容器 宽度：1rem 2.5rem 1rem 第二个col 一行不换行 溢出 省略 12-监控区域-效果切换功能： 绑定 标签页点击 事件 当前容器加active其他容器移除active index对应的内容容器显示其他容器隐藏 动画功能： 实现思路： 先克隆列表，追加在后面 marquee-view 占满剩余高度，溢出隐藏 绝对定位，top 1.6rem bottom 0 宽度100%，溢出隐藏 使用animation实现动画 使用 translateY 向上位移 50% 动画时间15s，匀速播放，循环执行。 js代码： css代码： 13-点位区域(point)-布局html结构： css样式： point 盒子高度为 340px 14-点位区域-饼图ECharts图表实现步骤： 从官方示例中找到类似图表，适当修改，引入到HTML页面中。 按照产品需求，来定制图表。 1. HTML引入图表 2. 定制需求第一步：参考官方例子，熟悉里面参数具体含义 第二步：按照需求定制 需求1：颜色设置 需求2：修改饼形图大小 ( series对象) 需求3： 把饼形图的显示模式改为 半径模式 需求4：数据使用更换（series对象 里面 data对象） 需求5：字体略小些 10 px ( series对象里面设置 ) 饼图图形上的文本标签可以控制饼形图的文字的一些样式。 label 对象设置 需求6：防止缩放的时候，引导线过长。引导线略短些 (series对象里面的 labelLine 对象设置 ) 连接图表 6 px 连接文字 8 px 需求6：浏览器缩放的时候，图表跟着自动适配。 点位统计完整JavaScript代码： 15-地图区域 (map) -预留布局html结构： css样式： 注意第二列（column) 有个外边距（上面 32px 左右 20px 下是 0） 16-用户统计 (users) -布局html结构： css样式： 17-用户统计 (users) -柱状图实现步骤： 从官方示例中找到最接近项目需求的例子，适当修改, 引入到HTML页面中 按照产品需求，来定制图表。 第一步：参考官方示例 + 分析 第二步：按照需求修改 需求1： 修改柱子的颜色 需求2： 提示框组件放到柱子上触发， 没有阴影等效果 需求3： 修改柱形图表大小， 以及相关网格。 饼形图修改图表大小是通过 series 对象里面的 radius 柱形图修改图标大小是通过 series 对象里面的 grid 对象 left right 等 显示网格 show: true，网格颜色是 borderColor 需求4： X 轴调整 柱子在刻度之间 剔除刻度不显示 刻度标签文字颜色 #4c9bfd 通过 axisLabel 对象设置 修改x轴线的颜色 axisLine 里面的 lineStyle 需求5： Y 轴调整 剔除刻度不显示 Y轴文字颜色 #4c9bfd 通过 axisLabel 对象设置 Y轴分割线颜色 splitLine 对象里面 lineStyle 对象设置 需求6：调整数据，与省略图形定制 省略图形 经过图形才显示提示，且省略的柱子不需要提示 图形单独设置颜色 18-订单区域（order）-布局html结构： css样式： 18-订单区域（order）-效果 ( 课后作业 )实现步骤： 提前准备数据 点击后切tab激活样式 点击后切换数据内容 开启定时器动态切换数据 19-销售统计( sales )-布局html结构： css样式： 19-销售统计( sales )-线形图实现步骤： 寻找官方的类似示例，给予分析, 引入到HTML页面中 按照需求来定制它。 第一步：寻找官方的类似示例，给予分析。 官方参考示例： 第二步：按照需求来定制它。 需求1： 修改折线图大小，显示边框设置颜色：#012f4a，并且显示刻度标签。 需求2： 修改图例组件中的文字颜色 #4c9bfd， 距离右侧 right 为 10% 需求3： x轴相关配置 刻度去除 x轴刻度标签字体颜色：#4c9bfd 剔除坐标轴线颜色（将来使用Y轴分割线) 轴两端是不需要内间距 boundaryGap 需求4： y轴的定制 刻度去除 字体颜色：#4c9bfd 分割线颜色：#012f4a 需求5： 两条线形图定制 颜色分别：#00f2f1 #ed3f35 把折线修饰为圆滑 series 数据中添加 smooth 为 true 需求6： 配置数据 总结：现在给的是年份数据，还需要切换效果。 19-销售统计( sales )-切换效果实现步骤： 准备切换需要依赖的数据 4组 绑定点击事件 切换激活 tab 的样式 切换图表依赖的数据（重新渲染图表） 开启定时器，进行切换， 鼠标经过sales停止定时器，离开开启定时器 第一步：准备数据，使用数据 第二步：点击后切换 第三步：tab栏自动切换效果 开启定时器每隔3s，自动让a触发点击事件即可 鼠标经过sales，关闭定时器，离开开启定时器 自动缩放 20-渠道区域&amp;销售进度-布局html结构： css样式： 21-渠道分布(channel)-雷达图实现步骤： 寻找官方的类似示例，给予分析，并引入到HTML页面中 按照需求来定制它 第一步： 参考类似实例：  第二步： 按照需求来定制它 需求1： 去掉背景颜色，调整雷达图大小 65% 需求2： 指示器轴的分割段数为4条（4个圆圈） 需求3： 雷达图分割线设为白色半透明 0.5 需求4： 雷达图 坐标轴轴线相关设置(竖线) axisLine 需求5： 修饰雷达图文字颜色为 #4c9bfd 需求6： 修饰 区域填充样式 series 对象 区域填充的背景颜色设置为： rgba(238, 197, 102, 0.6) 区域填充的线条颜色为白色 需求7： 标记的图形(拐点）设置 注意 series 里面设置 用圆点显示， 拐点的大小设置为 5 小圆点设置为白色 在小圆点上显示相关数据，颜色设置为白色，10像素 需求8： 鼠标经过显示提示框组件 需求9： 更换数据 整个代码 22-销售进度 (quarter) -饼状图实现步骤： 寻找官方的类似示例，给予分析,引入到HTML页面中 按照需求来定制它。 第一步：参考官方示例： 第二步：进行定制 需求1：改成半圆，图表大一些，让50%文字在中心。 需求2：鼠标经过无需变大，修改第一段颜色渐变#00c9e0-&gt;#005fc1，修改第二段颜色#12274d。 23-热销排行（top）-布局html结构： css样式： 23-热销排行（top）-效果实现思路： 准备后台返回的真实数据 利用数据渲染各省热销模块 sup 模块 (拼接html格式字符串，进行渲染) 当鼠标进入 tab 的时候 激活当前的tab样式，删除其他tab的样式 渲染各省热销 sub 模块 (拼接html格式字符串，进行渲染) 默认激活第一个tab的效果 开启定时器，按依次切换 预备知识： 扩展知识：ES6模版字符 开始实现： 第一步：得到后台数据（实际开发中，这个数据通过ajax请求获得） 第二步：根据数据渲染各省热销 sup 模块内容 删掉原先自带小li 遍历数据 $.each() 拼接字符串把数据渲染到 li 的span 里面 追加给 .sup 盒子 第三步：当数据进入 tab 的时候 激活当前的tab样式，删除其他tab的样式 渲染各省热销 sub 模块 注意鼠标进入tab， 只遍历 当前索引号对应的 城市对象里面的 brands 拼接html格式字符串，进行渲染 第四步：默认激活第一个tab 第五步：开启定时切换 定时器里面 mouseenter 冲突问题的解决方案 定时器里面不加mousenter 事件，而是直接重新渲染数据就可以(执行鼠标经过事件里面的代码) 最好把渲染的代码封装到函数里面 24-Echarts-社区介绍 社区就是一些，活跃的echart使用者，交流和贡献定制好的图表的地方。 在这里可以找到一些基于echart的高度定制好的图表，相当于基于jquery开发的插件，这里是基于echarts开发的第三方的图表。 25-Echarts-map使用（扩展）参考社区的例子： (模拟飞机航线) 实现步骤： 第一需要下载china.js提供中国地图的js文件 第二个因为里面代码比较多，我们新建一个新的js文件 myMap.js 引入 使用社区提供的配置即可。 需要修改： 去掉图例组件和标题组件 去掉背景颜色 修改地图省份背景 #142957 地图放大通过 zoom 设置为1.2即可 AJAX 原生AJAXGET获取 POST请求 JOSN 本质是字符串，用于处理数据 序列化：数据对象转为自字符串，JOSN.stringIfy() 反序列化：字符串转为数据对象，JOSN.parse() 自己封装ajax函数 Ajaxday0101. URL地址的组成部分 客户端与服务器之间的通信协议 存有该资源的服务器名称 资源在服务器上具体的存放位置 02. 客户端与服务器的通信过程 客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤 03. 网页中如何请求数据 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象 最简单的用法 const xhr &#x3D; new XMLHttpRequest() 04. 资源的请求方式 get 请求通常用于获取服务端资源（向服务器要资源） post 请求通常用于向服务器提交数据（往服务器发送资源） 05. Ajax概念 Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML） 在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax Ajax能让我们轻松实现网页与服务器之间的数据交互 06. jQuery中的Ajax 浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数 jQuery 中发起 Ajax 请求最常用的三个方法如下： $.get() $.post() $.ajax() 07. $.get()函数的语法 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 08. $.post()函数的语法 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 09. $.ajax()函数的语法 10. 接口 概念: 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）, 同时，每个接口必须有请求方式 通过GET方式请求接口的过程 (post类似) 11. 接口测试工具PostMan 使用PostMan测试GET接口 选择请求的方式 填写请求的URL地址 填写请求的参数 点击Send 按钮发起GET 请求 查看服务器响应的结果 使用PostMan测试POST接口 选择请求的方式 填写请求的URL地址 选择Body 面板并勾选数据格式 填写要发送到服务器的数据 点击Send 按钮发起POST请求 查看服务器响应的结果 12. 接口文档 是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明 接口文档的组成部分: 接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等 接口URL：接口的调用地址 调用方式：接口的调用方式，如 GET 或 POST 参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容 响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容 返回示例（可选）：通过对象的形式，例举服务器返回数据的结构 day0201. form表单 表单作用：收集表单数据，从而提交给服务器 组成：表单标签form、表单域、提交按钮 其中表单域包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等 02. form表单属性表单属性: 用来规定如何把采集到的数据发送到服务器 属性 值 描述 action URL地址 规定当提交表单时，向何处发送表单数据 method get或post 规定以何种方式把表单数据提交到action URL enctype application&#x2F;x-www-form-urlencoded multipart&#x2F;form-datatext&#x2F;plain 规定在发送表单数据之前如何对其进行编码 target _ blank _ self _ parent _top framename 规定在何处打开 action URL action action 属性用来规定当提交表单时，向何处发送表单数据 action 属性的值是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。当表单在未指定 action 属性值，action 的默认值为当前页面的 URL 地址 注意：当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址 target target 属性用来规定在何处打开 action URL _blank 在新窗口中打开 _self 默认 在相同的框架中打开 _parent 在父框架集中打开（很少用） _top 在整个窗口中打开（很少用） framename 在指定的框架中打开（很少用） method method 属性用来规定以何种方式把表单数据提交到 action URL 它的可选值有两个，分别是 get 和 post 默认为 get，表示通过URL地址的形式，把表单数据提交到 action URL 提交的数据的格式：url地址?键&#x3D;值&amp;键&#x3D;值?键&#x3D;值&amp;键&#x3D;值 是查询字符串 指要提交的数据 在实际开发中， 表单的 post 提交方式用的最多 get post 区别 get 方式适合用来提交少量的、简单的数据 post 方式适合用来提交大量的、复杂的、或包含文件上传的数据, 数据大小不受限制 get 提交数据的时候，把数据放到url地址后面 post 提交数据的时候，没有数据放到url地址后面，放到请求体里面了 enctype enctype 属性用来规定在发送表单数据之前如何对数据进行编码 application&#x2F;x-www-form-urlencoded 在发送前编码所有字符（默认） multipart&#x2F;form-data 不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值 text&#x2F;plain 空格转换为 “+” 加号，但不对特殊字符编码。（很少用 03. 表单的同步提交 概念: 通过点击 submit 按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交 缺点: 网页发生了跳转,用户体验差 状态 + 数据丢失了 解决：表单只收集数据，ajax将数据提交给服务器 04. 通过Ajax提交表单数据 步骤: 给表单form 注册submit事件 阻止其默认行为 e.preventDefault() 收集表单数据， jQ提供了 serialize(), 必须要有name属性 ajax去发送请求 05. serialize()函数快速获取表单中的数据 day0301. 使用xhr发起GET请求XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源 XMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态 值 状态 描述 0 UNSENT XMLHttpRequest 对象已被创建，但尚未调用 open方法 1 OPENED open() 方法已经被调用 2 HEADERS_RECEIVED send() 方法已经被调用，响应头也已经被接收 3 LOADING 数据接收中，此时 response 属性中已经包含部分数据 4 DONE Ajax 请求完成，这意味着数据传输已经彻底完成或失败 02. 使用xhr发起POST请求 03. 查询字符串 定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量） 格式：将英文的 ? 放在URL 的末尾，然后再加上 参数＝值 ，想加上多个参数的话，使用 &amp; 符号进行分隔 GET请求携带参数的本质: 将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的 04. URL编码与解码URL编码原则：使用英文字符去表示非英文字符 encodeURI() 编码的函数 decodeURI() 解码的函数 05. 数据交换格式数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式 (XML 和 JSON) JSON: 本质：字符串 字符串表示JS数组和对象 数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型 规律： JSON 数据中不能出现 undefined 和 函数 键必须是双引号（不能没有双引号，不能使用单引号） 值如果是字符串的话，也必须使用双引号 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 2个方法 JSON.parse() 把JSON字符串转成 js对象 反序列化 JSON.stringify() 把 js对象转成 JSON字符串 序列化 06. XMLHttpRequest Level2的新特性 旧版XMLHttpRequest的缺点 只支持文本数据的传输，无法用来读取和上传文件 传送和接收数据时，没有进度信息，只能提示有没有完成 XMLHttpRequest Level2的新功能 可以设置 HTTP 请求的时限 可以使用 FormData 对象管理表单数据 可以上传文件 可以获得数据传输的进度信息 07. 设置HTTP请求时限 08. FormData对象管理表单数据 模拟表单操作 获取网页表单的值 09. 上传文件 步骤: 定义 UI 结构 验证是否选择了文件 向 FormData 中追加文件 使用 xhr 发起上传文件的请求 监听 onreadystatechange 事件 10. 显示文件上传进度 xhr.upload.onprogress 事件，可以获取到文件的上传进度 : xhr.upload.onload , 监听上传完成的事件 11. jQuery发起上传文件的请求 12. ajaxStart(callback) Ajax 请求开始时，执行 ajaxStart 函数 $(document).ajaxStart() 函数会监听当前文档内所有的 Ajax 请求 13. ajaxStop(callback) Ajax 请求结束时，执行 ajaxStop 函数 14. axios Axios 是专注于网络数据请求的库 相比于原生的 XMLHttpRequest 对象，axios 简单易用 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。 15. axios发起GET请求 16. axios发起POST请求 17. 直接使用axios发起请求 git sidebar: autopermalink: &#x2F;git_base Gitgit基础入门 Git是一款免费、开源的分布式 版本控制系统 ，用于敏捷高效地处理任何或小或大的项目。 思考：为什么要学习git 思考：git的好处是什么 git的安装下载地址 注意：不要安装在中文目录 安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。 说明：Mac的安装可以查看官网说明在 macOS 上安装 在终端里尝试首次运行 git 命令即可。如果没有安装过git，将会提示你安装。 git三个区 要对某个项目使用git进行管理，需要使用git init命令初始化git仓库 git init会在当前目录生成一个隐藏文件夹 .git 不要去修改这个文件夹下的任意东西。 git仓库会分成三个区 工作区：我们书写代码的地方，工作的目录就叫工作区。 暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。 仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。 git基本命令git init作用：初始化git仓库，想要使用git对某个项目进行管理，需要git init进行初始化 git add作用：将文件由 工作区 添加到 暂存区，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。 命令：git add 文件名/目录名 git commit作用：将文件由 暂存区 添加到 仓库区，生成版本号（存档） git config配置如果是第一次提交，需要配置提交者信息 这两条配置是很重要的，每次提交 git 代码都会引用这两条信息，记录了谁提交了代码，会永久的记录在历史记录中。 git status作用：查看文件的状态 命令：git status 红色表示工作区中的文件需要提交 绿色表示暂存区中的文件需要提交 git log作用：查看提交日志 git log 查看提交的日志 git重置git reset作用：版本回退，将代码恢复到已经提交的某一个版本中。 git reset --hard 版本号 将代码回退到某个指定的版本(版本号只要有前几位即可) 当使用了git reset命令后，版本会回退，使用git log只能看到当前版本之前的信息。git reflog 查看仓库中所有的提交日志信息 git log –oneline 可以一行输出提交日志信息 git忽视文件 在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules文件夹等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。 在仓库的根目录创建一个.gitignore的文件，文件名是固定的。 将不需要被git管理的文件路径添加到.gitignore中 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 复习 git分支操作分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 为什么要有分支？ 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。 git分支命令创建分支 git branch 分支名称创建分支，分支中的代码，在创建时与当前分支的内容完全相同。 git在第一次提交时，就有了一个叫master的主分支。 git branch dev，创建了一个叫做dev的分支 查看分支 git branch可以查看所有的分支 在当前分支的前面会有一个* 切换分支 git checkout 分支名称切换分支 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。 提交代码时，会生产版本号 创建并切换分支 git checkout -b 分支名称 创建并切换分支 删除分支 git branch -d 分支名称 可以删除分支 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。 注意：master分支是可以删除的，但是不推荐那么做。 合并分支 git merge 分支名称 将其他分支的内容合并到当前分支。 在master分支中执行git merge dev 将dev分支中的代码合并到master分支 分支合并 git合并冲突 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。 git远程仓库 以后公司会有一台服务器作为公司的远程仓库。 github与gitgit与github没有直接的关系。 git是一个版本控制工具。 github是一个代码托管平台，开源社区，是git的一个远程代码仓库。 gitHub是一个托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 创建git项目时，不能有中文。 github官网 开源中国-git git clone 作用：克隆远程仓库的代码到本地 git clone [远程仓库地址] git克隆默认会使用远程仓库的项目名字，也可以自己指定。 需要是使用以下命令：git clone [远程仓库地址] [本地项目名] git push 作用：将本地仓库中代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 git pull 作用：将远程的代码下载到本地 通常在push前，需要先pull一次。 git remote每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名 SSH免密码登陆git支持多种数据传输协议： https协议： 需要输入用户名和密码 ssh协议：git@github.com:webman158/demo76.git 可以配置免密码登录 每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码 SSH免密码登录配置注意：这些命令需要在bash中敲 1 创建SSH Key：ssh-keygen -t rsa 敲3次回车 2 在文件路径 C:\\用户\\当前用户名\\ 找到 .ssh 文件夹 3 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 4 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 5 粘贴 公钥 id_rsa.pub 内容到对应文本框中 5 在github中新建仓库或者使用现在仓库，拿到git@github.com:用户名/仓库名.git 6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了 vue基操 定义：vue是渐进式js框架！现下载yarn（推荐）或者npm，搭配环境 下载地址:  mac如果没安装过homeBrew先运行这个命令 上面命令不行: 试试这个: curl -o- -L  | bash (直接安装yarn) 安装vue及脚手架 命令：yarn global add @vue&#x2F;cli vue -V 查看版本 yarn使用设置淘宝镜像 创建项目 vue create vuecli-demo 可自行选择版本{vue2&#x2F;&#x2F;&#x2F;vue3}和配置{less….} vue.config.js配置修改后 要重新执行yarn serve（启动服务器） 命令 项目内文件src：业务文件夹​ assets ：静态资源（图片、字体图标等） ​ main.js 打包入口 文件，引入vue对象 {import App from ‘.&#x2F;09_vue_过滤器.vue’} ​ App.vue：整个应用的根组件 vue页面的入口，再次编写代码 过滤器 ：filters 局部使用,写在需要使用的App.vue文件内，与data同级 vue计算属性：computedcomputed：与data同级；计算属性和data属性都是变量-不能重名； 函数内变量变化, 会自动重新计算结果返回 侦听器：watchwatch：与data同级 侦听data computed 侦听复杂数据 vue组件：component使用: 把组件名 当标签名来使用 全局 局部 2.vue组件-scoped作用目的: 解决多个组件样式名相同, 冲突问题 只在当前的组件内生效 3.组件内通信 父传子1.在子组件上,通过props来指定 属性,将来通过属性来接收父传给子的数据 2.在父组件上,通过属性来传值 3.单向数据流 (从父到子的数据流向) 在vue中需要遵循单向数据流原则 4.组件内通信 子传父1.在子组件上 通过this.$emit(‘自定义事件’,值)触发自定义事件,以及还可以传参 2.在父组件上,监听自定义事件 components ：组件目录public 静态文件夹&#x3D;&gt;index.heml：浏览器真正运行的网页node_modules：第三方包 一般要在.gitignore文件进行忽略（根目录已经处理过）Vue语法 VUE-组件 1.组件进阶 - 动态组件 动态组件 vue内置的component 组件 2.组件进阶 - 组件缓存目标: 组件切换会导致组件被频繁销毁和重新创建, 性能不高 使用Vue内置的keep-alive组件, 可以让包裹的组件保存在内存中不被销毁 3.组件进阶 - 激活和非激活 目标: 被缓存的组件不再创建和销毁, 而是激活和非激活 补充2个钩子方法名: ​ activated – 激活时触发 ​ deactivated – 失去激活状态触发 4.组件进阶 - 组件插槽语法口诀: 组件内用占位 使用组件时夹着的地方, 传入标签替换slot 5.组件进阶 - 插槽默认内容 目标: 如果外面不给传, 想给个默认显示内容 口诀: 夹着内容默认显示内容, 如果不给插槽slot传东西, 则使用夹着的内容在原地显示 6.组件进阶 - 具名插槽 &#x2F;&#x2F; 目标: 具名插槽 &#x2F;&#x2F; 场景: 2处以上不确定的地方 &#x2F;&#x2F; 1. slot占位 - name属性起名字 &#x2F;&#x2F; 2. 使用组件, template配合v-slot:插槽名, 夹着传入具体标签 v-slot: 可以简化成# 总结: slot的name属性起插槽名, 使用组件时, template配合#插槽名传入具体标签 7.组件进阶 - 作用域插槽&#x2F;&#x2F; 目标: 作用域插槽 &#x2F;&#x2F; 场景: 使用插槽, 使用组件内的变量 slot标签, 自定义属性和内变量关联 使用组件, template配合v-slot&#x3D;”变量名” 变量名会收集slot身上属性和值形成对象 8.自定义指令目标: 创建 “自定义指令”, 让输入框自动聚焦 创建自定义指令 全局 &#x2F; 局部 在标签上使用自定义指令 v-指令名 注意: inserted方法 - 指令所在标签, 被插入到网页上触发(一次) update方法 - 指令对应数据&#x2F;标签更新时, 此方法执行 1.全局注册 2.局部注册 9.案例 router VUE-Router main.js 拦截器 路由守卫&#x2F;&#x2F; 全局的导航守卫&#x2F;&#x2F; 需要登录的页面&#x2F;&#x2F; 只要导航发生跳转，都会先执行beforeEach的函数&#x2F;&#x2F; 守卫的思路&#x2F;&#x2F; 1. 判断是否有token 如果有 直接放行&#x2F;&#x2F; 2. 如果没有token,,判断去的页面是否需要登录&#x2F;&#x2F; 3. 如果去的页面不需要登录，放行&#x2F;&#x2F; 4. 如果去的页面需要登录，拦截到登录页面。 &#x2F;&#x2F; 需要登陆才能访问的页面 将这些页面放入数组中，遍历查询对比const privateURL &#x3D; [‘&#x2F;user’, ‘&#x2F;user&#x2F;chat’, ‘&#x2F;user&#x2F;profile’, ‘&#x2F;qa’, ‘&#x2F;user&#x2F;edit’] VUEX vuex概念 vue全家桶：vue + vue-router + vuex + vue-cli 目标： 了解vuex的应用场景 (在哪用) 掌握vuex的基本使用 (怎么用) 常见的组件通讯方案 在现代化开发中，组件化已经成为主流开发了。 组件的数据是独立的, 每个组件有着自己的状态(数据) 在实际开发中，一个组件需要访问另一个组件中的数据是非常常见的。这时候需要进行组件通讯。 常见的组件通讯 父传子 props 子传父 $emit event bus 通用组件通讯的解决方案 为什么要有vuex vuex的作用是解决多组件状态共享的问题，在大型的项目中，组件通讯会变得很混乱，使用vuex可以统一管理组件之间的通讯 它是独立于组件而单独存在的，所有的组件都可以把它当作一座桥梁来进行通讯。 与事件总线（EventBus）相比，它具备额外的特点： 响应式 操作更简洁 项目越大，vuex越清晰 vuex缺点：vuex功能非常的强大，但是vuex的要求也特别的多。如果是小项目，使用vuex收益不高，如果是大型项目。适合使用vuex vuex基本概念vuex是vue的状态管理工具，状态即数据。 状态管理就是集中管理vue中通用的一些数据 注意： 不是所有的场景都适用于vuex，只有在必要的时候才使用vuex,如果不必要，尽量别用 使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度 vuex架构就像眼镜：您自会知道什么时候需要它。 vuex入门初始化vuex项目 初始化命令 vue项目如何配置自动打开浏览器 多组件共享数据(1)app.vue (2)Man.vue (3)Women.vue (4)Three.vue vuex 的使用 - 创建仓库1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。 2 新建 store/index.js 专门存放 vuex ​ 为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 router/index.js 类似) 3 创建仓库 store/index.js 4 在 main.js 中导入挂载到 Vue 实例上 此刻起, 就成功创建了一个空仓库!! 核心概念 - state 状态State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。 state提供数据打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。 问题: 如何在组件中获取money? 组件直接获取数据所有的组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取money， 如下 &#x3D;&#x3D;缺点：如果vuex中的某个数据在组件中需要多次使用，会很麻烦&#x3D;&#x3D; 计算属性计算属性 - 将state属性定义在计算属性中  &#x3D;&#x3D;如果某个组件需要用到vuex中多个状态，需要创建多个计算属性&#x3D;&#x3D; 但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法 辅助函数-mapState mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法 用法 ： 第一步：导入mapState (mapState是vuex中的一个函数) 第二步：采用数组形式引入state属性 上面代码的最终得到的是 类似于 mapState配合展开运算符如果直接使用mapState,会导致组件无法提供自己的计算属性，需要配合展开运算符使用 mapState可以是对象如果需要对vuex中的数据进行重命名的时候，会使用对象的形式 核心概念 - mutations state数据的修改只能通过mutations，并且mutations必须是同步的 严格模式 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。 基本使用&#x3D;&#x3D;state是vuex提供数据的，mutations是vuex提供修改数据的方法的。。修改数据只能通过mutations&#x3D;&#x3D; 定义mutations 格式说明 mutations是一个对象，对象中存放修改state的方法 组件中提交 mutations 带参数的 mutation1 提供mutation函数 2 提交mutation,需要传递额外的参数 小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象 payload 载荷 指的就是mutations的额外参数，payload是一个对象，因为可以传递多个参数，而且更好阅读 辅助函数 - mapMutations mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入 上面代码的含义是将mutations的方法导入了methods中，等价于 此时，就可以直接通过this.addCount调用了 但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中 核心概念-actions state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)， actions则负责进行异步操作 需求: 一秒钟之后, 要给一个数 去修改state 定义actions 原始调用 - $store (支持传参) 辅助函数 -mapActions actions也有辅助函数，可以将action导入到组件中 直接通过 this.方法 就可以调用 核心概念-getters 除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters 给vuex也提供计算属性 提供一个昵称 使用getters 原始方式 -$store 辅助函数 - mapGetters mapGetters和mapState的功能差不都，，mapGetters把vuex的getters映射为组件的计算属性 todos案例vuex-模块化Vuex中的模块化-Module为什么会有模块化？ 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护 由此，又有了Vuex的模块化 模块化的简单应用应用 定义两个模块 user 和 setting user中管理用户的状态 token setting中管理 网站的名称 name 定义App.vue组件，分别显示用户的token和应用名称name 请注意： 此时要获取子模块的状态 需要通过 $store.state.模块名称.属性名 来获取 看着获取有点麻烦，我们可以通过之前学过的getters来改变一下 请注意：这个getters是根级别的getters哦 通过mapGetters引用 模块化中的命名空间默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 这句话的意思是 刚才的user模块还是setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用 如 命名空间 namespaced 如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置 高封闭性？可以理解成 一家人如果分家了，此时，你的爸妈可以随意的进出分给你的小家，你觉得自己没什么隐私了，我们可以给自己的房门加一道锁（命名空间 namespaced）,你的父母再也不能进出你的小家了 如 使用带命名空间的模块 action/mutations 方案1：直接调用-带上模块的属性名路径 方案2：辅助函数-带上模块的属性名路径 vue-组件 vue-路由 "}]